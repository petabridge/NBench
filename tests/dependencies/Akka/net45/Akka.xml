<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Akka</name>
    </assembly>
    <members>
        <member name="T:Akka.Actor.IActorState">
            <summary>
            This interface represents the parts of the internal actor state; the behavior stack, watched by, watching and termination queue
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorState.RemoveWatching(Akka.Actor.IActorRef)">
            <summary>
            Removes the provided <see cref="T:Akka.Actor.IActorRef"/> from the `Watching` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be removed</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.RemoveWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            Removes the provided <see cref="T:Akka.Actor.IActorRef"/> from the `WatchedBy` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be removed</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.RemoveTerminated(Akka.Actor.IActorRef)">
            <summary>
            Removes the provided <see cref="T:Akka.Actor.IActorRef"/> from the `Termination queue` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be removed</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.AddWatching(Akka.Actor.IActorRef)">
            <summary>
            Adds the provided <see cref="T:Akka.Actor.IActorRef"/> to the `Watching` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be added</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.AddWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            Adds the provided <see cref="T:Akka.Actor.IActorRef"/> to the `WatchedBy` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be added</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.AddTerminated(Akka.Actor.IActorRef)">
            <summary>
            Adds the provided <see cref="T:Akka.Actor.IActorRef"/> to the `Termination queue` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to be added</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ClearWatching">
            <summary>
            Clears the `Watching` set
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ClearTerminated">
            <summary>
            Clears the `Termination queue` set
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ClearBehaviorStack">
            <summary>
            Clears the `Behavior` stack
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.Become(Akka.Actor.Receive)">
            <summary>
            Replaces the current receive behavior with a new behavior
            </summary>
            <param name="receive">The new behavior</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.BecomeStacked(Akka.Actor.Receive)">
            <summary>
            Pushes a new receive behavior onto the `Behavior` stack
            </summary>
            <param name="receive">The new top level behavior</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.UnbecomeStacked">
            <summary>
            Removes the top level receive behavior from the `Behavior` stack
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ContainsWatching(Akka.Actor.IActorRef)">
            <summary>
            Determines whether the provided <see cref="T:Akka.Actor.IActorRef"/> is present in the `Watching` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to locate in the `Watching` set</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ContainsWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            Determines whether the provided <see cref="T:Akka.Actor.IActorRef"/> is present in the `WatchedBy` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to locate in the `WatchedBy` set</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.ContainsTerminated(Akka.Actor.IActorRef)">
            <summary>
            Determines whether the provided <see cref="T:Akka.Actor.IActorRef"/> is present in the `Termination queue` set
            </summary>
            <param name="actor">The <see cref="T:Akka.Actor.IActorRef"/> to locate in the `Termination queue` set</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.GetWatching">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> over the `Watching` set
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.GetWatchedBy">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> over the `WatchedBy` set
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.Getterminated">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> over the `Termination queue` set
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorState.GetCurrentBehavior">
            <summary>
            Returns the top level receive behavior from the behavior stack
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.DefaultActorState">
            <summary>
            Represents the default start up state for any actor.
            This state provides capacity for one `WatchedBy` and one `Receive` behavior
            As soon as this container is no longer enough to contain the current state
            The state container will escalate into a `FullActorState` instance
            </summary>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.RemoveWatching(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.RemoveWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.RemoveTerminated(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.AddWatching(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.AddWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.AddTerminated(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.ContainsWatching(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.ContainsWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.ContainsTerminated(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.GetWatching">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.GetWatchedBy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.Getterminated">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.ClearWatching">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.ClearTerminated">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.Become(Akka.Actor.Receive)">
            <summary>
            TBD
            </summary>
            <param name="receive">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.BecomeStacked(Akka.Actor.Receive)">
            <summary>
            TBD
            </summary>
            <param name="receive">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.UnbecomeStacked">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.ClearBehaviorStack">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DefaultActorState.GetCurrentBehavior">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.FullActorState">
            <summary>
            Represents the full state of an actor, this is used whenever an actor need more state than the `DefaultActorState` container can contain
            </summary>
        </member>
        <member name="M:Akka.Actor.FullActorState.RemoveWatching(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.RemoveWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.RemoveTerminated(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.AddWatching(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.AddWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.AddTerminated(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.ContainsWatching(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.ContainsWatchedBy(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.ContainsTerminated(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.GetWatching">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.GetWatchedBy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.Getterminated">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.ClearWatching">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.ClearTerminated">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.Become(Akka.Actor.Receive)">
            <summary>
            TBD
            </summary>
            <param name="receive">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.BecomeStacked(Akka.Actor.Receive)">
            <summary>
            TBD
            </summary>
            <param name="receive">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.UnbecomeStacked">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.ClearBehaviorStack">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FullActorState.GetCurrentBehavior">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.Status">
            <summary>
            Classes for passing status back to the sender.
            Used for internal ACKing protocol, but also exposed as a utility class for user-specific ACKing if needed.
            </summary>
        </member>
        <member name="T:Akka.Actor.Status.Success">
            <summary>
            Indicates the success of some operation which has been performed
            </summary>
        </member>
        <member name="F:Akka.Actor.Status.Success.Status">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Status.Success.#ctor(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="status">TBD</param>
        </member>
        <member name="T:Akka.Actor.Status.Failure">
            <summary>
            Indicates the failure of some operation that was requested and includes an
            <see cref="T:System.Exception"/> describing the underlying cause of the problem.
            </summary>
        </member>
        <member name="F:Akka.Actor.Status.Failure.Cause">
            <summary>
            The cause of the failure
            </summary>
        </member>
        <member name="M:Akka.Actor.Status.Failure.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Status.Failure"/> class.
            </summary>
            <param name="cause">The cause of the failure</param>
        </member>
        <member name="M:Akka.Actor.Status.Failure.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.ILogReceive">
            <summary>
                Interface ILogReceive
            </summary>
        </member>
        <member name="T:Akka.Actor.IInternalActor">
            <summary>
            Contains things needed by the framework
            </summary>
        </member>
        <member name="P:Akka.Actor.IInternalActor.ActorContext">
            <summary>Gets the context for this instance.</summary>
            <value>The context.</value>
            <exception cref="T:System.NotSupportedException">
            This exception is thrown if there is no active Context. The most likely cause is due to use of async operations from within this actor.
            </exception>
        </member>
        <member name="T:Akka.Actor.ActorBase">
            <summary>
                Class ActorBase.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.ActorBase" /> class.
            </summary>
            <exception cref="T:Akka.Actor.ActorInitializationException">
            This exception is thrown when an actor is created using <c>new</c>. Always create actors using an ActorContext/System.
            </exception>
        </member>
        <member name="P:Akka.Actor.ActorBase.Sender">
            <summary>
                Gets the sending ActorRef of the current message
            </summary>
            <value>The sender ActorRef</value>
        </member>
        <member name="P:Akka.Actor.ActorBase.Self">
            <summary>
                Gets the self ActorRef
            </summary>
            <value>Self ActorRef</value>
        </member>
        <member name="P:Akka.Actor.ActorBase.Akka#Actor#IInternalActor#ActorContext">
            <summary>
                Gets the context.
            </summary>
            <value>The context.</value>
            <exception cref="T:System.NotSupportedException">
            This exception is thrown if there is no active ActorContext. The most likely cause is due to use of async operations from within this actor.
            </exception>
        </member>
        <member name="P:Akka.Actor.ActorBase.Context">
            <summary>
                Gets the context.
            </summary>
            <value>The context.</value>
            <exception cref="T:System.NotSupportedException">
            This exception is thrown if there is no active Context. The most likely cause is due to use of async operations from within this actor.
            </exception>
        </member>
        <member name="M:Akka.Actor.ActorBase.AroundReceive(Akka.Actor.Receive,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="receive">TBD</param>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorBase.Receive(System.Object)">
            <summary>
                Processor for user defined messages.
            </summary>
            <param name="message">The message.</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.ActorBase.EmptyReceive">
            <summary>
            EmptyReceive is a Receive-delegate that matches no messages at all, ever.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.Unhandled(System.Object)">
            <summary>
            Is called when a message isn't handled by the current behavior of the actor
            by default it fails with either a <see cref="T:Akka.Actor.DeathPactException"/> (in
            case of an unhandled <see cref="T:Akka.Actor.Terminated"/> message) or publishes an <see cref="T:Akka.Event.UnhandledMessage"/>
            to the actor's system's <see cref="T:Akka.Event.EventStream"/>
            </summary>
            <param name="message">The unhandled message.</param>
            <exception cref="T:Akka.Actor.DeathPactException">
            This exception is thrown if the given <paramref name="message"/> is a <see cref="T:Akka.Actor.Terminated"/> message.
            </exception>
        </member>
        <member name="M:Akka.Actor.ActorBase.Become(Akka.Actor.Receive)">
            <summary>
            Changes the actor's command behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.BecomeStacked(Akka.Actor.Receive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.ActorBase.BecomeStacked(Akka.Actor.Receive)"/>
            is matched with a call to <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.UnbecomeStacked">
            <summary>
            Reverts the Actor behavior to the previous one on the behavior stack.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.Clear(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.Unclear">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.SetReceiveTimeout(System.Nullable{System.TimeSpan})">
            <summary>
            <para>
            Defines the inactivity timeout after which the sending of a <see cref="T:Akka.Actor.ReceiveTimeout"/> message is triggered.
            When specified, the receive function should be able to handle a <see cref="T:Akka.Actor.ReceiveTimeout"/> message.
            </para>
            
            <para>
            Please note that the receive timeout might fire and enqueue the <see cref="T:Akka.Actor.ReceiveTimeout"/> message right after
            another message was enqueued; hence it is not guaranteed that upon reception of the receive
            timeout there must have been an idle period beforehand as configured via this method.
            </para>
            
            <para>
            Once set, the receive timeout stays in effect (i.e. continues firing repeatedly after inactivity
            periods). Pass in <c>null</c> to switch off this feature.
            </para>
            </summary>
            <param name="timeout">The timeout. Pass in <c>null</c> to switch off this feature.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.AroundPreRestart(System.Exception,System.Object)">
            <summary>
            Can be overridden to intercept calls to `PreRestart`. Calls `PreRestart` by default.
            </summary>
            <param name="cause">The cause.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.AroundPreStart">
            <summary>
            Can be overridden to intercept calls to `PreStart`. Calls `PreStart` by default.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.PreStart">
            <summary>
                User overridable callback.
                <p />
                Is called when an Actor is started.
                Actors are automatically started asynchronously when created.
                Empty default implementation.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.AroundPostRestart(System.Exception,System.Object)">
            <summary>
                Can be overridden to intercept calls to `PostRestart`. Calls `PostRestart` by default.
            </summary>
            <param name="cause">The cause.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)">
            <summary>
                User overridable callback: '''By default it disposes of all children and then calls `postStop()`.'''
                <p />
                Is called on a crashed Actor right BEFORE it is restarted to allow clean
                up of resources before Actor is terminated.
            </summary>
            <param name="reason">the Exception that caused the restart to happen.</param>
            <param name="message">optionally the current message the actor processed when failing, if applicable.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.PostRestart(System.Exception)">
            <summary>
                User overridable callback: By default it calls `PreStart()`.
                <p />
                Is called right AFTER restart on the newly created Actor to allow reinitialization after an Actor crash.
            </summary>
            <param name="reason">the Exception that caused the restart to happen.</param>
        </member>
        <member name="M:Akka.Actor.ActorBase.AroundPostStop">
            <summary>
                Can be overridden to intercept calls to `PostStop`. Calls `PostStop` by default..
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.PostStop">
            <summary>
                User overridable callback.
                <p />
                Is called asynchronously after 'actor.stop()' is invoked.
                Empty default implementation.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorBase.SupervisorStrategyInternal">
            <summary>
            Gets or sets a <see cref="M:Akka.Actor.ActorBase.SupervisorStrategy"/>.
            When getting, if a previously <see cref="M:Akka.Actor.ActorBase.SupervisorStrategy"/> has been set it's returned; otherwise calls
            <see cref="M:Akka.Actor.ActorBase.SupervisorStrategy">SupervisorStrategy()</see>, stores and returns it.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorBase.SupervisorStrategy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.ActorCell">
            <summary>
            TBD
            </summary>
            <summary>
                Class ActorCell.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.ChildrenContainer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.AttachChild(Akka.Actor.Props,System.Boolean,System.String)">
            <summary>
            TBD
            </summary>
            <param name="props">TBD</param>
            <param name="isSystemService">TBD</param>
            <param name="name">TBD</param>
            <exception cref="T:Akka.Actor.InvalidActorNameException">
            This exception is thrown if the given <paramref name="name"/> is an invalid actor name.
            </exception>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if a pre-creation serialization occurred.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            This exception is thrown if the actor tries to create a child while it is terminating or is terminated.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.ActorOf(Akka.Actor.Props,System.String)">
            <summary>
            TBD
            </summary>
            <param name="props">TBD</param>
            <param name="name">TBD</param>
            <exception cref="T:Akka.Actor.InvalidActorNameException">
            This exception is thrown if the given <paramref name="name"/> is an invalid actor name.
            </exception>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if a pre-creation serialization occurred.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            This exception is thrown if the actor tries to create a child while it is terminating or is terminated.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.Stop(Akka.Actor.IActorRef)">
            <summary>
                Stops the specified child.
            </summary>
            <param name="child">The child.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.UpdateChildrenRefs``1(System.Func{Akka.Actor.Internal.IChildrenContainer,System.Tuple{System.Boolean,Akka.Actor.Internal.IChildrenContainer,``0}})">
            <summary>
            Swaps out the children container, by calling <paramref name="updater"/>  to produce the new container.
            If the underlying container has been updated while <paramref name="updater"/> was called,
            <paramref name="updater"/> will be called again with the new container. This will repeat until the 
            container can be swapped out, or until <see cref="P:System.Tuple`3.Item1"/> contains <c>false</c>.
            <para>The returned tuple should contain:</para>
            <para>Item1: <c>true</c> if the container should be updated; <c>false</c> to not update and return Item3</para>
            <para>Item2: The new container (will only be used if Item1=<c>true</c>)</para>
            <para>Item3: The return value</para>
            </summary>
            <param name="updater">A function that returns a new container.</param>
            <returns>The third value of the tuple that <paramref name="updater"/> returned.</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.UpdateChildrenRefs(System.Func{Akka.Actor.Internal.IChildrenContainer,Akka.Actor.Internal.IChildrenContainer})">
            <summary>
            Swaps out the children container, by calling <paramref name="updater" />  to produce the new container.
            If the underlying container has been updated while <paramref name="updater" /> was called,
            <paramref name="updater" /> will be called again with the new container. This will repeat until the
            container can be swapped out.
            </summary>
            <param name="updater">A function that returns a new container.</param>
            <returns>The new updated <see cref="P:Akka.Actor.ActorCell.ChildrenContainer"/></returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.ReserveChild(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.UnreserveChild(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.InitChild(Akka.Actor.IInternalActorRef)">
            <summary>
            This should only be used privately or when creating the root actor. 
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.SetChildrenTerminationReason(Akka.Actor.Internal.SuspendReason)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.SetTerminated">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.IsNormal">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.IsTerminating">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.SuspendChildren(System.Collections.Generic.List{Akka.Actor.IActorRef})">
            <summary>
                Suspends the children.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.ResumeChildren(System.Exception,Akka.Actor.IActorRef)">
            <summary>
                Resumes the children.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.TryGetChildStatsByName(System.String,Akka.Actor.Internal.IChildStats@)">
            <summary>
            Tries to get the stats for the child with the specified name. The stats can be either <see cref="T:Akka.Actor.Internal.ChildNameReserved"/> 
            indicating that only a name has been reserved for the child, or a <see cref="T:Akka.Actor.Internal.ChildRestartStats"/> for a child that 
            has been initialized/created.
            </summary>
            <param name="name">TBD</param>
            <param name="child">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.TryGetChildRestartStatsByName(System.String,Akka.Actor.Internal.ChildRestartStats@)">
            <summary>
            Tries to get the stats for the child with the specified name. This ignores children for whom only names have been reserved.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.TryGetChildStatsByRef(Akka.Actor.IActorRef,Akka.Actor.Internal.ChildRestartStats@)">
            <summary>
            Tries to get the stats for the specified child.
            <remarks>Since the child exists <see cref="T:Akka.Actor.Internal.ChildRestartStats"/> is the only valid <see cref="T:Akka.Actor.Internal.IChildStats"/>.</remarks>
            </summary>
            <param name="actor">TBD</param>
            <param name="child">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.GetSingleChild(System.String)">
            <summary>
            Obsolete. Use <see cref="M:Akka.Actor.ActorCell.TryGetSingleChild(System.String,Akka.Actor.IInternalActorRef@)"/> instead.
            </summary>
            <param name="name">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.TryGetSingleChild(System.String,Akka.Actor.IInternalActorRef@)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="child">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.RemoveChildAndGetStateChange(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="child">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Actor.ActorCell._self">
            <summary>NOTE! Only constructor and ClearActorFields is allowed to update this</summary>
        </member>
        <member name="F:Akka.Actor.ActorCell.UndefinedUid">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Stash(Akka.Dispatch.SysMsg.SystemMessage)">
            <summary>
            TBD
            </summary>
            <param name="msg">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.#ctor(Akka.Actor.Internal.ActorSystemImpl,Akka.Actor.IInternalActorRef,Akka.Actor.Props,Akka.Dispatch.MessageDispatcher,Akka.Actor.IInternalActorRef)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <param name="self">TBD</param>
            <param name="props">TBD</param>
            <param name="dispatcher">TBD</param>
            <param name="parent">TBD</param>
        </member>
        <member name="P:Akka.Actor.ActorCell.CurrentMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.Mailbox">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.Dispatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.IsLocal">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.Actor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.IsTerminated">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.Current">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.System">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.SystemImpl">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.Props">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.Self">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.Parent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.Sender">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.HasMessages">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.NumberOfMessages">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.ActorHasBeenCleared">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.TerminatedProps">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorCell.TaskScheduler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Init(System.Boolean,Akka.Dispatch.MailboxType)">
            <summary>
            Initialize this cell, i.e. set up mailboxes and supervision. The UID must be
            reasonably different from the previous UID of a possible actor with the same path,
            which can be achieved by using <see cref="T:Akka.Util.ThreadLocalRandom"/>
            </summary>
            <param name="sendSupervise">TBD</param>
            <param name="mailboxType">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.GetChildByName(System.String)">
            <summary>
            Obsolete. Use <see cref="M:Akka.Actor.ActorCell.TryGetChildStatsByName(System.String,Akka.Actor.Internal.IChildStats@)"/> instead.
            </summary>
            <param name="name">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.ActorSelection(System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.ActorSelection(Akka.Actor.ActorPath)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.GetChildren">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.Become(Akka.Actor.Receive)">
            <summary>
            TBD
            </summary>
            <param name="receive">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.BecomeStacked(Akka.Actor.Receive)">
            <summary>
            TBD
            </summary>
            <param name="receive">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.UnbecomeStacked">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.CreateNewActorInstance">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.UseThreadContext(System.Action)">
            <summary>
            TBD
            </summary>
            <param name="action">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.SendMessage(Akka.Actor.Envelope)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.SendMessage(Akka.Actor.IActorRef,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="sender">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.ClearActorCell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.ClearActor(Akka.Actor.ActorBase)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.PrepareForNewActor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.SetActorFields(Akka.Actor.ActorBase)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.SplitNameAndUid(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.GetCurrentSelfOrNoSender">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.GetCurrentSenderOrNoSender">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.Watch(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="subject">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.Unwatch(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="subject">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.ReceivedTerminated(Akka.Actor.Terminated)">
            <summary>
            TBD
            </summary>
            <param name="t">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.WatchedActorTerminated(Akka.Actor.IActorRef,System.Boolean,System.Boolean)">
            <summary>
            When this actor is watching the subject of <see cref="T:Akka.Actor.Terminated"/> message
            it will be propagated to user's receive.
            </summary>
            <param name="actor">TBD</param>
            <param name="existenceConfirmed">TBD</param>
            <param name="addressTerminated">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.TerminatedQueuedFor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="subject">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.TellWatchersWeDied">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.UnwatchWatchedActors(Akka.Actor.ActorBase)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.AddWatcher(Akka.Actor.IActorRef,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="watchee">TBD</param>
            <param name="watcher">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.RemWatcher(Akka.Actor.IActorRef,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="watchee">TBD</param>
            <param name="watcher">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.AddressTerminated(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="address">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.MaintainAddressTerminatedSubscription(System.Action,Akka.Actor.IActorRef)">
            <summary>
            Starts subscription to AddressTerminated if not already subscribing and the
            block adds a non-local ref to watching or watchedBy.
            Ends subscription to AddressTerminated if subscribing and the
            block removes the last non-local ref from watching and watchedBy.
            </summary>
            <param name="block">TBD</param>
            <param name="change">TBD</param>
        </member>
        <member name="P:Akka.Actor.ActorCell.ActorType">
            <summary>
                Gets the type of the actor.
            </summary>
            <value>The type of the actor.</value>
        </member>
        <member name="P:Akka.Actor.ActorCell.CurrentEnvelopeId">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Invoke(Akka.Actor.Envelope)">
            <summary>
                Invokes the specified envelope.
            </summary>
            <param name="envelope">The envelope.</param>
            <exception cref="T:Akka.Actor.ActorKilledException">
            This exception is thrown if a <see cref="T:Akka.Actor.Kill"/> message is included in the given <paramref name="envelope"/>.
            </exception>>
        </member>
        <member name="M:Akka.Actor.ActorCell.MatchSender(Akka.Actor.Envelope)">
            <summary>
            If the envelope.Sender property is null, then we'll substitute
            Deadletters as the <see cref="P:Akka.Actor.ActorCell.Sender"/> of this message.
            </summary>
            <param name="envelope">The envelope we received</param>
            <returns>An IActorRef that corresponds to a Sender</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.AutoReceiveMessage(Akka.Actor.Envelope)">
            <summary>
            TBD
            </summary>
            <param name="envelope">TBD</param>
            <exception cref="T:Akka.Actor.ActorKilledException">
            This exception is thrown if a <see cref="T:Akka.Actor.Kill"/> message is included in the given <paramref name="envelope"/>.
            </exception>
        </member>
        <member name="M:Akka.Actor.ActorCell.ReceiveMessageForTest(Akka.Actor.Envelope)">
            <summary>
            This is only intended to be called from TestKit's TestActorRef
            </summary>
            <param name="envelope">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.ReceiveMessage(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.ReceiveSelection(Akka.Actor.ActorSelectionMessage)">
            <summary>   
                Receives the selection.
            </summary>
            <param name="m">The m.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.SystemInvoke(Akka.Dispatch.SysMsg.ISystemMessage)">
            <summary>
              Used to invoke system messages.
            </summary>
            <param name="envelope">The envelope.</param>
            <exception cref="T:Akka.Actor.ActorInitializationException">
            This exception is thrown if a <see cref="T:Akka.Dispatch.SysMsg.Create"/> system message is included in the given <paramref name="envelope"/>.
            </exception>
            <exception cref="T:System.NotSupportedException">
            This exception is thrown if an unknown message type is included in the given <paramref name="envelope"/>.
            </exception>
        </member>
        <member name="M:Akka.Actor.ActorCell.SwapMailbox(Akka.Dispatch.Mailbox)">
            <summary>
            TBD
            </summary>
            <param name="mailbox">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorCell.Publish(Akka.Event.LogEvent)">
            <summary>
                Publishes the specified event.
            </summary>
            <param name="event">The event.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.HandleIdentity(Akka.Actor.Identify)">
            <summary>
                Handles the identity.
            </summary>
            <param name="m">The m.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.HandlePoisonPill">
            <summary>
                Handles the poison pill.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Restart(System.Exception)">
            <summary>
                Restarts the specified cause.
            </summary>
            <remarks> NEVER SEND THE SAME SYSTEM MESSAGE OBJECT TO TWO ACTORS </remarks>
            <param name="cause">The cause.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.Start">
            <summary>
                Starts this instance.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.PreStart">
            <summary>
            Allow extra pre-start initialization in derived classes
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Resume(System.Exception)">
            <summary>
                Resumes the specified caused by failure.
            </summary>
            <remarks> NEVER SEND THE SAME SYSTEM MESSAGE OBJECT TO TWO ACTORS </remarks>
            <param name="causedByFailure">The caused by failure.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.Stop">
            <summary>
                Async stop this actor
            </summary>
            <remarks> NEVER SEND THE SAME SYSTEM MESSAGE OBJECT TO TWO ACTORS </remarks>
        </member>
        <member name="M:Akka.Actor.ActorCell.Suspend">
            <summary>
                Suspends this instance.
            </summary>
            <remarks> NEVER SEND THE SAME SYSTEM MESSAGE OBJECT TO TWO ACTORS </remarks>
        </member>
        <member name="M:Akka.Actor.ActorCell.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage)">
            <summary>
            TBD
            </summary>
            <remarks> NEVER SEND THE SAME SYSTEM MESSAGE OBJECT TO TWO ACTORS </remarks>
            <param name="systemMessage">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.FaultRecreate(System.Exception)">
            <summary>Re-create the actor in response to a failure.</summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.FaultSuspend">
            <summary>
            Suspends the actor in response to a failure of a parent (i.e. the "recursive suspend" feature).
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.FaultResume(System.Exception)">
            <summary>
            Resumes the actor in response to a failure
            </summary>
            <param name="causedByFailure">The exception that caused the failure. signifies if it was our own failure 
            which prompted this action.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.FaultCreate">
            <summary>
            Create the actor in response to a failure
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.Terminate">
            <summary>Terminates this instance.</summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.HandleNonFatalOrInterruptedException(System.Action)">
            <summary>
                Handles the non fatal or interrupted exception.
            </summary>
            <param name="action">The action.</param>
        </member>
        <member name="M:Akka.Actor.ActorCell.SetReceiveTimeout(System.Nullable{System.TimeSpan})">
            <summary>
            TBD
            </summary>
            <param name="timeout">TBD</param>
        </member>
        <member name="P:Akka.Actor.ActorCell.ReceiveTimeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorCell.CheckReceiveTimeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.INotInfluenceReceiveTimeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorPath">
            <summary>
            Actor path is a unique path to an actor that shows the creation path
            up through the actor tree to the root actor.
            ActorPath defines a natural ordering (so that ActorRefs can be put into
            collections with this requirement); this ordering is intended to be as fast
            as possible, which owing to the bottom-up recursive nature of ActorPath
            is sorted by path elements FROM RIGHT TO LEFT, where RootActorPath >
            ChildActorPath in case the number of elements is different.
            Two actor paths are compared equal when they have the same name and parent
            elements, including the root address information. That does not necessarily
            mean that they point to the same incarnation of the actor if the actor is
            re-created with the same path. In other words, in contrast to how actor
            references are compared the unique id of the actor is not taken into account
            when comparing actor paths.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorPath.Surrogate">
            <summary>
            This class represents a surrogate of an <see cref="T:Akka.Actor.ActorPath"/>.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorPath.Surrogate.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorPath.Surrogate"/> class.
            </summary>
            <param name="path">The string representation of the actor path.</param>
        </member>
        <member name="P:Akka.Actor.ActorPath.Surrogate.Path">
            <summary>
            The string representation of the actor path
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorPath.Surrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates an <see cref="T:Akka.Actor.ActorPath"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that contains this actor path.</param>
            <returns>The <see cref="T:Akka.Actor.ActorPath"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.Surrogate.Equals(Akka.Actor.ActorPath.Surrogate)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.ActorPath.Surrogate.Equals(Akka.Actor.ActorPath)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.ActorPath.Surrogate.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.ActorPath.Surrogate.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="F:Akka.Actor.ActorPath.ValidSymbols">
            INTERNAL API 
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorPath.IsValidPathElement(System.String)">
            <summary> 
            Method that checks if actor name conforms to RFC 2396, http://www.ietf.org/rfc/rfc2396.txt
            Note that AKKA JVM does not allow parenthesis ( ) but, according to RFC 2396 those are allowed, and 
            since we use URL Encode to create valid actor names, we must allow them.
            </summary>
            <param name="s">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.#ctor(Akka.Actor.Address,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorPath" /> class.
            </summary>
            <param name="address"> The address. </param>
            <param name="name"> The name. </param>
        </member>
        <member name="M:Akka.Actor.ActorPath.#ctor(Akka.Actor.ActorPath,System.String,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorPath" /> class.
            </summary>
            <param name="parentPath"> The parent path. </param>
            <param name="name"> The name. </param>
            <param name="uid"> The uid. </param>
        </member>
        <member name="P:Akka.Actor.ActorPath.Uid">
            <summary>
            Gets the uid.
            </summary>
            <value> The uid. </value>
        </member>
        <member name="M:Akka.Actor.ActorPath.FillElements(Akka.Actor.ActorPath)">
            <summary>
            This method pursuits optimization goals mostly in terms of allocations.
            We're computing elements chain only once and storing it in <see cref="F:Akka.Actor.ActorPath._elements" />.
            Computed chain meant to be reused not only by calls to <see cref="P:Akka.Actor.ActorPath.Elements" /> 
            but also during chain computation of children actors.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorPath.Elements">
            <summary>
            Gets the elements.
            </summary>
            <value> The elements. </value>
        </member>
        <member name="P:Akka.Actor.ActorPath.ElementsWithUid">
            <summary>
            INTERNAL API.
            
            Used in Akka.Remote - when resolving deserialized local actor references
            we need to be able to include the UID at the tail end of the elements.
            
            It's implemented in this class because we don't have an ActorPathExtractor equivalent.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorPath.Name">
            <summary>
            Gets the name.
            </summary>
            <value> The name. </value>
        </member>
        <member name="P:Akka.Actor.ActorPath.Address">
            <summary>
            The Address under which this path can be reached; walks up the tree to
            the RootActorPath.
            </summary>
            <value> The address. </value>
        </member>
        <member name="P:Akka.Actor.ActorPath.Root">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorPath.Parent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorPath.Equals(Akka.Actor.ActorPath)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.ActorPath.CompareTo(Akka.Actor.ActorPath)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.ActorPath.WithUid(System.Int64)">
            <summary>
            Withes the uid.
            </summary>
            <param name="uid"> The uid. </param>
            <returns> ActorPath. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.op_Division(Akka.Actor.ActorPath,System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.ChildActorPath"/> with the specified parent <paramref name="path"/>
            and the specified <paramref name="name"/>.
            </summary>
            <param name="path">The parent path of the newly created actor path</param>
            <param name="name">The name of child actor path</param>
            <returns>A newly created <see cref="T:Akka.Actor.ChildActorPath"/></returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.op_Division(Akka.Actor.ActorPath,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new <see cref="T:Akka.Actor.ActorPath"/> by appending all the names in <paramref name="name"/>
            to the specified <paramref name="path"/>.
            </summary>
            <param name="path">The base path of the newly created actor path.</param>
            <param name="name">The names being appended to the specified <paramref name="path"/>.</param>
            <returns>A newly created <see cref="T:Akka.Actor.ActorPath"/></returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.Parse(System.String)">
            <summary>
            Creates an <see cref="T:Akka.Actor.ActorPath"/> from the specified <paramref name="path"/>.
            </summary>
            <param name="path">The string representing a possible <see cref="T:Akka.Actor.ActorPath"/></param>
            <exception cref="T:System.UriFormatException">
            This exception is thrown if the given <paramref name="path"/> cannot be parsed into an <see cref="T:Akka.Actor.ActorPath"/>.
            </exception>
            <returns>A newly created <see cref="T:Akka.Actor.ActorPath"/></returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.TryParse(System.String,Akka.Actor.ActorPath@)">
            <summary>
            Tries to parse the uri, which should be a full uri, i.e containing protocol.
            For example "akka://System/user/my-actor"
            </summary>
            <param name="path">TBD</param>
            <param name="actorPath">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.TryParseAddress(System.String,Akka.Actor.Address@)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <param name="address">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.Join">
            <summary>
            Joins this instance.
            </summary>
            <returns> System.String. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToStringWithoutAddress">
            <summary>
            String representation of the path elements, excluding the address
            information. The elements are separated with "/" and starts with "/",
            e.g. "/user/a/b".
            </summary>
            <returns> System.String. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToStringWithUid">
            <summary>
            Returns a string representation of this instance including uid.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.Child(System.String)">
            <summary>
            Creates a child with the specified name
            </summary>
            <param name="childName"> Name of the child. </param>
            <returns> ActorPath. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.ActorPath.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.ActorPath.op_Equality(Akka.Actor.ActorPath,Akka.Actor.ActorPath)">
            <summary>
            Compares two specified actor paths for equality.
            </summary>
            <param name="left">The first actor path used for comparison</param>
            <param name="right">The second actor path used for comparison</param>
            <returns><c>true</c> if both actor paths are equal; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.op_Inequality(Akka.Actor.ActorPath,Akka.Actor.ActorPath)">
            <summary>
            Compares two specified actor paths for inequality.
            </summary>
            <param name="left">The first actor path used for comparison</param>
            <param name="right">The second actor path used for comparison</param>
            <returns><c>true</c> if both actor paths are not equal; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToStringWithAddress">
            <summary>
            Generate String representation, with the address in the RootActorPath.
            </summary>
            <returns> System.String. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToSerializationFormat">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToSerializationFormatWithAddress(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="address">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToStringWithAddress(Akka.Actor.Address)">
            <summary>
            Generate String representation, replacing the Address in the RootActorPath
            with the given one unless this paths address includes host and port
            information.
            </summary>
            <param name="address"> The address. </param>
            <returns> System.String. </returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.FormatPathElements(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            TBD
            </summary>
            <param name="pathElements">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorPath.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Actor.ActorPath"/>.
            </summary>
            <param name="system">The actor system that references this actor path.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Actor.ActorPath"/>.</returns>
        </member>
        <member name="T:Akka.Actor.RootActorPath">
            <summary>
            Class RootActorPath.
            </summary>
        </member>
        <member name="M:Akka.Actor.RootActorPath.#ctor(Akka.Actor.Address,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.RootActorPath" /> class.
            </summary>
            <param name="address"> The address. </param>
            <param name="name"> The name. </param>
        </member>
        <member name="P:Akka.Actor.RootActorPath.Parent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.RootActorPath.Root">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.RootActorPath.WithUid(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="uid">TBD</param>
            <exception cref="T:System.NotSupportedException">This exception is thrown if the given <paramref name="uid"/> is not equal to 0.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.RootActorPath.CompareTo(Akka.Actor.ActorPath)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.ChildActorPath">
            <summary>
            Class ChildActorPath.
            </summary>
        </member>
        <member name="M:Akka.Actor.ChildActorPath.#ctor(Akka.Actor.ActorPath,System.String,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ChildActorPath" /> class.
            </summary>
            <param name="parentPath"> The parent path. </param>
            <param name="name"> The name. </param>
            <param name="uid"> The uid. </param>
        </member>
        <member name="P:Akka.Actor.ChildActorPath.Parent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ChildActorPath.Root">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ChildActorPath.WithUid(System.Int64)">
            <summary>
            Creates a copy of the given ActorPath and applies a new Uid
            </summary>
            <param name="uid"> The uid. </param>
            <returns> ActorPath. </returns>
        </member>
        <member name="M:Akka.Actor.ChildActorPath.CompareTo(Akka.Actor.ActorPath)">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.IActorProducerPlugin">
            <summary>
            Plugin interface used to define
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorProducerPlugin.CanBeAppliedTo(System.Type)">
            <summary>
            Determines if current plugin can be applied to provided actor based on it's type.
            </summary>
            <param name="actorType">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorProducerPlugin.AfterIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to underlying <paramref name="actor"/> instance when the new one is being created.
            </summary>
            <param name="actor">TBD</param>
            <param name="context">TBD</param>
        </member>
        <member name="M:Akka.Actor.IActorProducerPlugin.BeforeIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to underlying <paramref name="actor"/> instance before the actor is being recycled.
            </summary>
            <param name="actor">TBD</param>
            <param name="context">TBD</param>
        </member>
        <member name="T:Akka.Actor.ActorProducerPluginBase">
            <summary>
            Base actor producer pipeline plugin class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase.CanBeAppliedTo(System.Type)">
            <summary>
            By default derivatives of this plugin will be applied to all actors.
            </summary>
            <param name="actorType">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase.AfterIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to <paramref name="actor"/> instance when the new one is being created.
            </summary>
            <param name="actor">TBD</param>
            <param name="context">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase.BeforeIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to <paramref name="actor"/> instance before the actor is being recycled.
            </summary>
            <param name="actor">TBD</param>
            <param name="context">TBD</param>
        </member>
        <member name="T:Akka.Actor.ActorProducerPluginBase`1">
            <summary>
            Base generic actor producer pipeline plugin class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase`1.CanBeAppliedTo(System.Type)">
            <summary>
            By default derivatives of this plugin will be applied to all actors inheriting from <typeparamref name="TActor">actor generic type</typeparamref>.
            </summary>
            <param name="actorType">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase`1.AfterIncarnated(`0,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to <paramref name="actor"/> instance when the new one is being created.
            </summary>
            <param name="actor">TBD</param>
            <param name="context">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorProducerPluginBase`1.BeforeIncarnated(`0,Akka.Actor.IActorContext)">
            <summary>
            Plugin behavior applied to <paramref name="actor"/> instance before the actor is being recycled.
            </summary>
            <param name="actor">TBD</param>
            <param name="context">TBD</param>
        </member>
        <member name="T:Akka.Actor.ActorProducerPipelineResolver">
            <summary>
            Class used to resolving actor producer pipelines depending on actor type.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorProducerPipelineResolver.TotalPluginCount">
            <summary>
            Gets total number of unique plugins registered inside current resolver.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipelineResolver.#ctor(System.Func{Akka.Event.ILoggingAdapter})">
            <summary>
            TBD
            </summary>
            <param name="logBuilder">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipelineResolver.Register(Akka.Actor.IActorProducerPlugin)">
            <summary>
            Register target <paramref name="plugin"/> at the end of producer pipeline.
            </summary>
            <param name="plugin">TBD</param>
            <returns>True if plugin was registered (it has not been found in pipeline already). False otherwise. </returns>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipelineResolver.Insert(System.Int32,Akka.Actor.IActorProducerPlugin)">
            <summary>
            Register target <paramref name="plugin"/> inside producer pipeline at specified <paramref name="index"/>.
            </summary>
            <param name="index">TBD</param>
            <param name="plugin">TBD</param>
            <returns>True if plugin was registered (it has not been found in pipeline already). False otherwise. </returns>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipelineResolver.Unregister(Akka.Actor.IActorProducerPlugin)">
            <summary>
            Unregisters plugin from producer pipeline, returning false if plugin was not found.
            </summary>
            <param name="plugin">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipelineResolver.IsRegistered(Akka.Actor.IActorProducerPlugin)">
            <summary>
            Returns true if current actor producer pipeline already has registered provided plugin type.
            </summary>
            <param name="plugin">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipelineResolver.ResolvePipeline(System.Type)">
            <summary>
            TBD
            </summary>
            <param name="actorType">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.ActorProducerPipeline">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipeline.#ctor(System.Lazy{Akka.Event.ILoggingAdapter},System.Collections.Generic.IEnumerable{Akka.Actor.IActorProducerPlugin})">
            <summary>
            TBD
            </summary>
            <param name="log">TBD</param>
            <param name="plugins">TBD</param>
        </member>
        <member name="P:Akka.Actor.ActorProducerPipeline.Count">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipeline.AfterActorIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Resolves and applies all plugins valid to specified underlying <paramref name="actor"/> 
            registered in current producer pipeline to newly created actor.
            </summary>
            <param name="actor">TBD</param>
            <param name="context">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipeline.BeforeActorIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Resolves and applies all plugins valid to specified underlying <paramref name="actor"/> 
            registered in current producer pipeline before old actor would be recycled.
            </summary>
            <param name="actor">TBD</param>
            <param name="context">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorProducerPipeline.GetEnumerator">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.IActorRefScope">
            <summary>
            INTERNAL API
            
            All ActorRefs have a scope which describes where they live. Since it is often
            necessary to distinguish between local and non-local references, this is the only
            method provided on the scope. 
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorRefScope.IsLocal">
            <summary>
            Returns <c>true</c> if the actor is local to this <see cref="T:Akka.Actor.ActorSystem"/>.
            Returns <c>false</c> if the actor is remote.
            </summary>
        </member>
        <member name="T:Akka.Actor.ILocalRef">
            <summary>
            Marker interface for Actors that are deployed within local scope, 
            i.e. <see cref="P:Akka.Actor.IActorRefScope.IsLocal"/> always returns <c>true</c>.
            </summary>
        </member>
        <member name="T:Akka.Actor.IRepointableRef">
            <summary>
            INTERNAL API
            
            RepointableActorRef (and potentially others) may change their locality at
            runtime, meaning that isLocal might not be stable. RepointableActorRef has
            the feature that it starts out "not fully started" (but you can send to it),
            which is why <see cref="P:Akka.Actor.IRepointableRef.IsStarted"/> features here; it is not improbable that cluster
            actor refs will have the same behavior. 
            </summary>
        </member>
        <member name="P:Akka.Actor.IRepointableRef.IsStarted">
            <summary>
            Retruns <c>true</c> if this actor has started yet. <c>false</c> otherwise.
            </summary>
        </member>
        <member name="T:Akka.Actor.FutureActorRef">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.FutureActorRef.#ctor(System.Threading.Tasks.TaskCompletionSource{System.Object},System.Action,Akka.Actor.ActorPath)">
            <summary>
            TBD
            </summary>
            <param name="result">TBD</param>
            <param name="unregister">TBD</param>
            <param name="path">TBD</param>
        </member>
        <member name="P:Akka.Actor.FutureActorRef.Path">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FutureActorRef.Provider">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.NotImplementedException">TBD</exception>
        </member>
        <member name="M:Akka.Actor.FutureActorRef.TellInternal(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
        </member>
        <member name="M:Akka.Actor.FutureActorRef.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="T:Akka.Actor.ActorRefSender">
            <summary>
            INTERNAL API.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefSender.GetSelfOrNoSender">
            <summary>
            Gets the current actor, if any. Otherwise <see cref="F:Akka.Actor.ActorRefs.NoSender"/>.
            </summary>
            <returns>The current <see cref="T:Akka.Actor.IActorRef"/>, if applicable. If not, <see cref="F:Akka.Actor.ActorRefs.NoSender"/>.</returns>
        </member>
        <member name="T:Akka.Actor.IActorRef">
            <summary>
            An actor reference. Acts as a handle to an actor. Used to send messages to an actor, whether an actor is local or remote.
            If you receive a reference to an actor, that actor is guaranteed to have existed at some point
            in the past. However, an actor can always be terminated in the future.
            
            If you want to be notified about an actor terminating, call <see cref="!:IActorContext.Watch"/>
            on this actor and you'll receive a <see cref="T:Akka.Actor.Terminated"/> message when the actor dies or if it
            is already dead.
            </summary>
            <remarks>Actor references can be serialized and passed over the network.</remarks>
        </member>
        <member name="P:Akka.Actor.IActorRef.Path">
            <summary>
            The path of this actor. Can be used to extract information about whether or not this actor is local or remote.
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorRefImplicitSenderExtensions">
            <summary>
            Extension method class. Used to deliver messages to <see cref="T:Akka.Actor.IActorRef"/> instances
            via <see cref="M:Akka.Actor.ActorRefImplicitSenderExtensions.Tell(Akka.Actor.IActorRef,System.Object)"/> and <see cref="M:Akka.Actor.ActorRefImplicitSenderExtensions.Forward(Akka.Actor.IActorRef,System.Object)"/> and pass along information about the current sender.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefImplicitSenderExtensions.Tell(Akka.Actor.IActorRef,System.Object)">
            <summary>
            Asynchronously tells a message to an <see cref="T:Akka.Actor.IActorRef"/>.
            </summary>
            <param name="receiver">The actor who will receive the message.</param>
            <param name="message">The message.</param>
            <remarks>Will automatically resolve the current sender using the current <see cref="T:Akka.Actor.ActorCell"/>, if any.</remarks>
        </member>
        <member name="M:Akka.Actor.ActorRefImplicitSenderExtensions.Forward(Akka.Actor.IActorRef,System.Object)">
            <summary>
            Forwards the message using the current Sender
            </summary>
            <param name="receiver">The actor that receives the forward</param>
            <param name="message">The message to forward</param>
        </member>
        <member name="T:Akka.Actor.ActorRefs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Actor.ActorRefs.Nobody">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Actor.ActorRefs.NoSender">
            <summary>
            Use this value as an argument to <see cref="M:Akka.Actor.ICanTell.Tell(System.Object,Akka.Actor.IActorRef)"/> if there is not actor to
            reply to (e.g. when sending from non-actor code).
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorRefBase">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorRefBase.Surrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Actor.ActorRefBase"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefBase.Surrogate.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
        </member>
        <member name="P:Akka.Actor.ActorRefBase.Surrogate.Path">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefBase.Surrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates an <see cref="T:Akka.Actor.ActorRefBase"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that contains this <see cref="T:Akka.Actor.ActorRefBase"/>.</param>
            <returns>The <see cref="T:Akka.Actor.ActorRefBase"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Actor.ActorRefBase.Path">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefBase.Tell(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorRefBase.TellInternal(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorRefBase.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.ActorRefBase.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.ActorRefBase.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.ActorRefBase.CompareTo(System.Object)">
            <inheritdoc/>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the given <paramref name="obj"/> isn't an <see cref="T:Akka.Actor.IActorRef"/>.
            </exception>
        </member>
        <member name="M:Akka.Actor.ActorRefBase.Equals(Akka.Actor.IActorRef)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.ActorRefBase.CompareTo(Akka.Actor.IActorRef)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.ActorRefBase.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Actor.ActorRefBase"/>.
            </summary>
            <param name="system">The actor system that references this <see cref="T:Akka.Actor.ActorRefBase"/>.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Actor.ActorRefBase"/>.</returns>
        </member>
        <member name="T:Akka.Actor.IInternalActorRef">
            <summary>
            INTERNAL API.
            
            Used by built-in <see cref="T:Akka.Actor.IActorRef"/> implementations for handling
            internal operations that are not exposed directly to end-users.
            </summary>
        </member>
        <member name="P:Akka.Actor.IInternalActorRef.Parent">
            <summary>
            The parent of this actor.
            </summary>
        </member>
        <member name="P:Akka.Actor.IInternalActorRef.Provider">
            <summary>
            The <see cref="T:Akka.Actor.IActorRefProvider"/> used by the <see cref="T:Akka.Actor.ActorSystem"/>
            to which this actor belongs.
            </summary>
        </member>
        <member name="P:Akka.Actor.IInternalActorRef.IsTerminated">
            <summary>
            Obsolete. Use <see cref="!:Akka.Actor.UntypedActor.Context.Watch(IActorRef)"/> or <see cref="M:Akka.Actor.ReceiveActor.Receive``1(System.Action{``0},System.Predicate{``0})">Receive&lt;<see cref="T:Akka.Actor.Terminated"/>&gt;</see>
            </summary>
        </member>
        <member name="M:Akka.Actor.IInternalActorRef.GetChild(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Obtain a child given the paths element to that actor, by possibly traversing the actor tree or 
            looking it up at some provider-specific location. 
            A path element of ".." signifies the parent, a trailing "" element must be disregarded. 
            If the requested path does not exist, returns <see cref="T:Akka.Actor.Nobody"/>.
            </summary>
            <param name="name">The path elements.</param>
            <returns>The <see cref="T:Akka.Actor.IActorRef"/>, or if the requested path does not exist, returns <see cref="T:Akka.Actor.Nobody"/>.</returns>
        </member>
        <member name="M:Akka.Actor.IInternalActorRef.Resume(System.Exception)">
            <summary>
            Resumes an actor if it has been suspended.
            </summary>
            <param name="causedByFailure">Optional. Passed in if the actor is resuming as a result of recovering from failure.</param>
        </member>
        <member name="M:Akka.Actor.IInternalActorRef.Start">
            <summary>
            Start a newly created actor.
            </summary>
        </member>
        <member name="M:Akka.Actor.IInternalActorRef.Stop">
            <summary>
            Stop the actor. Terminates it permanently.
            </summary>
        </member>
        <member name="M:Akka.Actor.IInternalActorRef.Restart(System.Exception)">
            <summary>
            Restart the actor.
            </summary>
            <param name="cause">The exception that caused the actor to fail in the first place.</param>
        </member>
        <member name="M:Akka.Actor.IInternalActorRef.Suspend">
            <summary>
            Suspend the actor. Actor will not process any more messages until <see cref="M:Akka.Actor.IInternalActorRef.Resume(System.Exception)"/> is called.
            </summary>
        </member>
        <member name="M:Akka.Actor.IInternalActorRef.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage,Akka.Actor.IActorRef)">
            <summary>
            Obsolete. Use <see cref="M:Akka.Actor.IInternalActorRef.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage)"/> instead.
            </summary>
            <param name="message">N/A</param>
            <param name="sender">N/A</param>
        </member>
        <member name="M:Akka.Actor.IInternalActorRef.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage)">
            <summary>
            Sends an <see cref="T:Akka.Dispatch.SysMsg.ISystemMessage"/> to the underlying actor.
            </summary>
            <param name="message">The system message we're sending.</param>
        </member>
        <member name="T:Akka.Actor.InternalActorRefBase">
            <summary>
            INTERNAL API.
            
            Abstract implementation of <see cref="T:Akka.Actor.IInternalActorRef"/>.
            </summary>
        </member>
        <member name="P:Akka.Actor.InternalActorRefBase.Parent">
            <inheritdoc cref="T:Akka.Actor.IInternalActorRef"/>
        </member>
        <member name="P:Akka.Actor.InternalActorRefBase.Provider">
            <inheritdoc cref="T:Akka.Actor.IInternalActorRef"/>
        </member>
        <member name="M:Akka.Actor.InternalActorRefBase.GetChild(System.Collections.Generic.IEnumerable{System.String})">
            <inheritdoc cref="T:Akka.Actor.IInternalActorRef"/>
        </member>
        <member name="M:Akka.Actor.InternalActorRefBase.Resume(System.Exception)">
            <inheritdoc cref="T:Akka.Actor.IInternalActorRef"/>
        </member>
        <member name="M:Akka.Actor.InternalActorRefBase.Start">
            <inheritdoc cref="T:Akka.Actor.IInternalActorRef"/>
        </member>
        <member name="M:Akka.Actor.InternalActorRefBase.Stop">
            <inheritdoc cref="T:Akka.Actor.IInternalActorRef"/>
        </member>
        <member name="M:Akka.Actor.InternalActorRefBase.Restart(System.Exception)">
            <inheritdoc cref="T:Akka.Actor.IInternalActorRef"/>
        </member>
        <member name="M:Akka.Actor.InternalActorRefBase.Suspend">
            <inheritdoc cref="T:Akka.Actor.IInternalActorRef"/>
        </member>
        <member name="P:Akka.Actor.InternalActorRefBase.IsTerminated">
            <inheritdoc cref="T:Akka.Actor.IInternalActorRef"/>
        </member>
        <member name="P:Akka.Actor.InternalActorRefBase.IsLocal">
            <inheritdoc cref="T:Akka.Actor.IInternalActorRef"/>
        </member>
        <member name="M:Akka.Actor.InternalActorRefBase.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage,Akka.Actor.IActorRef)">
            <inheritdoc cref="T:Akka.Actor.IInternalActorRef"/>
        </member>
        <member name="M:Akka.Actor.InternalActorRefBase.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage)">
            <inheritdoc cref="T:Akka.Actor.IInternalActorRef"/>
        </member>
        <member name="T:Akka.Actor.MinimalActorRef">
            <summary>
            INTERNAL API.
            
            Barebones <see cref="T:Akka.Actor.IActorRef"/> with no backing actor or <see cref="T:Akka.Actor.ActorCell"/>.
            </summary>
        </member>
        <member name="P:Akka.Actor.MinimalActorRef.Parent">
            <inheritdoc cref="T:Akka.Actor.InternalActorRefBase"/>
        </member>
        <member name="M:Akka.Actor.MinimalActorRef.GetChild(System.Collections.Generic.IEnumerable{System.String})">
            <inheritdoc cref="T:Akka.Actor.InternalActorRefBase"/>
        </member>
        <member name="M:Akka.Actor.MinimalActorRef.Resume(System.Exception)">
            <inheritdoc cref="T:Akka.Actor.InternalActorRefBase"/>
        </member>
        <member name="M:Akka.Actor.MinimalActorRef.Start">
            <inheritdoc cref="T:Akka.Actor.InternalActorRefBase"/>
        </member>
        <member name="M:Akka.Actor.MinimalActorRef.Stop">
            <inheritdoc cref="T:Akka.Actor.InternalActorRefBase"/>
        </member>
        <member name="M:Akka.Actor.MinimalActorRef.Restart(System.Exception)">
            <inheritdoc cref="T:Akka.Actor.InternalActorRefBase"/>
        </member>
        <member name="M:Akka.Actor.MinimalActorRef.Suspend">
            <inheritdoc cref="T:Akka.Actor.InternalActorRefBase"/>
        </member>
        <member name="M:Akka.Actor.MinimalActorRef.TellInternal(System.Object,Akka.Actor.IActorRef)">
            <inheritdoc cref="T:Akka.Actor.InternalActorRefBase"/>
        </member>
        <member name="M:Akka.Actor.MinimalActorRef.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage)">
            <inheritdoc cref="T:Akka.Actor.InternalActorRefBase"/>
        </member>
        <member name="P:Akka.Actor.MinimalActorRef.IsLocal">
            <inheritdoc cref="T:Akka.Actor.InternalActorRefBase"/>
        </member>
        <member name="P:Akka.Actor.MinimalActorRef.IsTerminated">
            <inheritdoc cref="T:Akka.Actor.InternalActorRefBase"/>
        </member>
        <member name="T:Akka.Actor.Nobody">
            <summary> This is an internal look-up failure token, not useful for anything else.</summary>
        </member>
        <member name="T:Akka.Actor.Nobody.NobodySurrogate">
            <summary>
            A surrogate for serializing <see cref="T:Akka.Actor.Nobody"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.Nobody.NobodySurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Converts the <see cref="T:Akka.Util.ISurrogate"/> into a <see cref="T:Akka.Actor.IActorRef"/>.
            </summary>
            <param name="system">The actor system.</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Actor.Nobody.Instance">
            <summary>
            Singleton instance of <see cref="T:Akka.Actor.Nobody"/>.
            </summary>
        </member>
        <member name="P:Akka.Actor.Nobody.Path">
            <inheritdoc cref="T:Akka.Actor.InternalActorRefBase"/>
        </member>
        <member name="P:Akka.Actor.Nobody.Provider">
            <summary>N/A</summary>
            <exception cref="T:System.NotSupportedException">
            This exception is automatically thrown since this actor doesn't have a provider.
            </exception>
        </member>
        <member name="M:Akka.Actor.Nobody.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.ActorRefWithCell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorRefWithCell.Underlying">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorRefWithCell.Children">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefWithCell.GetSingleChild(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.VirtualPathContainer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.VirtualPathContainer.#ctor(Akka.Actor.IActorRefProvider,Akka.Actor.ActorPath,Akka.Actor.IInternalActorRef,Akka.Event.ILoggingAdapter)">
            <summary>
            TBD
            </summary>
            <param name="provider">TBD</param>
            <param name="path">TBD</param>
            <param name="parent">TBD</param>
            <param name="log">TBD</param>
        </member>
        <member name="P:Akka.Actor.VirtualPathContainer.Provider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.VirtualPathContainer.Parent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.VirtualPathContainer.Path">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.VirtualPathContainer.Log">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.VirtualPathContainer.TryGetChild(System.String,Akka.Actor.IInternalActorRef@)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="child">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.VirtualPathContainer.AddChild(System.String,Akka.Actor.IInternalActorRef)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="actor">TBD</param>
        </member>
        <member name="M:Akka.Actor.VirtualPathContainer.RemoveChild(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="M:Akka.Actor.VirtualPathContainer.RemoveChild(System.String,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="child">TBD</param>
        </member>
        <member name="M:Akka.Actor.VirtualPathContainer.GetChild(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.VirtualPathContainer.HasChildren">
            <summary>
            Returns <c>true</c> if the <see cref="T:Akka.Actor.VirtualPathContainer"/> contains any children, 
            <c>false</c> otherwise.
            </summary>
        </member>
        <member name="M:Akka.Actor.VirtualPathContainer.ForEachChild(System.Action{Akka.Actor.IInternalActorRef})">
            <summary>
            Executes an action for each child in the current collection.
            </summary>
            <param name="action">A lambda which takes a reference to the internal child actor as an argument.</param>
        </member>
        <member name="T:Akka.Actor.VirtualPathContainer.Enumerable`1">
            <summary>
            An enumerable that continues where the supplied enumerator is positioned
            </summary>
        </member>
        <member name="M:Akka.Actor.VirtualPathContainer.Enumerable`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.ActorRefExtensions">
            <summary>
                An extension method class for working with ActorRefs
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefExtensions.IsNobody(Akka.Actor.IActorRef)">
            <summary>
                If we call a method such as <code>Context.Child(name)</code>
                and don't receive a valid result in return, this method will indicate
                whether or not the actor we received is valid.
            </summary>
            <param name="actorRef">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.ActorRefFactoryExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefFactoryExtensions.ActorOf``1(Akka.Actor.IActorRefFactory,System.String)">
            <summary>
            TBD
            </summary>
            <typeparam name="TActor">TBD</typeparam>
            <param name="factory">TBD</param>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorRefFactoryExtensions.ActorSelection(Akka.Actor.IActorRefFactory,Akka.Actor.IActorRef,System.String)">
            <summary>
                Construct an <see cref="T:Akka.Actor.ActorSelection"/> from the given string representing a path
                relative to the given target. This operation has to create all the
                matching magic, so it is preferable to cache its result if the
                intention is to send messages frequently.
            </summary>
            <param name="factory">TBD</param>
            <param name="anchorRef">TBD</param>
            <param name="actorPath">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.ActorRefFactoryShared">
            <summary>
            This class contains implementations originally found in Akkas trait ActorRefFactory in ActorRefProvider.scala
            https://github.com/akka/akka/blob/master/akka-actor/src/main/scala/akka/actor/ActorRefProvider.scala#L180
            <see cref="T:Akka.Actor.IActorRefFactory"/> corresponds to that trait, but since it is an interface it
            cannot contain any code, hence this class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorRefFactoryShared.ActorSelection(Akka.Actor.ActorPath,Akka.Actor.ActorSystem)">
            <summary>
                Construct an <see cref="T:Akka.Actor.ActorSelection"/> from the given path, which is
                parsed for wildcards (these are replaced by regular expressions
                internally). No attempt is made to verify the existence of any part of
                the supplied path, it is recommended to send a message and gather the
                replies in order to resolve the matching set of actors.
            </summary>
            <param name="actorPath">TBD</param>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorRefFactoryShared.ActorSelection(System.String,Akka.Actor.ActorSystem,Akka.Actor.IActorRef)">
            <summary>
                Construct an <see cref="T:Akka.Actor.ActorSelection"/> from the given path, which is
                parsed for wildcards (these are replaced by regular expressions
                internally). No attempt is made to verify the existence of any part of
                the supplied path, it is recommended to send a message and gather the
                replies in order to resolve the matching set of actors.
            </summary>
            <param name="path">TBD</param>
            <param name="system">TBD</param>
            <param name="lookupRoot">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorRefFactoryShared.ActorSelection(Akka.Actor.IActorRef,System.String)">
            <summary>
                Construct an <see cref="T:Akka.Actor.ActorSelection"/> from the given string representing a path
                relative to the given target. This operation has to create all the
                matching magic, so it is preferable to cache its result if the
                intention is to send messages frequently.
            </summary>
            <param name="anchorActorRef">TBD</param>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.IActorRefProvider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.RootGuardian">
            <summary>
            Reference to the supervisor of guardian and systemGuardian; this is
            exposed so that the ActorSystemImpl can use it as lookupRoot, i.e.
            for anchoring absolute actor look-ups.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.RootGuardianAt(Akka.Actor.Address)">
            <summary>Reference to the supervisor of guardian and systemGuardian at the specified address;
            this is exposed so that the ActorRefFactory can use it as lookupRoot, i.e.
            for anchoring absolute actor selections.
            </summary>
            <param name="address">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.Guardian">
            <summary> Gets the supervisor used for all top-level user actors.</summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.SystemGuardian">
            <summary>Gets the supervisor used for all top-level system actors.</summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.DeadLetters">
            <summary>Gets the dead letters.</summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.RootPath">
            <summary>
            Gets the root path for all actors within this actor system, not including any remote address information.
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.Settings">
            <summary>Gets the settings.</summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.Init(Akka.Actor.Internal.ActorSystemImpl)">
            <summary>
            Initialization of an ActorRefProvider happens in two steps: first
            construction of the object with settings, eventStream, etc.
            and thenwhen the ActorSystem is constructedthe second phase during
            which actors may be created (e.g. the guardians).
            </summary>
            <param name="system">TBD</param>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.Deployer">
            <summary>Gets the deployer.</summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.TempPath">
            <summary>Generates and returns a unique actor path below "/temp".</summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.TempContainer">
            <summary>Returns the actor reference representing the "/temp" path.</summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.RegisterTempActor(Akka.Actor.IInternalActorRef,Akka.Actor.ActorPath)">
            <summary>Registers an actorRef at a path returned by <see cref="M:Akka.Actor.IActorRefProvider.TempPath"/>; do NOT pass in any other path.</summary>
            <param name="actorRef">The actor reference.</param>
            <param name="path">A path returned by <see cref="M:Akka.Actor.IActorRefProvider.TempPath"/>. Do NOT pass in any other path!</param>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.UnregisterTempActor(Akka.Actor.ActorPath)">
            <summary>Unregister a temporary actor (i.e. obtained from <see cref="M:Akka.Actor.IActorRefProvider.TempPath"/>); do NOT pass in any other path.</summary>
            <param name="path">A path returned by <see cref="M:Akka.Actor.IActorRefProvider.TempPath"/>. Do NOT pass in any other path!</param>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.ActorOf(Akka.Actor.Internal.ActorSystemImpl,Akka.Actor.Props,Akka.Actor.IInternalActorRef,Akka.Actor.ActorPath,System.Boolean,Akka.Actor.Deploy,System.Boolean,System.Boolean)">
            <summary>
            Actor factory with create-only semantics: will create an actor as
            described by <paramref name="props"/> with the given <paramref name="supervisor"/> and <paramref name="path"/> (may be different
            in case of remote supervision). If <paramref name="systemService"/> is true, deployment is
            bypassed (local-only). If a value for<paramref name="deploy"/> is passed in, it should be
            regarded as taking precedence over the nominally applicable settings,
            but it should be overridable from external configuration; the lookup of
            the latter can be suppressed by setting "lookupDeploy" to "false".
            </summary>
            <param name="system">TBD</param>
            <param name="props">TBD</param>
            <param name="supervisor">TBD</param>
            <param name="path">TBD</param>
            <param name="systemService">TBD</param>
            <param name="deploy">TBD</param>
            <param name="lookupDeploy">TBD</param>
            <param name="async">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.ResolveActorRef(System.String)">
            <summary>Get the actor reference for a specified path. If no such actor exists, it will be (equivalent to) a dead letter reference.</summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.ResolveActorRef(Akka.Actor.ActorPath)">
            <summary>Get the actor reference for a specified path. If no such actor exists, it will be (equivalent to) a dead letter reference.</summary>
            <param name="actorPath">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.TerminationTask">
            <summary>
            This Future is completed upon termination of this <see cref="T:Akka.Actor.IActorRefProvider"/>, which
            is usually initiated by stopping the guardian via <see cref="M:Akka.Actor.ActorSystem.Stop(Akka.Actor.IActorRef)"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorRefProvider.GetExternalAddressFor(Akka.Actor.Address)">
            <summary>
            Obtain the address which is to be used within sender references when
            sending to the given other address or none if the other address cannot be
            reached from this system (i.e. no means of communication known; no
            attempt is made to verify actual reachability).
            </summary>
            <param name="address">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.IActorRefProvider.DefaultAddress">
            <summary>Gets the external address of the default transport. </summary>
        </member>
        <member name="T:Akka.Actor.LocalActorRefProvider">
            <summary>
                Class LocalActorRefProvider. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.#ctor(System.String,Akka.Actor.Settings,Akka.Event.EventStream)">
            <summary>
            TBD
            </summary>
            <param name="systemName">TBD</param>
            <param name="settings">TBD</param>
            <param name="eventStream">TBD</param>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.#ctor(System.String,Akka.Actor.Settings,Akka.Event.EventStream,Akka.Actor.Deployer,System.Func{Akka.Actor.ActorPath,Akka.Actor.IInternalActorRef})">
            <summary>
            TBD
            </summary>
            <param name="systemName">TBD</param>
            <param name="settings">TBD</param>
            <param name="eventStream">TBD</param>
            <param name="deployer">TBD</param>
            <param name="deadLettersFactory">TBD</param>
        </member>
        <member name="P:Akka.Actor.LocalActorRefProvider.DeadLetters">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRefProvider.Deployer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRefProvider.RootGuardian">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRefProvider.RootPath">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRefProvider.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRefProvider.SystemGuardian">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRefProvider.TempContainer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRefProvider.TerminationTask">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRefProvider.Guardian">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRefProvider.EventStream">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.TempPath">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.RegisterExtraName(System.String,Akka.Actor.IInternalActorRef)">
            <summary>
            Higher-level providers (or extensions) might want to register new synthetic
            top-level paths for doing special stuff. This is the way to do just that.
            Just be careful to complete all this before <see cref="M:Akka.Actor.Internal.ActorSystemImpl.Start"/> finishes,
            or before you start your own auto-spawned actors.
            </summary>
            <param name="name">TBD</param>
            <param name="actor">TBD</param>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.RootGuardianAt(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="address">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.RegisterTempActor(Akka.Actor.IInternalActorRef,Akka.Actor.ActorPath)">
            <summary>
            Registers an actorRef at a path returned by <see cref="M:Akka.Actor.LocalActorRefProvider.TempPath" />; do NOT pass in any other path.
            </summary>
            <param name="actorRef">The actor reference.</param>
            <param name="path">A path returned by <see cref="M:Akka.Actor.LocalActorRefProvider.TempPath" />. Do NOT pass in any other path!</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the given <paramref name="path"/> is not on the temp path.</exception>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.UnregisterTempActor(Akka.Actor.ActorPath)">
            <summary>
            Unregister a temporary actor (i.e. obtained from <see cref="M:Akka.Actor.LocalActorRefProvider.TempPath" />); do NOT pass in any other path.
            </summary>
            <param name="path">A path returned by <see cref="M:Akka.Actor.LocalActorRefProvider.TempPath" />. Do NOT pass in any other path!</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the given <paramref name="path"/> is not on the temp path.</exception>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.Init(Akka.Actor.Internal.ActorSystemImpl)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.ResolveActorRef(System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.ResolveActorRef(Akka.Actor.ActorPath)">
            <summary>
                Resolves the actor reference.
            </summary>
            <param name="path">The actor path.</param>
            <returns>ActorRef.</returns>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.ResolveActorRef(Akka.Actor.IInternalActorRef,System.Collections.Generic.IReadOnlyCollection{System.String})">
            <summary>
            TBD
            </summary>
            <param name="actorRef">TBD</param>
            <param name="pathElements">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.ActorOf(Akka.Actor.Internal.ActorSystemImpl,Akka.Actor.Props,Akka.Actor.IInternalActorRef,Akka.Actor.ActorPath,System.Boolean,Akka.Actor.Deploy,System.Boolean,System.Boolean)">
            <summary>
            Actor factory with create-only semantics: will create an actor as
            described by <paramref name="props" /> with the given <paramref name="supervisor" /> and <paramref name="path" /> (may be different
            in case of remote supervision). If <paramref name="systemService" /> is true, deployment is
            bypassed (local-only). If a value for<paramref name="deploy" /> is passed in, it should be
            regarded as taking precedence over the nominally applicable settings,
            but it should be overridable from external configuration; the lookup of
            the latter can be suppressed by setting "lookupDeploy" to "false".
            </summary>
            <param name="system">TBD</param>
            <param name="props">TBD</param>
            <param name="supervisor">TBD</param>
            <param name="path">TBD</param>
            <param name="systemService">TBD</param>
            <param name="deploy">TBD</param>
            <param name="lookupDeploy">TBD</param>
            <param name="async">TBD</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception can be thrown for a number of reasons. The following are some examples:
            <dl>
            <dt><b>non-routers</b></dt>
            <dd>The dispatcher in the given <paramref name="props"/> is not configured for the given <paramref name="path"/>.</dd>
            <dd>or</dd>
            <dd>There was a configuration problem while creating the given <paramref name="path"/> with the dispatcher and mailbox from the given <paramref name="props"/></dd>
            <dt><b>routers</b></dt>
            <dd>The dispatcher in the given <paramref name="props"/> is not configured for routees of the given <paramref name="path"/></dd>
            <dd>or</dd>
            <dd>The dispatcher in the given <paramref name="props"/> is not configured for router of the given <paramref name="path"/></dd>
            <dd>or</dd>
            <dd>$There was a configuration problem while creating the given <paramref name="path"/> with router dispatcher and mailbox and routee dispatcher and mailbox.</dd>
            </dl>
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.LocalActorRefProvider.GetExternalAddressFor(Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="address">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.LocalActorRefProvider.DefaultAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRefProvider.Log">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.ActorSelection">
            <summary>
            This class represents a logical view of a section of an <see cref="T:Akka.Actor.ActorSystem">ActorSystem's</see>
            tree of actors that allows for broadcasting of messages to that section.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorSelection.Anchor">
            <summary>
            Gets the anchor.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorSelection.Path">
            <summary>
            Gets the elements.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorSelection.PathString">
            <summary>
            A string representation of all of the elements in the <see cref="T:Akka.Actor.ActorSelection"/> path,
            starting with "/" and separated with "/".
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSelection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelection" /> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSelection.#ctor(Akka.Actor.IActorRef,Akka.Actor.SelectionPathElement[])">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelection" /> class.
            </summary>
            <param name="anchor">The anchor.</param>
            <param name="path">The path.</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.#ctor(Akka.Actor.IActorRef,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelection" /> class.
            </summary>
            <param name="anchor">The anchor.</param>
            <param name="path">The path.</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.#ctor(Akka.Actor.IActorRef,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelection" /> class.
            </summary>
            <param name="anchor">The anchor.</param>
            <param name="elements">The elements.</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.Tell(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Sends a message to this ActorSelection.
            </summary>
            <param name="message">The message to send</param>
            <param name="sender">The actor that sent the message</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.ResolveOne(System.TimeSpan)">
            <summary>
            Resolves the <see cref="T:Akka.Actor.IActorRef"/> matching this selection.
            The result is returned as a Task that is completed with the <see cref="T:Akka.Actor.IActorRef"/>
            if such an actor exists. It is completed with failure <see cref="T:Akka.Actor.ActorNotFoundException"/> if
            no such actor exists or the identification didn't complete within the supplied <paramref name="timeout"/>.
            
            Under the hood it talks to the actor to verify its existence and acquire its <see cref="T:Akka.Actor.IActorRef"/>
            </summary>
            <param name="timeout">
            The amount of time to wait while resolving the selection before terminating the operation and generating an error.
            </param>
            <exception cref="T:Akka.Actor.ActorNotFoundException">
            This exception is thrown if no such actor exists or the identification didn't complete within the supplied <paramref name="timeout"/>.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorSelection.DeliverSelection(Akka.Actor.IInternalActorRef,Akka.Actor.IActorRef,Akka.Actor.ActorSelectionMessage)">
            <summary>
            INTERNAL API
            Convenience method used by remoting when receiving <see cref="T:Akka.Actor.ActorSelectionMessage" /> from a remote
            actor.
            </summary>
            <param name="anchor">TBD</param>
            <param name="sender">TBD</param>
            <param name="sel">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorSelection.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Actor.ActorSelection.Equals(Akka.Actor.ActorSelection)">
            <summary>
            Determines whether the specified actor selection, is equal to this instance.
            </summary>
            <param name="other">The actor selection to compare.</param>
            <returns><c>true</c> if the specified router is equal to this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSelection.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Akka.Actor.ActorSelection.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Actor.ActorSelectionMessage">
            <summary>
            Class ActorSelectionMessage.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSelectionMessage.#ctor(System.Object,Akka.Actor.SelectionPathElement[],System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorSelectionMessage" /> class.
            </summary>
            <param name="message">The message.</param>
            <param name="elements">The elements.</param>
            <param name="wildCardFanOut">TBD</param>
        </member>
        <member name="P:Akka.Actor.ActorSelectionMessage.Message">
            <summary>
            The message that should be delivered to this ActorSelection.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorSelectionMessage.Elements">
            <summary>
            The elements, e.g. "foo/bar/baz".
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorSelectionMessage.WildCardFanOut">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSelectionMessage.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Actor.SelectionPathElement">
            <summary>
            Class SelectionPathElement.
            </summary>
        </member>
        <member name="T:Akka.Actor.SelectChildName">
            <summary>
            Class SelectChildName.
            </summary>
        </member>
        <member name="M:Akka.Actor.SelectChildName.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.SelectChildName" /> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="P:Akka.Actor.SelectChildName.Name">
            <summary>
            Gets the actor name.
            </summary>
        </member>
        <member name="M:Akka.Actor.SelectChildName.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Actor.SelectChildPattern">
            <summary>
            Class SelectChildPattern.
            </summary>
        </member>
        <member name="M:Akka.Actor.SelectChildPattern.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.SelectChildPattern" /> class.
            </summary>
            <param name="patternStr">The pattern string.</param>
        </member>
        <member name="P:Akka.Actor.SelectChildPattern.PatternStr">
            <summary>
            Gets the pattern string.
            </summary>
        </member>
        <member name="M:Akka.Actor.SelectChildPattern.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Actor.SelectParent">
            <summary>
            Class SelectParent.
            </summary>
        </member>
        <member name="M:Akka.Actor.SelectParent.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Actor.ActorSystem">
            <summary>
                An actor system is a hierarchical group of actors which share common
                configuration, e.g. dispatchers, deployments, remote capabilities and
                addresses. It is also the entry point for creating or looking up actors.
                There are several possibilities for creating actors (see <see cref="T:Akka.Actor.Props"/>
                for details on `props`):
                <code>
            system.ActorOf(props, "name");
            system.ActorOf(props);
            system.ActorOf(Props.Create(typeof(MyActor)), "name");
            system.ActorOf(Props.Create(() =&gt; new MyActor(arg1, arg2), "name");
            </code>
                Where no name is given explicitly, one will be automatically generated.
                <b>
                    <i>Important Notice:</i>
                </b>
                This class is not meant to be extended by user code.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Settings">
            <summary>Gets the settings.</summary>
            <value>The settings.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Name">
            <summary>Gets the name of this system.</summary>
            <value>The name.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Serialization">
            <summary>Gets the serialization.</summary>
            <value>The serialization.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.EventStream">
            <summary>Gets the event stream.</summary>
            <value>The event stream.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.DeadLetters">
            <summary>
                Gets the dead letters.
            </summary>
            <value>The dead letters.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Dispatchers">
            <summary>Gets the dispatchers.</summary>
            <value>The dispatchers.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Mailboxes">
            <summary>Gets the mailboxes.</summary>
            <value>The mailboxes.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Scheduler">
            <summary>Gets the scheduler.</summary>
            <value>The scheduler.</value>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Log">
            <summary>Gets the log</summary>
        </member>
        <member name="P:Akka.Actor.ActorSystem.StartTime">
            <summary>
            Start-up time since the epoch.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorSystem.Uptime">
            <summary>
            Up-time of this actor system.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Create(System.String,Akka.Configuration.Config)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.ActorSystem"/> with the specified name and configuration.
            </summary>
            <param name="name">The name of the actor system to create. The name must be uri friendly.
            <remarks>Must contain only word characters (i.e. [a-zA-Z0-9] plus non-leading '-'</remarks>
            </param>
            <param name="config">The configuration used to create the actor system</param>
            <returns>A newly created actor system with the given name and configuration.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Create(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.ActorSystem"/> with the specified name.
            </summary>
            <param name="name">The name of the actor system to create. The name must be uri friendly.
            <remarks>Must contain only word characters (i.e. [a-zA-Z0-9] plus non-leading '-'</remarks>
            </param>
            <returns>A newly created actor system with the given name.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.GetExtension(Akka.Actor.IExtensionId)">
            <summary>
            Retrieves the specified extension that is registered to this actor system.
            </summary>
            <param name="extensionId">The extension to retrieve</param>
            <returns>The specified extension registered to this actor system</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.GetExtension``1">
            <summary>
            Retrieves an extension with the specified type that is registered to this actor system.
            </summary>
            <typeparam name="T">The type of extension to retrieve</typeparam>
            <returns>The specified extension registered to this actor system</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.HasExtension(System.Type)">
            <summary>
            Determines whether this actor system has an extension with the specified type.
            </summary>
            <param name="type">The type of the extension being queried</param>
            <returns><c>true</c> if this actor system has the extension; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.HasExtension``1">
            <summary>
            Determines whether this actor system has the specified extension.
            </summary>
            <typeparam name="T">The type of the extension being queried</typeparam>
            <returns><c>true</c> if this actor system has the extension; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.TryGetExtension(System.Type,System.Object@)">
            <summary>
            Tries to retrieve an extension with the specified type.
            </summary>
            <param name="extensionType">The type of extension to retrieve</param>
            <param name="extension">The extension that is retrieved if successful</param>
            <returns><c>true</c> if the retrieval was successful; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.TryGetExtension``1(``0@)">
            <summary>
            Tries to retrieve an extension with the specified type
            </summary>
            <typeparam name="T">The type of extension to retrieve</typeparam>
            <param name="extension">The extension that is retrieved if successful</param>
            <returns><c>true</c> if the retrieval was successful; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.RegisterOnTermination(System.Action)">
            <summary>
            <para>
            Registers a block of code (callback) to run after ActorSystem.shutdown has been issued and all actors
            in this actor system have been stopped. Multiple code blocks may be registered by calling this method
            multiple times.
            </para>
            <para>
            The callbacks will be run sequentially in reverse order of registration, i.e. last registration is run first.
            </para>
            </summary>
            <param name="code">The code to run</param>
            <exception cref="T:System.Exception">
            This exception is thrown if the system has already shut down or if shutdown has been initiated.
            </exception>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Terminate">
            <summary>
            <para>
            Terminates this actor system. This will stop the guardian actor, which in turn will recursively stop
            all its child actors, then the system guardian (below which the logging actors reside) and the execute
            all registered termination handlers (<see cref="M:Akka.Actor.ActorSystem.RegisterOnTermination(System.Action)" />).
            </para>
            <para>
            Be careful to not schedule any operations on completion of the returned task using the `dispatcher`
            of this actor system as it will have been shut down before the task completes.
            </para>
            </summary>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> that will complete once the actor system has finished terminating and all actors are stopped.
            </returns>
        </member>
        <member name="P:Akka.Actor.ActorSystem.WhenTerminated">
            <summary>
            Returns a task which will be completed after the <see cref="T:Akka.Actor.ActorSystem"/> has been
            terminated and termination hooks have been executed. Be careful to not schedule any
            operations on the `dispatcher` of this actor system as it will have been shut down
            before this task completes.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Stop(Akka.Actor.IActorRef)">
            <summary>
            Stops the specified actor permanently.
            </summary>
            <param name="actor">The actor to stop</param>
            <remarks>
            This method has no effect if the actor is already stopped.
            </remarks>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="M:Akka.Actor.ActorSystem.Dispose(System.Boolean)">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
            <param name="disposing">if set to <c>true</c> the method has been called directly or indirectly by a 
            user's code. Managed and unmanaged resources will be disposed.<br />
            if set to <c>false</c> the method has been called by the runtime from inside the finalizer and only 
            unmanaged resources can be disposed.</param>
        </member>
        <member name="M:Akka.Actor.ActorSystem.RegisterExtension(Akka.Actor.IExtensionId)">
            <summary>
            Registers the specified extension with this actor system.
            </summary>
            <param name="extension">The extension to register with this actor system</param>
            <returns>The extension registered with this actor system</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystem.ActorOf(Akka.Actor.Props,System.String)">
            <inheritdoc cref="T:Akka.Actor.IActorRefFactory"/>
        </member>
        <member name="M:Akka.Actor.ActorSystem.ActorSelection(Akka.Actor.ActorPath)">
            <inheritdoc cref="T:Akka.Actor.IActorRefFactory"/>
        </member>
        <member name="M:Akka.Actor.ActorSystem.ActorSelection(System.String)">
            <inheritdoc cref="T:Akka.Actor.IActorRefFactory"/>
        </member>
        <member name="T:Akka.Actor.Address">
            <summary>
             The address specifies the physical location under which an Actor can be
             reached. Examples are local addresses, identified by the <see cref="T:Akka.Actor.ActorSystem"/>'s
            name, and remote addresses, identified by protocol, host and port.
             
            This class is sealed to allow use as a case class (copy method etc.); if
            for example a remote transport would want to associate additional
            information with an address, then this must be done externally.
            </summary>
        </member>
        <member name="F:Akka.Actor.Address.AllSystems">
            <summary>
            Pseudo address for all systems
            </summary>
        </member>
        <member name="M:Akka.Actor.Address.#ctor(System.String,System.String,System.String,System.Nullable{System.Int32})">
            <summary>
            TBD
            </summary>
            <param name="protocol">TBD</param>
            <param name="system">TBD</param>
            <param name="host">TBD</param>
            <param name="port">TBD</param>
        </member>
        <member name="P:Akka.Actor.Address.Host">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Address.Port">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Address.System">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Address.Protocol">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Address.HasLocalScope">
            <summary>
            Returns true if this Address is only defined locally. It is not safe to send locally scoped addresses to remote
             hosts. See also <see cref="P:Akka.Actor.Address.HasGlobalScope"/>
            </summary>
        </member>
        <member name="P:Akka.Actor.Address.HasGlobalScope">
            <summary>
            Returns true if this Address is usable globally. Unlike locally defined addresses <see cref="P:Akka.Actor.Address.HasLocalScope"/>
            addresses of global scope are safe to sent to other hosts, as they globally and uniquely identify an addressable
            entity.
            </summary>
        </member>
        <member name="M:Akka.Actor.Address.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Akka.Actor.Address.Equals(Akka.Actor.Address)">
            <summary>
            Determines whether the specified <see cref="T:Akka.Actor.Address" />, is equal to this instance.
            </summary>
            <param name="other">The <see cref="T:Akka.Actor.Address" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:Akka.Actor.Address" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Actor.Address.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Actor.Address.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Akka.Actor.Address.Clone">
            <summary>
            Creates a new copy with the same properties as the current address.
            </summary>
            <returns>A new copy of the current address</returns>
        </member>
        <member name="M:Akka.Actor.Address.WithProtocol(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Address"/> with a given <paramref name="protocol"/>.
            </summary>
            <note>
            This method is immutable and returns a new instance of the address.
            </note>
            <param name="protocol">The protocol used to configure the new address.</param>
            <returns>A new address with the provided <paramref name="protocol" />.</returns>
        </member>
        <member name="M:Akka.Actor.Address.WithSystem(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Address"/> with a given <paramref name="system"/>.
            </summary>
            <note>
            This method is immutable and returns a new instance of the address.
            </note>
            <param name="system">The system used to configure the new address.</param>
            <returns>A new address with the provided <paramref name="system" />.</returns>
        </member>
        <member name="M:Akka.Actor.Address.WithHost(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Address"/> with a given <paramref name="host"/>.
            </summary>
            <note>
            This method is immutable and returns a new instance of the address.
            </note>
            <param name="host">The host used to configure the new address.</param>
            <returns>A new address with the provided <paramref name="host" />.</returns>
        </member>
        <member name="M:Akka.Actor.Address.WithPort(System.Nullable{System.Int32})">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Address"/> with a given <paramref name="port"/>.
            </summary>
            <note>
            This method is immutable and returns a new instance of the address.
            </note>
            <param name="port">The port used to configure the new address.</param>
            <returns>A new address with the provided <paramref name="port" />.</returns>
        </member>
        <member name="M:Akka.Actor.Address.op_Equality(Akka.Actor.Address,Akka.Actor.Address)">
            <summary>
            Compares two specified addresses for equality.
            </summary>
            <param name="left">The first address used for comparison</param>
            <param name="right">The second address used for comparison</param>
            <returns><c>true</c> if both addresses are equal; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Actor.Address.op_Inequality(Akka.Actor.Address,Akka.Actor.Address)">
            <summary>
            Compares two specified addresses for inequality.
            </summary>
            <param name="left">The first address used for comparison</param>
            <param name="right">The second address used for comparison</param>
            <returns><c>true</c> if both addresses are not equal; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Actor.Address.HostPort">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Address.Parse(System.String)">
            <summary>
            Parses a new <see cref="T:Akka.Actor.Address"/> from a given string
            </summary>
            <param name="address">The address to parse</param>
            <returns>A populated <see cref="T:Akka.Actor.Address"/> object with host and port included, if available</returns>
            <exception cref="T:System.UriFormatException">Thrown if the address is not able to be parsed</exception>
        </member>
        <member name="T:Akka.Actor.Address.AddressSurrogate">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Address.AddressSurrogate.Protocol">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Address.AddressSurrogate.System">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Address.AddressSurrogate.Host">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Address.AddressSurrogate.Port">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Address.AddressSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Address.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.RelativeActorPath">
            <summary>
            Extractor class for so-called "relative actor paths" - as in "relative URI", not
            "relative to some other actors."
            
            Examples:
            
             * "grand/child"
             * "/user/hello/world"
            </summary>
        </member>
        <member name="M:Akka.Actor.RelativeActorPath.Unapply(System.String)">
            <summary>
            TBD
            </summary>
            <param name="addr">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.EventStreamActor">
            <summary>
                Class EventStreamActor.
            </summary>
        </member>
        <member name="M:Akka.Actor.EventStreamActor.Receive(System.Object)">
            <summary>
                Processor for user defined messages.
            </summary>
            <param name="message">The message.</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.GuardianActor">
            <summary>
                Class GuardianActor.
            </summary>
        </member>
        <member name="M:Akka.Actor.GuardianActor.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.GuardianActor.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.SystemGuardianActor">
            <summary>
            System guardian. 
            
            Root actor for all actors under the /system path.
            </summary>
        </member>
        <member name="M:Akka.Actor.SystemGuardianActor.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="userGuardian">TBD</param>
        </member>
        <member name="M:Akka.Actor.SystemGuardianActor.Receive(System.Object)">
            <summary>
            Processor for messages that are sent to the root system guardian
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.SystemGuardianActor.PreRestart(System.Exception,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="T:Akka.Actor.DeadLetterActorRef">
            <summary>
                Class DeadLetterActorRef.
            </summary>
        </member>
        <member name="M:Akka.Actor.DeadLetterActorRef.#ctor(Akka.Actor.IActorRefProvider,Akka.Actor.ActorPath,Akka.Event.EventStream)">
            <summary>
            TBD
            </summary>
            <param name="provider">TBD</param>
            <param name="path">TBD</param>
            <param name="eventStream">TBD</param>
        </member>
        <member name="M:Akka.Actor.DeadLetterActorRef.TellInternal(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
            <exception cref="T:Akka.Actor.InvalidMessageException">This exception is thrown if the given <paramref name="message"/> is undefined.</exception>
        </member>
        <member name="M:Akka.Actor.DeadLetterActorRef.SpecialHandle(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.AlreadyCanceledCancelable">
            <summary>
            A <see cref="T:Akka.Actor.ICancelable"/> that is already canceled.
            </summary>
        </member>
        <member name="M:Akka.Actor.AlreadyCanceledCancelable.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.AlreadyCanceledCancelable.IsCancellationRequested">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.AlreadyCanceledCancelable.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.AlreadyCanceledCancelable.Token">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.AlreadyCanceledCancelable.Cancel(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="throwOnFirstException">TBD</param>
        </member>
        <member name="T:Akka.Actor.Cancelable">
            <summary>
            A <see cref="T:Akka.Actor.ICancelable"/> that wraps a <see cref="T:System.Threading.CancellationTokenSource"/>. 
            When canceling this instance the underlying <see cref="T:System.Threading.CancellationTokenSource"/> is canceled as well.
            </summary>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IActionScheduler,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class that will be cancelled after the specified amount of time.
            </summary>
            <param name="scheduler">The scheduler.</param>
            <param name="delay">The delay before the cancelable is canceled.</param>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IScheduler,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class that will be cancelled after the specified amount of time.
            </summary>
            <param name="scheduler">The scheduler.</param>
            <param name="delay">The delay before the cancelable is canceled.</param>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IScheduler,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class that will be cancelled after the specified amount of milliseconds.
            </summary>
            <param name="scheduler">The scheduler.</param>
            <param name="millisecondsDelay">The delay in milliseconds.</param>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class.
            </summary>
            <param name="scheduler">TBD</param>
        </member>
        <member name="M:Akka.Actor.Cancelable.#ctor(Akka.Actor.IActionScheduler)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Cancelable"/> class.
            </summary>
            <param name="scheduler">TBD</param>
        </member>
        <member name="P:Akka.Actor.Cancelable.IsCancellationRequested">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Cancelable.Token">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Cancelable.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Cancelable.Cancel(System.Boolean)">
            <summary>
            Communicates a request for cancellation, and specifies whether remaining callbacks and cancelable operations should be processed.
            </summary>
            <param name="throwOnFirstException"><c>true</c> if exceptions should immediately propagate; otherwise, <c>false</c>.</param>
            <remarks>
            The associated cancelable will be notified of the cancellation and will transition to a state where
            <see cref="P:Akka.Actor.Cancelable.IsCancellationRequested" /> returns <c>true</c>.
            Any callbacks or cancelable operations registered with the cancelable will be executed.
            Cancelable operations and callbacks registered with the token should not throw exceptions.
            If <paramref name="throwOnFirstException" /> is <c>true</c>, an exception will immediately propagate out of
            the call to Cancel, preventing the remaining callbacks and cancelable operations from being processed.
            If <paramref name="throwOnFirstException" /> is <c>false</c>, this overload will aggregate any exceptions
            thrown into an <see cref="T:System.AggregateException" />, such that one callback throwing an exception will not
            prevent other registered callbacks from being executed.
            The <see cref="T:System.Threading.ExecutionContext" /> that was captured when each callback was registered will be reestablished when the callback is invoked.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">
            This exception is thrown if this cancelable has already been disposed.
            </exception>
        </member>
        <member name="M:Akka.Actor.Cancelable.CancelAfter(System.TimeSpan)">
            <summary>
            Schedules a cancel operation on this cancelable after the specified delay.
            </summary>
            <param name="delay">The delay before this instance is canceled.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if the given <paramref name="delay"/> is less than or equal to 0.</exception>
            <exception cref="T:System.ObjectDisposedException">This exception is thrown if this cancelable has already been disposed.</exception>
        </member>
        <member name="M:Akka.Actor.Cancelable.CancelAfter(System.Int32)">
            <summary>
            Schedules a cancel operation on this cancelable after the specified number of milliseconds.
            </summary>
            <param name="millisecondsDelay">The delay in milliseconds before this instance is canceled.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if the given <paramref name="millisecondsDelay"/> is less than or equal to 0.</exception>
            <exception cref="T:System.ObjectDisposedException">This exception is thrown if this cancelable has already been disposed.</exception>
        </member>
        <member name="M:Akka.Actor.Cancelable.CreateCanceled">
            <summary>
            Returns a <see cref="T:Akka.Actor.ICancelable"/> that has already been canceled.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Cancelable.CreateLinkedCancelable(Akka.Actor.IScheduler,Akka.Actor.ICancelable[])">
            <summary>
            Creates a <see cref="T:Akka.Actor.ICancelable"/> that will be in the canceled state
            when any of the source cancelables are in the canceled state. 
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="cancelables">The cancelables instances to observe.</param>
            <returns>A new <see cref="T:Akka.Actor.ICancelable"/> that is linked to the source .</returns>
        </member>
        <member name="M:Akka.Actor.Cancelable.CreateLinkedCancelable(Akka.Actor.IActionScheduler,Akka.Actor.ICancelable[])">
            <summary>
            Creates a <see cref="T:Akka.Actor.ICancelable"/> that will be in the canceled state
            when any of the source cancelables are in the canceled state. 
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="cancelables">The cancelables instances to observe.</param>
            <returns>A new <see cref="T:Akka.Actor.ICancelable"/> that is linked to the source .</returns>
        </member>
        <member name="M:Akka.Actor.Cancelable.Dispose">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        </member>
        <member name="M:Akka.Actor.Cancelable.Dispose(System.Boolean)">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
            <param name="disposing">if set to <c>true</c> the method has been called directly or indirectly by a 
            user's code. Managed and unmanaged resources will be disposed.<br />
            if set to <c>false</c> the method has been called by the runtime from inside the finalizer and only 
            unmanaged resources can be disposed.</param>
        </member>
        <member name="T:Akka.Actor.CancelableExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.CancelableExtensions.CancelIfNotNull(Akka.Actor.ICancelable)">
            <summary>
            If <paramref name="cancelable"/> is not <c>null</c> it's canceled.
            </summary>
            <param name="cancelable">The cancelable. Will be canceled if it's not <c>null</c></param>
        </member>
        <member name="T:Akka.Actor.ICancelable">
            <summary>
            Signifies something that can be canceled
            </summary>
        </member>
        <member name="M:Akka.Actor.ICancelable.Cancel">
            <summary>
            Communicates a request for cancellation.
            </summary>
            <remarks>The associated cancelable will be notified of the cancellation and will transition to a state where 
            <see cref="P:Akka.Actor.ICancelable.IsCancellationRequested"/> returns <c>true</c>.
            Any callbacks or cancelable operations registered with the cancelable will be executed.
            Cancelable operations and callbacks registered with the token should not throw exceptions.
            However, this overload of Cancel will aggregate any exceptions thrown into an 
            <see cref="T:System.AggregateException"/>, such that one callback throwing an exception will not 
            prevent other registered callbacks from being executed.
            The <see cref="T:System.Threading.ExecutionContext"/> that was captured when each callback was registered will 
            be reestablished when the callback is invoked.</remarks>
        </member>
        <member name="P:Akka.Actor.ICancelable.IsCancellationRequested">
            <summary>
            Gets a value indicating whether cancellation has been requested
            </summary>
        </member>
        <member name="P:Akka.Actor.ICancelable.Token">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ICancelable.CancelAfter(System.TimeSpan)">
            <summary>
            Schedules a cancel operation on this cancelable after the specified delay.
            </summary>
            <param name="delay">The delay before this instance is canceled.</param>
        </member>
        <member name="M:Akka.Actor.ICancelable.CancelAfter(System.Int32)">
            <summary>
            Schedules a cancel operation on this cancelable after the specified number of milliseconds.
            </summary>
            <param name="millisecondsDelay">The delay in milliseconds before this instance is canceled.</param>
        </member>
        <member name="M:Akka.Actor.ICancelable.Cancel(System.Boolean)">
            <summary>
            Communicates a request for cancellation, and specifies whether remaining callbacks and cancelable operations should be processed.
            </summary>
            <param name="throwOnFirstException"><c>true</c> if exceptions should immediately propagate; otherwise, <c>false</c>.</param>
            <remarks>The associated cancelable will be notified of the cancellation and will transition to a state where 
            <see cref="P:Akka.Actor.ICancelable.IsCancellationRequested"/> returns <c>true</c>.
            Any callbacks or cancelable operations registered with the cancelable will be executed.
            Cancelable operations and callbacks registered with the token should not throw exceptions.
            If <paramref name="throwOnFirstException"/> is <c>true</c>, an exception will immediately propagate out of 
            the call to Cancel, preventing the remaining callbacks and cancelable operations from being processed.
            If <paramref name="throwOnFirstException"/> is <c>false</c>, this overload will aggregate any exceptions 
            thrown into an <see cref="T:System.AggregateException"/>, such that one callback throwing an exception will not 
            prevent other registered callbacks from being executed.
            The <see cref="T:System.Threading.ExecutionContext"/> that was captured when each callback was registered will be reestablished when the callback is invoked.</remarks>
        </member>
        <member name="T:Akka.Actor.ICell">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.ICell.Self">
            <summary>Gets the "self" reference which this Cell is attached to.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.System">
            <summary>The system within which this Cell lives.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.SystemImpl">
            <summary>The system internals within which this Cell lives.</summary>
        </member>
        <member name="M:Akka.Actor.ICell.Start">
            <summary>
            Start the cell: enqueued message must not be processed before this has
            been called. The usual action is to attach the mailbox to a dispatcher.
            </summary>
        </member>
        <member name="M:Akka.Actor.ICell.Suspend">
            <summary>Recursively suspend this actor and all its children. Is only allowed to throw fatal exceptions.</summary>
        </member>
        <member name="M:Akka.Actor.ICell.Resume(System.Exception)">
            <summary>Recursively resume this actor and all its children. Is only allowed to throw fatal exceptions.</summary>
            <param name="causedByFailure">TBD</param>
        </member>
        <member name="M:Akka.Actor.ICell.Restart(System.Exception)">
            <summary>Restart this actor (will recursively restart or stop all children). Is only allowed to throw Fatal Throwables.</summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Actor.ICell.Stop">
            <summary>Recursively terminate this actor and all its children. Is only allowed to throw Fatal Throwables.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.Parent">
            <summary>The supervisor of this actor.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.IsLocal">
            <summary>Returns true if the actor is local.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.Props">
            <summary>The props for this actor cell.</summary>
        </member>
        <member name="P:Akka.Actor.ICell.HasMessages">
            <summary>
            If the actor isLocal, returns whether "user messages" are currently queued,
            <c>false</c>otherwise.
            </summary>
        </member>
        <member name="P:Akka.Actor.ICell.NumberOfMessages">
            <summary>
            If the actor isLocal, returns the number of "user messages" currently queued,
            which may be a costly operation, 0 otherwise.
            </summary>
        </member>
        <member name="P:Akka.Actor.ICell.IsTerminated">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ICell.SendMessage(Akka.Actor.IActorRef,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="sender">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Actor.ICell.GetChildren">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.ICell.ChildrenContainer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ICell.GetSingleChild(System.String)">
            <summary>
            Method for looking up a single child beneath this actor.
            It is racy if called from the outside.
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ICell.GetChildByName(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ICell.TryGetChildStatsByName(System.String,Akka.Actor.Internal.IChildStats@)">
            <summary>
            Tries to get the stats for the child with the specified name. The stats can be either <see cref="T:Akka.Actor.Internal.ChildNameReserved"/> 
            indicating that only a name has been reserved for the child, or a <see cref="T:Akka.Actor.Internal.ChildRestartStats"/> for a child that 
            has been initialized/created.
            </summary>
            <param name="name">TBD</param>
            <param name="child">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ICell.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage)">
            <summary>
            Enqueue a message to be sent to the actor; may or may not actually
            schedule the actor to run, depending on which type of cell it is.
            </summary>
            <param name="message">The system message we're passing along</param>
        </member>
        <member name="T:Akka.Actor.Internal.IChildrenContainer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.IChildrenContainer.Add(System.String,Akka.Actor.Internal.ChildRestartStats)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="stats">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.IChildrenContainer.Remove(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="child">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.IChildrenContainer.TryGetByName(System.String,Akka.Actor.Internal.IChildStats@)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="stats">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.IChildrenContainer.TryGetByRef(Akka.Actor.IActorRef,Akka.Actor.Internal.ChildRestartStats@)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <param name="stats">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.Internal.IChildrenContainer.Children">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.IChildrenContainer.Stats">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.IChildrenContainer.ShallDie(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.IChildrenContainer.Reserve(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.IChildrenContainer.Unreserve(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.Internal.IChildrenContainer.IsTerminating">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.IChildrenContainer.IsNormal">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.IChildrenContainer.Contains(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.Internal.ChildrenContainerBase">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ChildrenContainerBase.#ctor(System.Collections.Immutable.IImmutableDictionary{System.String,Akka.Actor.Internal.IChildStats})">
            <summary>
            TBD
            </summary>
            <param name="children">TBD</param>
        </member>
        <member name="P:Akka.Actor.Internal.ChildrenContainerBase.IsTerminating">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.ChildrenContainerBase.IsNormal">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ChildrenContainerBase.Add(System.String,Akka.Actor.Internal.ChildRestartStats)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="stats">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ChildrenContainerBase.Remove(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="child">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ChildrenContainerBase.Reserve(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ChildrenContainerBase.ShallDie(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ChildrenContainerBase.Unreserve(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.Internal.ChildrenContainerBase.Children">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.ChildrenContainerBase.Stats">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.ChildrenContainerBase.InternalChildren">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ChildrenContainerBase.TryGetByName(System.String,Akka.Actor.Internal.IChildStats@)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="stats">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ChildrenContainerBase.TryGetByRef(Akka.Actor.IActorRef,Akka.Actor.Internal.ChildRestartStats@)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <param name="childRestartStats">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ChildrenContainerBase.Contains(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ChildrenContainerBase.ChildStatsAppender(System.Text.StringBuilder,System.Collections.Generic.KeyValuePair{System.String,Akka.Actor.Internal.IChildStats},System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="sb">TBD</param>
            <param name="kvp">TBD</param>
            <param name="index">TBD</param>
        </member>
        <member name="T:Akka.Actor.Internal.IChildStats">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.ChildNameReserved">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.ChildNameReserved.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ChildNameReserved.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.Internal.ChildRestartStats">
            <summary>
            ChildRestartStats is the statistics kept by every parent Actor for every child Actor
            and is used for SupervisorStrategies to know how to deal with problems that occur for the children.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ChildRestartStats.#ctor(Akka.Actor.IInternalActorRef,System.UInt32,System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="child">TBD</param>
            <param name="maxNrOfRetriesCount">TBD</param>
            <param name="restartTimeWindowStartTicks">TBD</param>
        </member>
        <member name="P:Akka.Actor.Internal.ChildRestartStats.Uid">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.ChildRestartStats.Child">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.ChildRestartStats.MaxNrOfRetriesCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.ChildRestartStats.RestartTimeWindowStartTicks">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ChildRestartStats.RequestRestartPermission(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="maxNrOfRetries">TBD</param>
            <param name="withinTimeMilliseconds">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.Internal.EmptyChildrenContainer">
            <summary>
            This is the empty container, shared among all leaf actors.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.EmptyChildrenContainer.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.EmptyChildrenContainer.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.EmptyChildrenContainer.Add(System.String,Akka.Actor.Internal.ChildRestartStats)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="stats">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.EmptyChildrenContainer.Remove(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="child">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.EmptyChildrenContainer.TryGetByName(System.String,Akka.Actor.Internal.IChildStats@)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="stats">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.EmptyChildrenContainer.TryGetByRef(Akka.Actor.IActorRef,Akka.Actor.Internal.ChildRestartStats@)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <param name="childRestartStats">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.EmptyChildrenContainer.Contains(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.Internal.EmptyChildrenContainer.Children">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.EmptyChildrenContainer.Stats">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.EmptyChildrenContainer.ShallDie(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.EmptyChildrenContainer.Reserve(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.EmptyChildrenContainer.Unreserve(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.EmptyChildrenContainer.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.Internal.EmptyChildrenContainer.IsTerminating">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.EmptyChildrenContainer.IsNormal">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.NormalChildrenContainer">
            <summary>
            Normal children container: we do have at least one child, but none of our
            children are currently terminating (which is the time period between calling
            context.stop(child) and processing the ChildTerminated() system message).
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.NormalChildrenContainer.Create(System.Collections.Immutable.IImmutableDictionary{System.String,Akka.Actor.Internal.IChildStats})">
            <summary>
            TBD
            </summary>
            <param name="children">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.NormalChildrenContainer.Add(System.String,Akka.Actor.Internal.ChildRestartStats)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="stats">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.NormalChildrenContainer.Remove(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="child">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.NormalChildrenContainer.ShallDie(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.NormalChildrenContainer.Reserve(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
             <exception cref="T:Akka.Actor.InvalidActorNameException">This exception is thrown if the given <paramref name="name"/> is not unique in the container.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.NormalChildrenContainer.Unreserve(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.NormalChildrenContainer.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason">
            <summary>
            TBD
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.IWaitingForChildren">
            <summary>
            TBD
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.Creation">
            <summary>
            TBD
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.Recreation">
            <summary>
            TBD
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.SuspendReason.Recreation.#ctor(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="P:Akka.Actor.Internal.SuspendReason.Recreation.Cause">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.Termination">
            <summary>
            TBD
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.SuspendReason.Termination.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.SuspendReason.UserRequest">
            <summary>
            TBD
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.SuspendReason.UserRequest.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.TerminatedChildrenContainer">
            <summary>
            This is the empty container which is installed after the last child has
            terminated while stopping; it is necessary to distinguish from the normal
            empty state while calling handleChildTerminated() for the last time.
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.TerminatedChildrenContainer.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.TerminatedChildrenContainer.Add(System.String,Akka.Actor.Internal.ChildRestartStats)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="stats">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.TerminatedChildrenContainer.Reserve(System.String)">
            <summary>
            N/A
            </summary>
            <param name="name">N/A</param>
            <returns>N/A</returns>
            <exception cref="T:System.InvalidOperationException">This exception is automatically thrown since the name belongs to an actor that is already terminated.</exception>
        </member>
        <member name="P:Akka.Actor.Internal.TerminatedChildrenContainer.IsTerminating">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.TerminatedChildrenContainer.IsNormal">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.TerminatedChildrenContainer.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.Internal.TerminatingChildrenContainer">
            <summary>
            Waiting state: there are outstanding termination requests (i.e. context.stop(child)
            was called but the corresponding ChildTerminated() system message has not yet been
            processed). There could be no specific reason (UserRequested), we could be Restarting
            or Terminating.
            Removing the last child which was supposed to be terminating will return a different
            type of container, depending on whether or not children are left and whether or not
            the reason was "Terminating".
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.TerminatingChildrenContainer.#ctor(System.Collections.Immutable.IImmutableDictionary{System.String,Akka.Actor.Internal.IChildStats},Akka.Actor.IActorRef,Akka.Actor.Internal.SuspendReason)">
            <summary>
            TBD
            </summary>
            <param name="children">TBD</param>
            <param name="toDie">TBD</param>
            <param name="reason">TBD</param>
        </member>
        <member name="M:Akka.Actor.Internal.TerminatingChildrenContainer.#ctor(System.Collections.Immutable.IImmutableDictionary{System.String,Akka.Actor.Internal.IChildStats},System.Collections.Immutable.ImmutableHashSet{Akka.Actor.IActorRef},Akka.Actor.Internal.SuspendReason)">
            <summary>
            TBD
            </summary>
            <param name="children">TBD</param>
            <param name="toDie">TBD</param>
            <param name="reason">TBD</param>
        </member>
        <member name="P:Akka.Actor.Internal.TerminatingChildrenContainer.Reason">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.TerminatingChildrenContainer.Add(System.String,Akka.Actor.Internal.ChildRestartStats)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="stats">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.TerminatingChildrenContainer.Remove(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="child">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.TerminatingChildrenContainer.ShallDie(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.TerminatingChildrenContainer.Reserve(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the given <paramref name="name"/> belongs to an actor that is terminating.</exception>
            <exception cref="T:Akka.Actor.InvalidActorNameException">This exception is thrown if the given <paramref name="name"/> is not unique in the container.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.TerminatingChildrenContainer.Unreserve(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.Internal.TerminatingChildrenContainer.IsTerminating">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.TerminatingChildrenContainer.IsNormal">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.TerminatingChildrenContainer.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.TerminatingChildrenContainer.CreateCopyWithReason(Akka.Actor.Internal.SuspendReason)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.Internal.ActorSystemImpl">
            <summary>
            TBD
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Internal.ActorSystemImpl"/> class.
            </summary>
            <param name="name">The name given to the actor system.</param>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.#ctor(System.String,Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Internal.ActorSystemImpl"/> class.
            </summary>
            <param name="name">The name given to the actor system.</param>
            <param name="config">The configuration used to configure the actor system.</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the given <paramref name="name"/> is an invalid name for an actor system.
             Note that the name must contain only word characters (i.e. [a-zA-Z0-9] plus non-leading '-').
            </exception>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the given <paramref name="config"/> is undefined.</exception>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.Provider">
            <inheritdoc cref="T:Akka.Actor.ActorSystem"/>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.Settings">
            <inheritdoc cref="T:Akka.Actor.ActorSystem"/>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.Name">
            <inheritdoc cref="T:Akka.Actor.ActorSystem"/>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.Serialization">
            <inheritdoc cref="T:Akka.Actor.ActorSystem"/>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.EventStream">
            <inheritdoc cref="T:Akka.Actor.ActorSystem"/>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.DeadLetters">
            <inheritdoc cref="T:Akka.Actor.ActorSystem"/>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.Dispatchers">
            <inheritdoc cref="T:Akka.Actor.ActorSystem"/>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.Mailboxes">
            <inheritdoc cref="T:Akka.Actor.ActorSystem"/>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.Scheduler">
            <inheritdoc cref="T:Akka.Actor.ActorSystem"/>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.Log">
            <inheritdoc cref="T:Akka.Actor.ActorSystem"/>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.ActorPipelineResolver">
            <inheritdoc cref="T:Akka.Actor.ActorSystem"/>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.Guardian">
            <inheritdoc cref="T:Akka.Actor.ActorSystem"/>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.LookupRoot">
            <inheritdoc cref="T:Akka.Actor.ActorSystem"/>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.SystemGuardian">
            <inheritdoc cref="T:Akka.Actor.ActorSystem"/>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.SystemActorOf(Akka.Actor.Props,System.String)">
            <summary>
            Creates a new system actor that lives under the "/system" guardian.
            </summary>
            <param name="props">The <see cref="T:Akka.Actor.Props"/> used to create the actor.</param>
            <param name="name">The name of the actor to create. The default value is <see langword="null"/>.</param>
            <exception cref="T:Akka.Actor.InvalidActorNameException">
            This exception is thrown when the given name is invalid or already in use.
            </exception>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown when deployment, dispatcher or mailbox configuration is incorrect.
            </exception>
            <returns>A reference to the underlying actor.</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.SystemActorOf``1(System.String)">
            <summary>
            Creates a new system actor that lives under the "/system" guardian.
            </summary>
            <typeparam name="TActor">
            The type of the actor to create. Must have a default constructor declared.
            </typeparam>
            <param name="name">The name of the actor to create. The default value is <see langword="null"/>.</param>
            <exception cref="T:Akka.Actor.InvalidActorNameException">
            This exception is thrown when the given name is invalid or already in use.
            </exception>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown when deployment, dispatcher or mailbox configuration is incorrect.
            </exception>
            <returns>A reference to the underlying actor.</returns>
        </member>
        <member name="F:Akka.Actor.Internal.ActorSystemImpl.Aborting">
            <summary>
            If <c>true</c>, then the <see cref="T:Akka.Actor.ActorSystem"/> is attempting to abort.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.Abort">
            <summary>
            Shuts down the <see cref="T:Akka.Actor.ActorSystem"/> without all of the usual guarantees,
            i.e. we may not guarantee that remotely deployed actors are properly shut down 
            when we abort.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.Start">
            <summary>Starts this system</summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.ActorOf(Akka.Actor.Props,System.String)">
            <summary>
            TBD
            </summary>
            <param name="props">TBD</param>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.ActorSelection(Akka.Actor.ActorPath)">
            <summary>
            TBD
            </summary>
            <param name="actorPath">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.ActorSelection(System.String)">
            <summary>
            TBD
            </summary>
            <param name="actorPath">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.RegisterExtension(Akka.Actor.IExtensionId)">
            <summary>
            Registers the specified extension with this actor system.
            </summary>
            <param name="extension">The extension to register with this actor system</param>
            <returns>The extension registered with this actor system</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.GetExtension(Akka.Actor.IExtensionId)">
            <summary>
            Retrieves the specified extension that is registered to this actor system.
            </summary>
            <param name="extensionId">The extension to retrieve</param>
            <returns>The specified extension registered to this actor system</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.TryGetExtension(System.Type,System.Object@)">
            <summary>
            Tries to retrieve an extension with the specified type.
            </summary>
            <param name="extensionType">The type of extension to retrieve</param>
            <param name="extension">The extension that is retrieved if successful</param>
            <returns><c>true</c> if the retrieval was successful; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.TryGetExtension``1(``0@)">
            <summary>
            Tries to retrieve an extension with the specified type.
            </summary>
            <typeparam name="T">The type of extension to retrieve</typeparam>
            <param name="extension">The extension that is retrieved if successful</param>
            <returns><c>true</c> if the retrieval was successful; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.GetExtension``1">
            <summary>
            Retrieves an extension with the specified type that is registered to this actor system.
            </summary>
            <typeparam name="T">The type of extension to retrieve</typeparam>
            <returns>The specified extension registered to this actor system</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.HasExtension(System.Type)">
            <summary>
            Determines whether this actor system has an extension with the specified type.
            </summary>
            <param name="type">The type of the extension being queried.</param>
            <returns><c>true</c> if this actor system has the extension; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.HasExtension``1">
            <summary>
            Determines whether this actor system has the specified extension.
            </summary>
            <typeparam name="T">The type of the extension being queried</typeparam>
            <returns><c>true</c> if this actor system has the extension; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.RegisterOnTermination(System.Action)">
            <summary>
            <para>
            Registers a block of code (callback) to run after ActorSystem.shutdown has been issued and all actors
            in this actor system have been stopped. Multiple code blocks may be registered by calling this method
            multiple times.
            </para>
            <para>
            The callbacks will be run sequentially in reverse order of registration, i.e. last registration is run first.
            </para>
            </summary>
            <param name="code">The code to run</param>
            <exception cref="T:System.Exception">
            This exception is thrown if the system has already shut down or if shutdown has been initiated.
            </exception>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.Terminate">
            <summary>
            <para>
            Terminates this actor system. This will stop the guardian actor, which in turn will recursively stop
            all its child actors, then the system guardian (below which the logging actors reside) and the execute
            all registered termination handlers (<see cref="M:Akka.Actor.ActorSystem.RegisterOnTermination(System.Action)" />).
            </para>
            <para>
            Be careful to not schedule any operations on completion of the returned task using the `dispatcher`
            of this actor system as it will have been shut down before the task completes.
            </para>
            </summary>
            <returns>
            A <see cref="T:System.Threading.Tasks.Task"/> that will complete once the actor system has finished terminating and all actors are stopped.
            </returns>
        </member>
        <member name="P:Akka.Actor.Internal.ActorSystemImpl.WhenTerminated">
            <summary>
            Returns a task which will be completed after the <see cref="T:Akka.Actor.ActorSystem"/> has been
            terminated and termination hooks have been executed. Be careful to not schedule any
            operations on the `dispatcher` of this actor system as it will have been shut down
            before this task completes.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.ActorSystemImpl.Stop(Akka.Actor.IActorRef)">
            <summary>
            Stops the specified actor permanently.
            </summary>
            <param name="actor">The actor to stop</param>
        </member>
        <member name="T:Akka.Actor.Internal.TerminationCallbacks">
            <summary>
            This class represents a callback used to run a task when the actor system is terminating.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.TerminationCallbacks.#ctor(System.Threading.Tasks.Task)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Internal.TerminationCallbacks" /> class.
            </summary>
            <param name="upStreamTerminated">The task to run when the actor system is terminating</param>
        </member>
        <member name="M:Akka.Actor.Internal.TerminationCallbacks.Add(System.Action)">
            <summary>
            Adds a continuation to the current task being performed.
            </summary>
            <param name="code">The method to run as part of the continuation</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the actor system has been terminated.</exception>
        </member>
        <member name="P:Akka.Actor.Internal.TerminationCallbacks.TerminationTask">
            <summary>
            The task that is currently being performed
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.IInitializableActor">
            <summary>
            Marks that the actor needs to be initialized directly after it has been created.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.IInitializableActor.Init">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.InternalCurrentActorCellKeeper">
            <summary>
            TBD
            
            INTERNAL!
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.InternalCurrentActorCellKeeper.Current">
            <summary>
            TBD
            
            INTERNAL!
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.IInternalSupportsTestFSMRef`2">
            <summary>
            INTERNAL API. Used for testing.
            This is used to let TestFSMRef in TestKit access to internal methods.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
            <typeparam name="TState">TBD</typeparam>
            <typeparam name="TData">TBD</typeparam>
        </member>
        <member name="M:Akka.Actor.Internal.IInternalSupportsTestFSMRef`2.ApplyState(Akka.Actor.FSMBase.State{`0,`1})">
            <summary>
            INTERNAL API. Used for testing.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
            <param name="upcomingState">TBD</param>
        </member>
        <member name="P:Akka.Actor.Internal.IInternalSupportsTestFSMRef`2.IsStateTimerActive">
            <summary>
            INTERNAL API. Used for testing.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.InternalActivateFsmLogging">
            <summary>
            INTERNAL API. Used for testing.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.Internal.InternalActivateFsmLogging.Instance">
            <summary>
            INTERNAL API. Used for testing.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.AbstractStash">
            <summary>INTERNAL
            Abstract base class for stash support
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.#ctor(Akka.Actor.IActorContext,System.Int32)">
            <summary>INTERNAL
            Abstract base class for stash support
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
            <param name="context">TBD</param>
            <param name="capacity">TBD</param>
            <exception cref="T:System.NotSupportedException">This exception is thrown if the actor's mailbox isn't deque-based (e.g. <see cref="T:Akka.Dispatch.UnboundedDequeBasedMailbox"/>).</exception>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.Stash">
            <summary>
            Stashes the current message in the actor's state.
            </summary>
            <exception cref="T:Akka.Actor.IllegalActorStateException">This exception is thrown if we attempt to stash the same message more than once.</exception>
            <exception cref="T:Akka.Actor.StashOverflowException">
            This exception is thrown in the event that we're using a <see cref="T:Akka.Dispatch.MessageQueues.BoundedMessageQueue"/>  for the <see cref="T:Akka.Actor.IStash"/> and we've exceeded capacity.
            </exception>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.Unstash">
            <summary>
            Unstash the most recently stashed message (top of the message stack.)
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.UnstashAll">
            <summary>
            Unstash all of the <see cref="T:Akka.Actor.Envelope"/>s in the Stash.
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.UnstashAll(System.Func{Akka.Actor.Envelope,System.Boolean})">
            <summary>
            Unstash all of the <see cref="T:Akka.Actor.Envelope"/>s in the Stash.
            </summary>
            <param name="predicate">A predicate function to determine which messages to select.</param>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.ClearStash">
            <summary>
            Eliminates the contents of the <see cref="T:Akka.Actor.IStash"/>, and returns
            the previous contents of the messages.
            </summary>
            <returns>Previously stashed messages.</returns>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.Prepend(System.Collections.Generic.IEnumerable{Akka.Actor.Envelope})">
            <summary>
            TBD
            </summary>
            <param name="envelopes">TBD</param>
        </member>
        <member name="M:Akka.Actor.Internal.AbstractStash.EnqueueFirst(Akka.Actor.Envelope)">
            <summary>
            Enqueues <paramref name="msg"/> at the first position in the mailbox. If the message contained in
            the envelope is a <see cref="T:Akka.Actor.Terminated"/> message, it will be ensured that it can be re-received
            by the actor.
            </summary>
        </member>
        <member name="T:Akka.Actor.Internal.BoundedStashImpl">
            <summary>INTERNAL
            A stash implementation that is bounded
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.BoundedStashImpl.#ctor(Akka.Actor.IActorContext,System.Int32)">
            <summary>INTERNAL
            A stash implementation that is bounded
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
            <param name="context">TBD</param>
            <param name="capacity">TBD</param>
        </member>
        <member name="T:Akka.Actor.Internal.UnboundedStashImpl">
            <summary>INTERNAL
            A stash implementation that is unbounded
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Internal.UnboundedStashImpl.#ctor(Akka.Actor.IActorContext)">
            <summary>INTERNAL
            A stash implementation that is bounded
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
            <param name="context">TBD</param>
        </member>
        <member name="T:Akka.Actor.CoordinatedShutdownExtension">
            <summary>
            Used to register the <see cref="T:Akka.Actor.CoordinatedShutdown"/> extension with a given <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.CoordinatedShutdownExtension.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Creates a new instance of the <see cref="T:Akka.Actor.CoordinatedShutdown"/> extension.
            </summary>
            <param name="system">The extended actor system.</param>
            <returns>A coordinated shutdown plugin.</returns>
        </member>
        <member name="T:Akka.Actor.Phase">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Actor.Phase.#ctor(System.Collections.Immutable.ImmutableHashSet{System.String},System.TimeSpan,System.Boolean)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Phase"/>
            </summary>
            <param name="dependsOn">The list of other phases this phase depends upon.</param>
            <param name="timeout">A timeout value for any tasks running during this phase.</param>
            <param name="recover">When set to <c>true</c>, this phase can recover from a faulted state during shutdown.</param>
        </member>
        <member name="P:Akka.Actor.Phase.DependsOn">
            <summary>
            The names of other <see cref="T:Akka.Actor.Phase"/>s this phase depends upon.
            </summary>
        </member>
        <member name="P:Akka.Actor.Phase.Timeout">
            <summary>
            The amount of time this phase is allowed to run.
            </summary>
        </member>
        <member name="P:Akka.Actor.Phase.Recover">
            <summary>
            If <c>true</c>, this phase has the ability to recover during a faulted state.
            </summary>
        </member>
        <member name="M:Akka.Actor.Phase.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.Phase.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.Phase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.CoordinatedShutdown">
            <summary>
            An <see cref="T:Akka.Actor.ActorSystem"/> extension used to help coordinate and sequence shutdown activities
            during graceful termination of actor systems, plugins, and so forth.
            </summary>
        </member>
        <member name="M:Akka.Actor.CoordinatedShutdown.#ctor(Akka.Actor.ExtendedActorSystem,System.Collections.Generic.Dictionary{System.String,Akka.Actor.Phase})">
            <summary>
            Initializes a new <see cref="T:Akka.Actor.CoordinatedShutdown"/> instance.
            </summary>
            <param name="system">Access to the <see cref="T:Akka.Actor.ExtendedActorSystem"/>.</param>
            <param name="phases">The list of <see cref="T:Akka.Actor.Phase"/>s provided by the HOCON configuration.</param>
        </member>
        <member name="M:Akka.Actor.CoordinatedShutdown.Get(Akka.Actor.ActorSystem)">
            <summary>
            Retreives the <see cref="T:Akka.Actor.CoordinatedShutdown"/> extension for the current <see cref="T:Akka.Actor.ActorSystem"/>
            </summary>
            <param name="sys">The current actor system.</param>
            <returns>A <see cref="T:Akka.Actor.CoordinatedShutdown"/> instance.</returns>
        </member>
        <member name="P:Akka.Actor.CoordinatedShutdown.System">
            <summary>
            The <see cref="T:Akka.Actor.ActorSystem"/>
            </summary>
        </member>
        <member name="P:Akka.Actor.CoordinatedShutdown.Phases">
            <summary>
            The set of named <see cref="T:Akka.Actor.Phase"/>s that will be executed during coordinated shutdown.
            </summary>
        </member>
        <member name="P:Akka.Actor.CoordinatedShutdown.Log">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Actor.CoordinatedShutdown.OrderedPhases">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="P:Akka.Actor.CoordinatedShutdown.ClrShutdownTask">
            <summary>
            INTERNAL API
            
            Signals when CLR shutdown hooks have been completed
            </summary>
        </member>
        <member name="M:Akka.Actor.CoordinatedShutdown.AddTask(System.String,System.String,System.Func{System.Threading.Tasks.Task{Akka.Done}})">
            <summary>
            Add a task to a phase. It doesn't remove previously added tasks.
            
            Tasks added to the same phase are executed in parallel without any
            ordering assumptions. Next phase will not start until all tasks of
            previous phase have completed.
            </summary>
            <param name="phase">The phase to add this task to.</param>
            <param name="taskName">The name of the task to add to this phase.</param>
            <param name="task">The delegate that produces a <see cref="T:System.Threading.Tasks.Task"/> that will be executed.</param>
            <remarks>
            Tasks should typically be registered as early as possible after system
            startup. When running the <see cref="T:Akka.Actor.CoordinatedShutdown"/> tasks that have been
            registered will be performed but tasks that are added too late will not be run.
            
            
            It is possible to add a task to a later phase from within a task in an earlier phase
            and it will be performed.
            </remarks>
        </member>
        <member name="M:Akka.Actor.CoordinatedShutdown.AddClrShutdownHook(System.Func{System.Threading.Tasks.Task{Akka.Done}})">
            <summary>
            Add a shutdown hook that will execute when the CLR process begins
            its shutdown sequence, invoked via <see cref="E:System.AppDomain.ProcessExit"/>.
            
            Added hooks may run in any order concurrently, but they are run before
            the Akka.NET internal shutdown hooks execute.
            </summary>
            <param name="hook">A task that will be executed during shutdown.</param>
        </member>
        <member name="M:Akka.Actor.CoordinatedShutdown.RunClrHooks">
            <summary>
            INTERNAL API
            
            Should only be called directly by the <see cref="E:System.AppDomain.ProcessExit"/> event
            in production.
            
            Safe to call multiple times, but hooks will only be run once.
            </summary>
            <returns>Returns a <see cref="T:System.Threading.Tasks.Task"/> that will be completed once the process exits.</returns>
        </member>
        <member name="M:Akka.Actor.CoordinatedShutdown.Run(System.String)">
            <summary>
            Run tasks of all phases including and after the given phase.
            </summary>
            <param name="fromPhase">Optional. The phase to start the run from.</param>
            <returns>A task that is completed when all such tasks have been completed, or
            there is failure when <see cref="P:Akka.Actor.Phase.Recover"/> is disabled.</returns>
            <remarks>
            It is safe to call this method multiple times. It will only run once.
            </remarks>
        </member>
        <member name="M:Akka.Actor.CoordinatedShutdown.Timeout(System.String)">
            <summary>
            The configured timeout for a given <see cref="T:Akka.Actor.Phase"/>.
            </summary>
            <param name="phase">The name of the phase.</param>
            <returns>Returns the timeout if ti exists.</returns>
            <exception cref="T:System.ArgumentException">Thrown if <see cref="!:phase"/> doesn't exist in the set of registered phases.</exception>
        </member>
        <member name="P:Akka.Actor.CoordinatedShutdown.TotalTimeout">
            <summary>
            The sum of timeouts of all phases that have some task.
            </summary>
        </member>
        <member name="M:Akka.Actor.CoordinatedShutdown.PhasesFromConfig(Akka.Configuration.Config)">
            <summary>
            INTERNAL API
            </summary>
            <param name="config">The HOCON configuration for the <see cref="T:Akka.Actor.CoordinatedShutdown"/></param>
            <returns>A map of all of the phases of the shutdown.</returns>
        </member>
        <member name="M:Akka.Actor.CoordinatedShutdown.TopologicalSort(System.Collections.Generic.Dictionary{System.String,Akka.Actor.Phase})">
            <summary>
            INTERNAL API: https://en.wikipedia.org/wiki/Topological_sorting
            </summary>
            <param name="phases">The set of phases to sort.</param>
            <returns>A topologically sorted list of phases.</returns>
        </member>
        <member name="M:Akka.Actor.CoordinatedShutdown.InitPhaseActorSystemTerminate(Akka.Actor.ActorSystem,Akka.Configuration.Config,Akka.Actor.CoordinatedShutdown)">
            <summary>
            INTERNAL API
            
            Primes the <see cref="T:Akka.Actor.CoordinatedShutdown"/> with the default phase for
            <see cref="M:Akka.Actor.ActorSystem.Terminate"/>
            </summary>
            <param name="system">The actor system for this extension.</param>
            <param name="conf">The HOCON configuration.</param>
            <param name="coord">The <see cref="T:Akka.Actor.CoordinatedShutdown"/> plugin instance.</param>
        </member>
        <member name="M:Akka.Actor.CoordinatedShutdown.InitClrHook(Akka.Actor.ActorSystem,Akka.Configuration.Config,Akka.Actor.CoordinatedShutdown)">
            <summary>
            Initializes the CLR hook
            </summary>
            <param name="system">The actor system for this extension.</param>
            <param name="conf">The HOCON configuration.</param>
            <param name="coord">The <see cref="T:Akka.Actor.CoordinatedShutdown"/> plugin instance.</param>
        </member>
        <member name="T:Akka.Actor.DeadLetterMessageQueue">
            <summary>
            INTERNAL API
            
            Message queue implementation used to funnel messages to <see cref="T:Akka.Actor.DeadLetterActorRef"/>
            </summary>
        </member>
        <member name="M:Akka.Actor.DeadLetterMessageQueue.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="deadLetters">TBD</param>
        </member>
        <member name="P:Akka.Actor.DeadLetterMessageQueue.HasMessages">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.DeadLetterMessageQueue.Count">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.DeadLetterMessageQueue.Enqueue(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <summary>
            TBD
            </summary>
            <param name="receiver">TBD</param>
            <param name="envelope">TBD</param>
        </member>
        <member name="M:Akka.Actor.DeadLetterMessageQueue.TryDequeue(Akka.Actor.Envelope@)">
            <summary>
            TBD
            </summary>
            <param name="envelope">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DeadLetterMessageQueue.CleanUp(Akka.Actor.IActorRef,Akka.Dispatch.MessageQueues.IMessageQueue)">
            <summary>
            TBD
            </summary>
            <param name="owner">TBD</param>
            <param name="deadletters">TBD</param>
        </member>
        <member name="T:Akka.Actor.DeadLetterMailbox">
            <summary>
            INTERNAL API
            
            Mailbox for dead letters.
            </summary>
        </member>
        <member name="M:Akka.Actor.DeadLetterMailbox.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="deadLetters">TBD</param>
        </member>
        <member name="P:Akka.Actor.DeadLetterMailbox.HasSystemMessages">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.DeadLetterMailbox.SystemDrain(Akka.Dispatch.SysMsg.LatestFirstSystemMessageList)">
            <summary>
            TBD
            </summary>
            <param name="newContents">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DeadLetterMailbox.SystemEnqueue(Akka.Actor.IActorRef,Akka.Dispatch.SysMsg.SystemMessage)">
            <summary>
            TBD
            </summary>
            <param name="receiver">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="T:Akka.Actor.Deploy">
            <summary>
            This class represents a configuration object used in the deployment of an <see cref="T:Akka.Actor.ActorBase">actor</see>.
            </summary>
        </member>
        <member name="F:Akka.Actor.Deploy.Local">
            <summary>
            A deployment configuration that is bound to the <see cref="F:Akka.Actor.Scope.Local"/> scope.
            </summary>
        </member>
        <member name="F:Akka.Actor.Deploy.NoDispatcherGiven">
            <summary>
            This deployment does not have a dispatcher associated with it.
            </summary>
        </member>
        <member name="F:Akka.Actor.Deploy.NoMailboxGiven">
            <summary>
            This deployment does not have a mailbox associated with it.
            </summary>
        </member>
        <member name="F:Akka.Actor.Deploy.NoScopeGiven">
            <summary>
            This deployment has an unspecified scope associated with it.
            </summary>
        </member>
        <member name="F:Akka.Actor.Deploy.None">
            <summary>
            A deployment configuration where none of the options have been configured.
            </summary>
        </member>
        <member name="M:Akka.Actor.Deploy.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Deploy"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.Deploy.#ctor(System.String,Akka.Actor.Scope)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Deploy"/> class.
            </summary>
            <param name="path">The actor path associated with this deployment.</param>
            <param name="scope">The scope to bind to this deployment.</param>
        </member>
        <member name="M:Akka.Actor.Deploy.#ctor(Akka.Actor.Scope)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Deploy"/> class.
            </summary>
            <param name="scope">The scope to bind to this deployment.</param>
        </member>
        <member name="M:Akka.Actor.Deploy.#ctor(Akka.Routing.RouterConfig,Akka.Actor.Scope)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Deploy"/> class.
            </summary>
            <param name="routerConfig">The router to use for this deployment.</param>
            <param name="scope">The scope to bind to this deployment.</param>
        </member>
        <member name="M:Akka.Actor.Deploy.#ctor(Akka.Routing.RouterConfig)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Deploy"/> class.
            </summary>
            <param name="routerConfig">The router to use for this deployment.</param>
        </member>
        <member name="M:Akka.Actor.Deploy.#ctor(System.String,Akka.Configuration.Config,Akka.Routing.RouterConfig,Akka.Actor.Scope,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Deploy"/> class.
            </summary>
            <param name="path">The path to deploy the actor.</param>
            <param name="config">The configuration used when deploying the actor.</param>
            <param name="routerConfig">The router used in this deployment.</param>
            <param name="scope">The scope to bind to this deployment.</param>
            <param name="dispatcher">The dispatcher used in this deployment.</param>
        </member>
        <member name="M:Akka.Actor.Deploy.#ctor(System.String,Akka.Configuration.Config,Akka.Routing.RouterConfig,Akka.Actor.Scope,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Deploy"/> class.
            </summary>
            <param name="path">The path to deploy the actor.</param>
            <param name="config">The configuration used when deploying the actor.</param>
            <param name="routerConfig">The router used in this deployment.</param>
            <param name="scope">The scope to bind to this deployment.</param>
            <param name="dispatcher">The dispatcher used in this deployment.</param>
            <param name="mailbox">The mailbox configured for the actor used in this deployment.</param>
        </member>
        <member name="P:Akka.Actor.Deploy.Path">
            <summary>
            The path where the actor is deployed.
            </summary>
        </member>
        <member name="P:Akka.Actor.Deploy.Config">
            <summary>
            The configuration used for this deployment.
            </summary>
        </member>
        <member name="P:Akka.Actor.Deploy.RouterConfig">
            <summary>
            The router used for this deployment.
            </summary>
        </member>
        <member name="P:Akka.Actor.Deploy.Scope">
            <summary>
            The scope bound to this deployment.
            </summary>
        </member>
        <member name="P:Akka.Actor.Deploy.Mailbox">
            <summary>
            The mailbox configured for the actor used in this deployment.
            </summary>
        </member>
        <member name="P:Akka.Actor.Deploy.Dispatcher">
            <summary>
            The dispatcher used in this deployment.
            </summary>
        </member>
        <member name="M:Akka.Actor.Deploy.Equals(Akka.Actor.Deploy)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            <c>true</c> if the current object is equal to the <paramref name="other" /> parameter; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Actor.Deploy.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Actor.Deploy"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Actor.Deploy"/>.</returns>
        </member>
        <member name="M:Akka.Actor.Deploy.WithFallback(Akka.Actor.Deploy)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Deploy" /> from this deployment using another <see cref="T:Akka.Actor.Deploy" />
            to backfill options that might be missing from this deployment.
            
            <note>
            This method is immutable and returns a new instance of <see cref="T:Akka.Actor.Deploy" />.
            </note>
            </summary>
            <param name="other">The <see cref="T:Akka.Actor.Deploy" /> used for fallback configuration.</param>
            <returns>A new <see cref="T:Akka.Actor.Deploy" /> using <paramref name="other" /> for fallback configuration.</returns>
        </member>
        <member name="M:Akka.Actor.Deploy.WithScope(Akka.Actor.Scope)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Deploy" /> with a given <see cref="T:Akka.Actor.Scope" />.
            
            <note>
            This method is immutable and returns a new instance of <see cref="T:Akka.Actor.Deploy" />.
            </note>
            </summary>
            <param name="scope">The <see cref="T:Akka.Actor.Scope" /> used to configure the new <see cref="T:Akka.Actor.Deploy" />.</param>
            <returns>A new <see cref="T:Akka.Actor.Deploy" /> with the provided <paramref name="scope" />.</returns>
        </member>
        <member name="M:Akka.Actor.Deploy.WithMailbox(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Deploy" /> with a given <paramref name="mailbox" />.
            
            <note>
            This method is immutable and returns a new instance of <see cref="T:Akka.Actor.Deploy" />.
            </note>
            </summary>
            <param name="mailbox">The mailbox used to configure the new <see cref="T:Akka.Actor.Deploy" />.</param>
            <returns>A new <see cref="T:Akka.Actor.Deploy" /> with the provided <paramref name="mailbox" />.</returns>
        </member>
        <member name="M:Akka.Actor.Deploy.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Deploy" /> with a given <paramref name="dispatcher" />.
            
            <note>
            This method is immutable and returns a new instance of <see cref="T:Akka.Actor.Deploy" />.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher used to configure the new <see cref="T:Akka.Actor.Deploy" />.</param>
            <returns>A new <see cref="T:Akka.Actor.Deploy" /> with the provided <paramref name="dispatcher" />.</returns>
        </member>
        <member name="M:Akka.Actor.Deploy.WithRouterConfig(Akka.Routing.RouterConfig)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Deploy" /> with a given <see cref="T:Akka.Routing.RouterConfig" />.
            
            <note>
            This method is immutable and returns a new instance of <see cref="T:Akka.Actor.Deploy" />.
            </note>
            </summary>
            <param name="routerConfig">The <see cref="T:Akka.Routing.RouterConfig" /> used to configure the new <see cref="T:Akka.Actor.Deploy" />.</param>
            <returns>A new <see cref="T:Akka.Actor.Deploy" /> with the provided <paramref name="routerConfig" />.</returns>
        </member>
        <member name="T:Akka.Actor.Deploy.DeploySurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Actor.Deploy"/> configuration object.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="P:Akka.Actor.Deploy.DeploySurrogate.Scope">
            <summary>
            The scope bound to this deployment.
            </summary>
        </member>
        <member name="P:Akka.Actor.Deploy.DeploySurrogate.RouterConfig">
            <summary>
            The router used for this deployment.
            </summary>
        </member>
        <member name="P:Akka.Actor.Deploy.DeploySurrogate.Path">
            <summary>
            The path where the actor is deployed.
            </summary>
        </member>
        <member name="P:Akka.Actor.Deploy.DeploySurrogate.Config">
            <summary>
            The configuration used for this deployment.
            </summary>
        </member>
        <member name="P:Akka.Actor.Deploy.DeploySurrogate.Mailbox">
            <summary>
            The mailbox configured for the actor used in this deployment.
            </summary>
        </member>
        <member name="P:Akka.Actor.Deploy.DeploySurrogate.Dispatcher">
            <summary>
            The dispatcher used in this deployment.
            </summary>
        </member>
        <member name="M:Akka.Actor.Deploy.DeploySurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Actor.Deploy"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Actor.Deploy"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="T:Akka.Actor.Deployer">
            <summary>
            Used to configure and deploy actors.
            </summary>
        </member>
        <member name="F:Akka.Actor.Deployer.Default">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Deployer.#ctor(Akka.Actor.Settings)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Deployer"/> class.
            </summary>
            <param name="settings">The settings used to configure the deployer.</param>
        </member>
        <member name="M:Akka.Actor.Deployer.Lookup(Akka.Actor.ActorPath)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Deployer.Lookup(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Deployer.Lookup(System.Collections.Generic.IEnumerator{System.String})">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Deployer.SetDeploy(Akka.Actor.Deploy)">
            <summary>
            TBD
            </summary>
            <param name="deploy">TBD</param>
            <exception cref="T:Akka.Actor.IllegalActorNameException">
            This exception is thrown if the actor name in the deployment path is empty or contains invalid ASCII.
            Valid ASCII includes letters and anything from <see cref="F:Akka.Actor.ActorPath.ValidSymbols"/>. Note that paths
            cannot start with the <c>$</c>.
            </exception>
        </member>
        <member name="M:Akka.Actor.Deployer.ParseConfig(System.String,Akka.Configuration.Config)">
            <summary>
            Creates an actor deployment to the supplied path, <paramref name="key"/>, using the supplied configuration, <paramref name="config"/>.
            </summary>
            <param name="key">The path used to deploy the actor.</param>
            <param name="config">The configuration used to configure the deployed actor.</param>
            <returns>A configured actor deployment to the given path.</returns>
        </member>
        <member name="T:Akka.Actor.Dsl.IActorDsl">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Dsl.IActorDsl.OnPostRestart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Dsl.IActorDsl.OnPreRestart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Dsl.IActorDsl.OnPostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Dsl.IActorDsl.OnPreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Dsl.IActorDsl.Strategy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.Receive``1(System.Action{``0,Akka.Actor.IActorContext})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.Receive``1(System.Predicate{``0},System.Action{``0,Akka.Actor.IActorContext})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="shouldHandle">TBD</param>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.Receive``1(System.Action{``0,Akka.Actor.IActorContext},System.Predicate{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="handler">TBD</param>
            <param name="shouldHandle">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.ReceiveAny(System.Action{System.Object,Akka.Actor.IActorContext})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.ReceiveAsync``1(System.Func{``0,Akka.Actor.IActorContext,System.Threading.Tasks.Task},System.Predicate{``0})">
            <summary>
            Registers an async handler for messages of the specified type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">the type of the message</typeparam>
            <param name="handler">the message handler invoked on the incoming message</param>
            <param name="shouldHandle">when not null, determines whether this handler should handle the message</param>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.ReceiveAsync``1(System.Predicate{``0},System.Func{``0,Akka.Actor.IActorContext,System.Threading.Tasks.Task})">
            <summary>
            Registers an async handler for messages of the specified type <typeparamref name="T"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="shouldHandle">determines whether this handler should handle the message</param>
            <param name="handler">the message handler invoked on the incoming message</param>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.ReceiveAnyAsync(System.Func{System.Object,Akka.Actor.IActorContext,System.Threading.Tasks.Task})">
            <summary>
            Registers an asynchronous handler for any incoming message that has not already been handled.
            </summary>
            <param name="handler">The message handler that is invoked for all</param>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.DefaultPreRestart(System.Exception,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.DefaultPostRestart(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.DefaultPreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.DefaultPostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.Become(System.Action{System.Object,Akka.Actor.IActorContext})">
            <summary>
            Changes the actor's behavior and replaces the current handler with the specified handler.
            </summary>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.BecomeStacked(System.Action{System.Object,Akka.Actor.IActorContext})">
            <summary>
            Changes the actor's behavior and replaces the current handler with the specified handler without discarding the current.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.Dsl.IActorDsl.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.Dsl.IActorDsl.BecomeStacked(System.Action{System.Object,Akka.Actor.IActorContext})"/>
            is matched with a call to <see cref="M:Akka.Actor.Dsl.IActorDsl.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.UnbecomeStacked">
            <summary>
            Changes the actor's behavior and replaces the current handler with the previous one on the behavior stack.
            <remarks>In order to store an actor on the behavior stack, a call to <see cref="M:Akka.Actor.Dsl.IActorDsl.BecomeStacked(System.Action{System.Object,Akka.Actor.IActorContext})"/> must have been made
            prior to this call</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.Dsl.IActorDsl.ActorOf(System.Action{Akka.Actor.Dsl.IActorDsl},System.String)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.Dsl.Act">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Dsl.Act.OnPostRestart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Dsl.Act.OnPreRestart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Dsl.Act.OnPostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Dsl.Act.OnPreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Dsl.Act.Strategy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.#ctor(System.Action{Akka.Actor.Dsl.IActorDsl})">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.#ctor(System.Action{Akka.Actor.Dsl.IActorDsl,Akka.Actor.IActorContext})">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.Receive``1(System.Action{``0,Akka.Actor.IActorContext})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.Receive``1(System.Action{``0,Akka.Actor.IActorContext},System.Predicate{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="handler">TBD</param>
            <param name="shouldHandle">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.Receive``1(System.Predicate{``0},System.Action{``0,Akka.Actor.IActorContext})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="shouldHandle">TBD</param>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.ReceiveAny(System.Action{System.Object,Akka.Actor.IActorContext})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.ReceiveAsync``1(System.Func{``0,Akka.Actor.IActorContext,System.Threading.Tasks.Task},System.Predicate{``0})">
            <summary>
            Registers an async handler for messages of the specified type <typeparamref name="T"/>
            </summary>
            <typeparam name="T">the type of the message</typeparam>
            <param name="handler">the message handler invoked on the incoming message</param>
            <param name="shouldHandle">when not null, determines whether this handler should handle the message</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.ReceiveAsync``1(System.Predicate{``0},System.Func{``0,Akka.Actor.IActorContext,System.Threading.Tasks.Task})">
            <summary>
            Registers an async handler for messages of the specified type <typeparamref name="T"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="shouldHandle">determines whether this handler should handle the message</param>
            <param name="handler">the message handler invoked on the incoming message</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.ReceiveAnyAsync(System.Func{System.Object,Akka.Actor.IActorContext,System.Threading.Tasks.Task})">
            <summary>
            Registers an asynchronous handler for any incoming message that has not already been handled.
            </summary>
            <param name="handler">The message handler that is invoked for all</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.DefaultPreRestart(System.Exception,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.DefaultPostRestart(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.DefaultPreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.DefaultPostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.Become(System.Action{System.Object,Akka.Actor.IActorContext})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.BecomeStacked(System.Action{System.Object,Akka.Actor.IActorContext})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.ActorOf(System.Action{Akka.Actor.Dsl.IActorDsl},System.String)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.PreRestart(System.Exception,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.PostRestart(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Dsl.Act.SupervisorStrategy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.Dsl.ActExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Dsl.ActExtensions.ActorOf(Akka.Actor.IActorRefFactory,System.Action{Akka.Actor.Dsl.IActorDsl},System.String)">
            <summary>
            TBD
            </summary>
            <param name="factory">TBD</param>
            <param name="config">TBD</param>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Dsl.ActExtensions.ActorOf(Akka.Actor.IActorRefFactory,System.Action{Akka.Actor.Dsl.IActorDsl,Akka.Actor.IActorContext},System.String)">
            <summary>
            TBD
            </summary>
            <param name="factory">TBD</param>
            <param name="config">TBD</param>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.EmptyLocalActorRef">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.EmptyLocalActorRef.#ctor(Akka.Actor.IActorRefProvider,Akka.Actor.ActorPath,Akka.Event.EventStream)">
            <summary>
            TBD
            </summary>
            <param name="provider">TBD</param>
            <param name="path">TBD</param>
            <param name="eventStream">TBD</param>
        </member>
        <member name="P:Akka.Actor.EmptyLocalActorRef.Path">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.EmptyLocalActorRef.Provider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.EmptyLocalActorRef.IsTerminated">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.EmptyLocalActorRef.TellInternal(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
            <exception cref="T:Akka.Actor.InvalidMessageException">This exception is thrown if the given <paramref name="message"/> is undefined.</exception>
        </member>
        <member name="M:Akka.Actor.EmptyLocalActorRef.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Actor.EmptyLocalActorRef.SpecialHandle(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.AkkaException">
            <summary>
            This exception provides the base for all Akka.NET specific exceptions within the system.
            </summary>
        </member>
        <member name="M:Akka.Actor.AkkaException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.AkkaException"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.AkkaException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.AkkaException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="cause">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Actor.AkkaException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.AkkaException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Akka.Actor.AkkaException.Cause">
            <summary>
            The exception that is the cause of the current exception.
            </summary>
        </member>
        <member name="T:Akka.Actor.InvalidActorNameException">
            <summary>
            This exception is thrown when the actor name is invalid.
            </summary>
        </member>
        <member name="M:Akka.Actor.InvalidActorNameException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.InvalidActorNameException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.InvalidActorNameException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.InvalidActorNameException"/> class.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Actor.InvalidActorNameException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.InvalidActorNameException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.AskTimeoutException">
            <summary>
            This exception is thrown when an Ask operation times out.
            </summary>
        </member>
        <member name="M:Akka.Actor.AskTimeoutException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.AskTimeoutException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.AskTimeoutException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.AskTimeoutException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.ActorInterruptedException">
            <summary>
            This exception is thrown when an actor is interrupted in the midst of processing messages.
            
            This is an exception typically thrown when the underlying dispatcher's threads are aborted.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorInterruptedException.#ctor(System.String,System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="cause">TBD</param>
        </member>
        <member name="T:Akka.Actor.ActorInitializationException">
            <summary>
            This exception is thrown when the initialization logic for an Actor fails.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorInitializationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorInitializationException"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorInitializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorInitializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.ActorInitializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorInitializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="cause">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Actor.ActorInitializationException.#ctor(Akka.Actor.IActorRef,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorInitializationException"/> class.
            </summary>
            <param name="actor">The actor whose initialization logic failed.</param>
            <param name="message">The message that describes the error.</param>
            <param name="cause">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Actor.ActorInitializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorInitializationException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Akka.Actor.ActorInitializationException.Actor">
            <summary>
            Retrieves the actor whose initialization logic failed.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorInitializationException.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Actor.LoggerInitializationException">
            <summary>
            This exception is thrown when there was a problem initializing a logger.
            </summary>
        </member>
        <member name="M:Akka.Actor.LoggerInitializationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.LoggerInitializationException"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.LoggerInitializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.LoggerInitializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.LoggerInitializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.LoggerInitializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="cause">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Actor.LoggerInitializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.LoggerInitializationException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.ActorKilledException">
            <summary>
            This exception is thrown when a <see cref="T:Akka.Actor.Kill"/> message has been sent to an Actor.
            <see cref="F:Akka.Actor.SupervisorStrategy.DefaultDecider"/> will by default stop the actor.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorKilledException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorKilledException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.ActorKilledException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorKilledException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.IllegalActorStateException">
            <summary>
            This exception is thrown when a core invariant in the Actor implementation has been violated.
            For instance, if you try to create an Actor that doesn't inherit from <see cref="T:Akka.Actor.ActorBase" />.
            </summary>
        </member>
        <member name="M:Akka.Actor.IllegalActorStateException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.IllegalActorStateException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.IllegalActorStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.IllegalActorStateException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.IllegalActorNameException">
            <summary>
            This exception is thrown when an Actor with an invalid name is deployed.
            </summary>
        </member>
        <member name="M:Akka.Actor.IllegalActorNameException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.IllegalActorNameException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.IllegalActorNameException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.IllegalActorNameException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.DeathPactException">
            <summary>
            This exception is thrown by an Actor that receives a Terminated(someActor) message
            that it doesn't handle itself, effectively crashing the Actor and escalating to the supervisor.
            </summary>
        </member>
        <member name="M:Akka.Actor.DeathPactException.#ctor(Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.DeathPactException"/> class.
            </summary>
            <param name="deadActor">The actor that has been terminated.</param>
        </member>
        <member name="M:Akka.Actor.DeathPactException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.DeathPactException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Akka.Actor.DeathPactException.DeadActor">
            <summary>
            Retrieves the actor that has been terminated.
            </summary>
        </member>
        <member name="T:Akka.Actor.PreRestartException">
             <summary>
             This exception is thrown when the <see cref="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)"/> method fails during a restart attempt.
            
             <note>
             This exception is not propagated to the supervisor, as it originates from the already failed instance,
             hence it is only visible as log entry on the event stream.
             </note>
             </summary>
        </member>
        <member name="M:Akka.Actor.PreRestartException.#ctor(Akka.Actor.IActorRef,System.Exception,System.Exception,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.PreRestartException"/> class.
            </summary>
            <param name="actor">The actor whose <see cref="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)"/> hook failed.</param>
            <param name="restartException">The exception thrown by the <paramref name="actor"/> within <see cref="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)"/>.</param>
            <param name="cause">The exception which caused the restart in the first place.</param>
            <param name="optionalMessage">The message which was optionally passed into <see cref="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)"/>.</param>
        </member>
        <member name="M:Akka.Actor.PreRestartException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.PreRestartException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.PostRestartException">
            <summary>
            This exception is thrown when the Actor constructor or <see cref="M:Akka.Actor.ActorBase.PostRestart(System.Exception)"/> method
            fails during a restart attempt.
            </summary>
        </member>
        <member name="M:Akka.Actor.PostRestartException.#ctor(Akka.Actor.IActorRef,System.Exception,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.PostRestartException"/> class.
            </summary>
            <param name="actor">The actor whose constructor or <see cref="M:Akka.Actor.ActorBase.PostRestart(System.Exception)"/> hook failed.</param>
            <param name="cause">The exception thrown by the <paramref name="actor"/> within <see cref="M:Akka.Actor.ActorBase.PostRestart(System.Exception)"/>.</param>
            <param name="originalCause">The original cause is the exception which caused the restart in the first place.</param>
        </member>
        <member name="M:Akka.Actor.PostRestartException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.PostRestartException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Akka.Actor.PostRestartException.OriginalCause">
            <summary>
             Retrieves the exception which caused the restart in the first place.
             </summary>
        </member>
        <member name="T:Akka.Actor.ActorNotFoundException">
            <summary>
            This exception is thrown when an Actor can not be found.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorNotFoundException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorNotFoundException"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorNotFoundException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:Akka.Actor.ActorNotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            <see cref="T:Akka.Actor.ActorNotFoundException"/> that takes a descriptive <paramref name="message"/> and optional <paramref name="innerException"/>.
            </summary>
            <param name="message">A user-defined error message.</param>
            <param name="innerException">An inner <see cref="T:System.Exception"/>.</param>
        </member>
        <member name="T:Akka.Actor.InvalidMessageException">
             <summary>
             This exception is thrown when an invalid message is sent to an Actor.
            
             <note>
             Currently only <c>null</c> is an invalid message.
             </note>
             </summary>
        </member>
        <member name="M:Akka.Actor.InvalidMessageException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.InvalidMessageException"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.InvalidMessageException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.InvalidMessageException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Actor.InvalidMessageException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.InvalidMessageException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.ExtendedActorSystem">
            <summary>
            More powerful interface to the actor systems implementation which is presented to 
            extensions (see <see cref="T:Akka.Actor.IExtension"/>).
            <remarks>Important Notice:<para>
            This class is not meant to be extended by user code. If you want to
            actually roll your own Akka, beware that you are completely on your own in
            that case!</para></remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.ExtendedActorSystem.Provider">
            <summary>Gets the provider.</summary>
            <value>The provider.</value>
        </member>
        <member name="P:Akka.Actor.ExtendedActorSystem.Guardian">
            <summary>
            Gets the top-level supervisor of all user actors created using 
            <see cref="M:Akka.Actor.ActorSystem.ActorOf(Akka.Actor.Props,System.String)">system.ActorOf(...)</see>
            </summary>
        </member>
        <member name="P:Akka.Actor.ExtendedActorSystem.LookupRoot">
            <summary>
            The <see cref="T:Akka.Actor.RootGuardianActorRef"/>, used as the lookup for <see cref="T:Akka.Actor.IActorRef"/> resolutions.
            </summary>
        </member>
        <member name="P:Akka.Actor.ExtendedActorSystem.SystemGuardian">
            <summary>
            Gets the top-level supervisor of all system-internal services like logging.
            </summary>
        </member>
        <member name="P:Akka.Actor.ExtendedActorSystem.ActorPipelineResolver">
            <summary>
            Gets the actor producer pipeline resolver for current actor system. It may be used by
            Akka plugins to inject custom behavior directly into actor creation chain.
            </summary>
        </member>
        <member name="M:Akka.Actor.ExtendedActorSystem.SystemActorOf(Akka.Actor.Props,System.String)">
            <summary>
            Creates a new system actor in the "/system" namespace. This actor 
            will be shut down during system shutdown only after all user actors have
            terminated.
            </summary>
            <param name="props">The <see cref="T:Akka.Actor.Props"/> used to create the actor</param>
            <param name="name">The name of the actor to create. The default value is <see langword="null"/>.</param>
            <returns>A reference to the newly created actor</returns>
        </member>
        <member name="M:Akka.Actor.ExtendedActorSystem.SystemActorOf``1(System.String)">
            <summary>
            Creates a new system actor in the "/system" namespace. This actor 
            will be shut down during system shutdown only after all user actors have
            terminated.
            </summary>
            <typeparam name="TActor">The type of actor to create</typeparam>
            <param name="name">The name of the actor to create. The default value is <see langword="null"/>.</param>
            <returns>A reference to the newly created actor</returns>
        </member>
        <member name="M:Akka.Actor.ExtendedActorSystem.Abort">
            <summary>
            Aggressively terminates an <see cref="T:Akka.Actor.ActorSystem"/> without waiting for the normal shutdown process to run as-is.
            </summary>
        </member>
        <member name="T:Akka.Actor.IExtension">
            <summary>
            This interface is used to mark an object as an <see cref="T:Akka.Actor.ActorSystem"/> extension.
            </summary>
        </member>
        <member name="T:Akka.Actor.IExtensionId">
            <summary>
            This interface is used to distinguish unique <see cref="T:Akka.Actor.ActorSystem"/> extensions.
            </summary>
        </member>
        <member name="M:Akka.Actor.IExtensionId.Apply(Akka.Actor.ActorSystem)">
            <summary>
            Registers the current extension to a given actor system.
            </summary>
            <param name="system">The actor system in which to register the extension.</param>
            <returns>The extension registered to the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.IExtensionId.Get(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the current extension from a given actor system.
            </summary>
            <param name="system">The actor system from which to retrieve the extension.</param>
            <returns>The extension retrieved from the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.IExtensionId.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Creates the current extension using a given actor system.
            
            <note>
            Internal use only.
            </note>
            </summary>
            <param name="system">The actor system to use when creating the extension.</param>
            <returns>The extension created using the given actor system.</returns>
        </member>
        <member name="P:Akka.Actor.IExtensionId.ExtensionType">
            <summary>
            Retrieves the underlying type for the current extension
            </summary>
        </member>
        <member name="T:Akka.Actor.IExtensionId`1">
            <summary>
            This interface is used to distinguish unique <see cref="T:Akka.Actor.ActorSystem"/> extensions.
            </summary>
            <typeparam name="T">The type associated with the current extension.</typeparam>
        </member>
        <member name="M:Akka.Actor.IExtensionId`1.Apply(Akka.Actor.ActorSystem)">
            <summary>
            Registers the current extension to a given actor system.
            </summary>
            <param name="system">The actor system in which to register the extension.</param>
            <returns>The extension registered to the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.IExtensionId`1.Get(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the current extension from a given actor system.
            </summary>
            <param name="system">The actor system from which to retrieve the extension.</param>
            <returns>The extension retrieved from the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.IExtensionId`1.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Creates the current extension using a given actor system.
            
            <note>
            Internal use only.
            </note>
            </summary>
            <param name="system">The actor system to use when creating the extension.</param>
            <returns>The extension created using the given actor system.</returns>
        </member>
        <member name="T:Akka.Actor.ActorSystemWithExtensions">
            <summary>
            This class contains extension methods used for resolving <see cref="T:Akka.Actor.ActorSystem"/> extensions.
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorSystemWithExtensions.WithExtension``1(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the extension specified by a given type, <typeparamref name="T"/>, from a given actor system.
            </summary>
            <typeparam name="T">The type associated with the extension to retrieve.</typeparam>
            <param name="system">The actor system from which to retrieve the extension.</param>
            <returns>The extension retrieved from the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystemWithExtensions.WithExtension``1(Akka.Actor.ActorSystem,System.Type)">
            <summary>
            Retrieves the extension specified by a given type, <typeparamref name="T"/>, from a given actor system.
            If the extension does not exist within the actor system, then the extension specified by <paramref name="extensionId"/>
            is registered to the actor system.
            </summary>
            <typeparam name="T">The type associated with the extension to retrieve.</typeparam>
            <param name="system">The actor system from which to retrieve the extension or to register with if it does not exist.</param>
            <param name="extensionId">The type of the extension to register if it does not exist in the given actor system.</param>
            <returns>The extension retrieved from the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.ActorSystemWithExtensions.WithExtension``2(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the extension specified by a given type, <typeparamref name="T"/>, from a given actor system.
            If the extension does not exist within the actor system, then the extension specified by <typeparamref name="TI"/>
            is registered to the actor system.
            </summary>
            <typeparam name="T">The type associated with the extension to retrieve.</typeparam>
            <typeparam name="TI">The type associated with the extension to retrieve if it does not exist within the system.</typeparam>
            <param name="system">The actor system from which to retrieve the extension or to register with if it does not exist.</param>
            <returns>The extension retrieved from the given actor system.</returns>
        </member>
        <member name="T:Akka.Actor.ExtensionIdProvider`1">
            <summary>
            This class represents the base provider implementation for creating, registering and retrieving extensions within an <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
            <typeparam name="T">The type of the extension being provided.</typeparam>
        </member>
        <member name="M:Akka.Actor.ExtensionIdProvider`1.Apply(Akka.Actor.ActorSystem)">
            <summary>
            Registers the current extension to a given actor system.
            </summary>
            <param name="system">The actor system in which to register the extension.</param>
            <returns>The extension registered to the given actor system.</returns>
        </member>
        <member name="P:Akka.Actor.ExtensionIdProvider`1.ExtensionType">
            <summary>
            Retrieves the underlying type for the current extension
            </summary>
        </member>
        <member name="M:Akka.Actor.ExtensionIdProvider`1.Get(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the current extension from a given actor system.
            </summary>
            <param name="system">The actor system from which to retrieve the extension.</param>
            <returns>The extension retrieved from the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.ExtensionIdProvider`1.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Creates the current extension using a given actor system.
            </summary>
            <param name="system">The actor system to use when creating the extension.</param>
            <returns>The extension created using the given actor system.</returns>
        </member>
        <member name="M:Akka.Actor.ExtensionIdProvider`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns><c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Actor.ExtensionIdProvider`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. </returns>
        </member>
        <member name="T:Akka.Actor.FSMBase">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.CurrentState`1">
            <summary>
            Message type which is sent directly to the subscriber Actor in <see cref="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack"/>
            before sending any <see cref="T:Akka.Actor.FSMBase.Transition`1"/> messages.
            </summary>
            <typeparam name="TS">The type of the state being used in this finite state machine.</typeparam>
        </member>
        <member name="M:Akka.Actor.FSMBase.CurrentState`1.#ctor(Akka.Actor.IActorRef,`0)">
            <summary>
            Initializes a new instance of the CurrentState
            </summary>
            <param name="fsmRef">TBD</param>
            <param name="state">TBD</param>
        </member>
        <member name="P:Akka.Actor.FSMBase.CurrentState`1.FsmRef">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.CurrentState`1.State">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.CurrentState`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.FSMBase.CurrentState`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.FSMBase.CurrentState`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.FSMBase.Transition`1">
            <summary>
            Message type which is used to communicate transitions between states to all subscribed listeners
            (use <see cref="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack"/>)
            </summary>
            <typeparam name="TS">The type of state used</typeparam>
        </member>
        <member name="M:Akka.Actor.FSMBase.Transition`1.#ctor(Akka.Actor.IActorRef,`0,`0)">
            <summary>
            Initializes a new instance of the Transition
            </summary>
            <param name="fsmRef">TBD</param>
            <param name="from">TBD</param>
            <param name="to">TBD</param>
        </member>
        <member name="P:Akka.Actor.FSMBase.Transition`1.FsmRef">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.Transition`1.From">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.Transition`1.To">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.Transition`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.FSMBase.Transition`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.FSMBase.Transition`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack">
            <summary>
            Send this to an <see cref="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack"/> to request first the <see cref="T:Akka.Actor.FSMBase.UnsubscribeTransitionCallBack"/>
            followed by a series of <see cref="T:Akka.Actor.FSMBase.Transition`1"/> updates. Cancel the subscription using
            <see cref="T:Akka.Actor.FSMBase.CurrentState`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.SubscribeTransitionCallBack.#ctor(Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the SubscribeTransitionCallBack
            </summary>
            <param name="actorRef">TBD</param>
        </member>
        <member name="P:Akka.Actor.FSMBase.SubscribeTransitionCallBack.ActorRef">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.UnsubscribeTransitionCallBack">
            <summary>
            Unsubscribe from <see cref="T:Akka.Actor.FSMBase.SubscribeTransitionCallBack"/> notifications which were
            initialized by sending the corresponding <see cref="T:Akka.Actor.FSMBase.Transition`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.UnsubscribeTransitionCallBack.#ctor(Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the UnsubscribeTransitionCallBack
            </summary>
            <param name="actorRef">TBD</param>
        </member>
        <member name="P:Akka.Actor.FSMBase.UnsubscribeTransitionCallBack.ActorRef">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Reason">
            <summary>
            Reason why this <see cref="T:Akka.Actor.FSM`2"/> is shutting down
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Normal">
            <summary>
            Default <see cref="T:Akka.Actor.FSMBase.Reason"/> if calling Stop().
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.Normal.#ctor">
            <summary>
            Obsolete. Use <see cref="P:Akka.Actor.FSMBase.Normal.Instance"/> instead.
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.Normal.Instance">
            <summary>
            Singleton instance of Normal
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Shutdown">
            <summary>
            Reason given when someone as calling <see cref="M:Akka.Actor.FSM`2.Stop"/> from outside;
            also applies to <see cref="T:Akka.Actor.ActorSystem"/> supervision directive.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.Shutdown.#ctor">
            <summary>
            Obsolete. Use <see cref="P:Akka.Actor.FSMBase.Shutdown.Instance"/> instead.
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.Shutdown.Instance">
            <summary>
            Singleton instance of Shutdown
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Failure">
            <summary>
            Signifies that the <see cref="T:Akka.Actor.FSM`2"/> is shutting itself down because of an error,
            e.g. if the state to transition into does not exist. You can use this to communicate a more
            precise cause to the <see cref="M:Akka.Actor.FSM`2.OnTermination(System.Action{Akka.Actor.FSMBase.StopEvent{`0,`1}})"/> block.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.Failure.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the Failure
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="P:Akka.Actor.FSMBase.Failure.Cause">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.Failure.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.FSMBase.StateTimeout">
            <summary>
            Used in the event of a timeout between transitions
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.StateTimeout.#ctor">
            <summary>
            Obsolete. Use <see cref="P:Akka.Actor.FSMBase.StateTimeout.Instance"/> instead.
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.StateTimeout.Instance">
            <summary>
            Singleton instance of StateTimeout
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.TimeoutMarker">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.TimeoutMarker.#ctor(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="generation">TBD</param>
        </member>
        <member name="P:Akka.Actor.FSMBase.TimeoutMarker.Generation">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.Timer">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.Timer.#ctor(System.String,System.Object,System.Boolean,System.Int32,Akka.Actor.IActorContext)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="message">TBD</param>
            <param name="repeat">TBD</param>
            <param name="generation">TBD</param>
            <param name="context">TBD</param>
        </member>
        <member name="P:Akka.Actor.FSMBase.Timer.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.Timer.Message">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.Timer.Repeat">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.Timer.Generation">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.Timer.Context">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.Timer.Schedule(Akka.Actor.IActorRef,System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <param name="timeout">TBD</param>
        </member>
        <member name="M:Akka.Actor.FSMBase.Timer.Cancel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.FSMBase.LogEntry`2">
            <summary>
            Log entry of the <see cref="T:Akka.Actor.ILoggingFSM"/> - can be obtained by calling <see cref="!:GetLog"/>
            </summary>
            <typeparam name="TS">The name of the state</typeparam>
            <typeparam name="TD">The data of the state</typeparam>
        </member>
        <member name="M:Akka.Actor.FSMBase.LogEntry`2.#ctor(`0,`1,System.Object)">
            <summary>
            Initializes a new instance of the LogEntry
            </summary>
            <param name="stateName">TBD</param>
            <param name="stateData">TBD</param>
            <param name="fsmEvent">TBD</param>
        </member>
        <member name="P:Akka.Actor.FSMBase.LogEntry`2.StateName">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.LogEntry`2.StateData">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.LogEntry`2.FsmEvent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.LogEntry`2.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.FSMBase.State`2">
            <summary>
            This captures all of the managed state of the <see cref="T:Akka.Actor.FSM`2"/>: the state name,
            the state data, possibly custom timeout, stop reason, and replies accumulated while
            processing the last message.
            </summary>
            <typeparam name="TS">The name of the state</typeparam>
            <typeparam name="TD">The data of the state</typeparam>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.#ctor(`0,`1,System.Nullable{System.TimeSpan},Akka.Actor.FSMBase.Reason,System.Collections.Generic.IReadOnlyList{System.Object},System.Boolean)">
            <summary>
            Initializes a new instance of the State
            </summary>
            <param name="stateName">TBD</param>
            <param name="stateData">TBD</param>
            <param name="timeout">TBD</param>
            <param name="stopReason">TBD</param>
            <param name="replies">TBD</param>
        </member>
        <member name="P:Akka.Actor.FSMBase.State`2.StateName">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.State`2.StateData">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.State`2.Timeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.State`2.StopReason">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.State`2.Replies">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.State`2.Notifies">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.Copy(System.Nullable{System.TimeSpan},Akka.Actor.FSMBase.Reason,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="timeout">TBD</param>
            <param name="stopReason">TBD</param>
            <param name="replies">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.ForMax(System.TimeSpan)">
            <summary>
            Modify the state transition descriptor to include a state timeout for the 
            next state. This timeout overrides any default timeout set for the next state.
            <remarks>Use <see cref="F:System.TimeSpan.MaxValue"/> to cancel a timeout.</remarks>
            </summary>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.Replying(System.Object)">
            <summary>
            Send reply to sender of the current message, if available.
            </summary>
            <param name="replyValue">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.Using(`1)">
            <summary>
            Modify state transition descriptor with new state data. The data will be set
            when transitioning to the new state.
            </summary>
            <param name="nextStateData">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.WithStopReason(Akka.Actor.FSMBase.Reason)">
            <summary>
            INTERNAL API
            </summary>
            <param name="reason">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.WithNotification(System.Boolean)">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.Equals(Akka.Actor.FSMBase.State{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.FSMBase.State`2.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.FSMBase.Event`1">
            <summary>
            All messages sent to the <see cref="T:Akka.Actor.FSM`2"/> will be wrapped inside an <see cref="T:Akka.Actor.FSMBase.Event`1"/>,
            which allows pattern matching to extract both state and data.
            </summary>
            <typeparam name="TD">The state data for this event</typeparam>
        </member>
        <member name="M:Akka.Actor.FSMBase.Event`1.#ctor(System.Object,`0)">
            <summary>
            Initializes a new instance of the Event
            </summary>
            <param name="fsmEvent">TBD</param>
            <param name="stateData">TBD</param>
        </member>
        <member name="P:Akka.Actor.FSMBase.Event`1.FsmEvent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.Event`1.StateData">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.Event`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.FSMBase.StopEvent`2">
            <summary>
            Class representing the state of the <see cref="T:Akka.Actor.FSM`2"/> within the OnTermination block.
            </summary>
            <typeparam name="TS">TBD</typeparam>
            <typeparam name="TD">TBD</typeparam>
        </member>
        <member name="M:Akka.Actor.FSMBase.StopEvent`2.#ctor(Akka.Actor.FSMBase.Reason,`0,`1)">
            <summary>
            Initializes a new instance of the StopEvent
            </summary>
            <param name="reason">TBD</param>
            <param name="terminatedState">TBD</param>
            <param name="stateData">TBD</param>
        </member>
        <member name="P:Akka.Actor.FSMBase.StopEvent`2.Reason">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.StopEvent`2.TerminatedState">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.FSMBase.StopEvent`2.StateData">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.FSMBase.StopEvent`2.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.FSM`2">
            <summary>
            Finite state machine (FSM) actor.
            </summary>
            <typeparam name="TState">The state name type</typeparam>
            <typeparam name="TData">The state data type</typeparam>
        </member>
        <member name="M:Akka.Actor.FSM`2.#ctor">
            <summary>
            Initializes a new instance of the FSM class.
            </summary>
        </member>
        <member name="T:Akka.Actor.FSM`2.StateFunction">
            <summary>
            Delegate describing this state's response to input
            </summary>
            <param name="fsmEvent">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.FSM`2.TransitionHandler">
            <summary>
            Handler which is called upon each state transition
            </summary>
            <param name="initialState">State designator for the initial state</param>
            <param name="nextState">State designator for the next state</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.When(`0,Akka.Actor.FSM{`0,`1}.StateFunction,System.Nullable{System.TimeSpan})">
            <summary>
            Insert a new <see cref="T:Akka.Actor.FSM`2.StateFunction"/> at the end of the processing chain for the
            given state. If the stateTimeout parameter is set, entering this state without a
            differing explicit timeout setting will trigger a <see cref="T:Akka.Actor.FSMBase.StateTimeout"/>.
            </summary>
            <param name="stateName">designator for the state</param>
            <param name="func">delegate describing this state's response to input</param>
            <param name="timeout">default timeout for this state</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.StartWith(`0,`1,System.Nullable{System.TimeSpan})">
            <summary>
            Sets the initial state for this FSM. Call this method from the constructor before the <see cref="M:Akka.Actor.FSM`2.Initialize"/> method.
            If different state is needed after a restart this method, followed by <see cref="M:Akka.Actor.FSM`2.Initialize"/>, can be used in the actor
            life cycle hooks <see cref="M:Akka.Actor.ActorBase.PreStart"/> and <see cref="M:Akka.Actor.ActorBase.PostRestart(System.Exception)"/>.
            </summary>
            <param name="stateName">Initial state designator.</param>
            <param name="stateData">Initial state data.</param>
            <param name="timeout">State timeout for the initial state, overriding the default timeout for that state.</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.GoTo(`0)">
            <summary>
            Produce transition to other state. Return this from a state function
            in order to effect the transition.
            </summary>
            <param name="nextStateName">State designator for the next state</param>
            <returns>State transition descriptor</returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.GoTo(`0,`1)">
            <summary>
            Obsolete. Use <c>GoTo(nextStateName).Using(stateData) instead.</c>
            </summary>
            <param name="nextStateName">N/A</param>
            <param name="stateData">N/A</param>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.Stay">
            <summary>
            Produce "empty" transition descriptor. Return this from a state function
            when no state change is to be effected.
            </summary>
            <returns>Descriptor for staying in the current state.</returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.Stop">
            <summary>
            Produce change descriptor to stop this FSM actor with <see cref="T:Akka.Actor.FSMBase.Reason"/> <see cref="T:Akka.Actor.FSMBase.Normal"/>
            </summary>
            <returns>Descriptor for stopping in the current state.</returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.Stop(Akka.Actor.FSMBase.Reason)">
            <summary>
            Produce change descriptor to stop this FSM actor with the specified <see cref="T:Akka.Actor.FSMBase.Reason"/>.
            </summary>
            <param name="reason">Reason why this <see cref="T:Akka.Actor.FSM`2"/> is shutting down.</param>
            <returns>Descriptor for stopping in the current state.</returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.Stop(Akka.Actor.FSMBase.Reason,`1)">
            <summary>
            Produce change descriptor to stop this FSM actor with the specified <see cref="T:Akka.Actor.FSMBase.Reason"/>.
            </summary>
            <param name="reason">Reason why this <see cref="T:Akka.Actor.FSM`2"/> is shutting down.</param>
            <param name="stateData">State data.</param>
            <returns>Descriptor for stopping in the current state.</returns>
        </member>
        <member name="T:Akka.Actor.FSM`2.TransformHelper">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.TransformHelper.#ctor(Akka.Actor.FSM{`0,`1}.StateFunction)">
            <summary>
            TBD
            </summary>
            <param name="func">TBD</param>
        </member>
        <member name="P:Akka.Actor.FSM`2.TransformHelper.Func">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.TransformHelper.Using(System.Func{Akka.Actor.FSMBase.State{`0,`1},Akka.Actor.FSMBase.State{`0,`1}})">
            <summary>
            TBD
            </summary>
            <param name="andThen">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.Transform(Akka.Actor.FSM{`0,`1}.StateFunction)">
            <summary>
            TBD
            </summary>
            <param name="func">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.SetTimer(System.String,System.Object,System.TimeSpan,System.Boolean)">
            <summary>
            Schedule named timer to deliver message after given delay, possibly repeating.
            Any existing timer with the same name will automatically be canceled before adding
            the new timer.
            </summary>
            <param name="name">identifier to be used with <see cref="M:Akka.Actor.FSM`2.CancelTimer(System.String)"/>.</param>
            <param name="msg">message to be delivered</param>
            <param name="timeout">delay of first message delivery and between subsequent messages.</param>
            <param name="repeat">send once if false, scheduleAtFixedRate if true</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.CancelTimer(System.String)">
            <summary>
            Cancel a named <see cref="T:Akka.Actor.FSMBase.Timer"/>, ensuring that the message is not subsequently delivered (no race.)
            </summary>
            <param name="name">The name of the timer to cancel.</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.IsTimerActive(System.String)">
            <summary>
            Determines whether the named timer is still active. Returns true 
            unless the timer does not exist, has previously been cancelled, or
            if it was a single-shot timer whose message was already received.
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.SetStateTimeout(`0,System.Nullable{System.TimeSpan})">
            <summary>
            Set the state timeout explicitly. This method can be safely used from
            within a state handler.
            </summary>
            <param name="state">TBD</param>
            <param name="timeout">TBD</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.OnTransition(Akka.Actor.FSM{`0,`1}.TransitionHandler)">
            <summary>
            Set handler which is called upon each state transition
            </summary>
            <param name="transitionHandler">TBD</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.OnTermination(System.Action{Akka.Actor.FSMBase.StopEvent{`0,`1}})">
            <summary>
            Set the handler which is called upon termination of this FSM actor. Calling this
            method again will overwrite the previous contents.
            </summary>
            <param name="terminationHandler">TBD</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.WhenUnhandled(Akka.Actor.FSM{`0,`1}.StateFunction)">
            <summary>
            Set handler which is called upon reception of unhandled FSM messages. Calling
            this method again will overwrite the previous contents.
            </summary>
            <param name="stateFunction">TBD</param>
        </member>
        <member name="M:Akka.Actor.FSM`2.Initialize">
            <summary>
            Verify the existence of initial state and setup timers. This should be the
            last call within the constructor or <see cref="M:Akka.Actor.ActorBase.PreStart"/> and
            <see cref="M:Akka.Actor.ActorBase.PostRestart(System.Exception)"/>.
            </summary>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown when this method is called before <see cref="M:Akka.Actor.FSM`2.StartWith(`0,`1,System.Nullable{System.TimeSpan})"/> is called.
            </exception>
        </member>
        <member name="P:Akka.Actor.FSM`2.StateName">
            <summary>
            Current state name
            </summary>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown if this property is accessed before <see cref="M:Akka.Actor.FSM`2.StartWith(`0,`1,System.Nullable{System.TimeSpan})"/> was called.
            </exception>
        </member>
        <member name="P:Akka.Actor.FSM`2.StateData">
            <summary>
            Current state data
            </summary>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown if this property is accessed before <see cref="M:Akka.Actor.FSM`2.StartWith(`0,`1,System.Nullable{System.TimeSpan})"/> was called.
            </exception>
        </member>
        <member name="P:Akka.Actor.FSM`2.NextStateData">
            <summary>
            Return next state data (available in <see cref="M:Akka.Actor.FSM`2.OnTransition(Akka.Actor.FSM{`0,`1}.TransitionHandler)"/> handlers)
            </summary>
            <exception cref="T:System.InvalidOperationException">
            This exception is thrown if this property is accessed outside of an <see cref="M:Akka.Actor.FSM`2.OnTransition(Akka.Actor.FSM{`0,`1}.TransitionHandler)"/> handler.
            </exception>
        </member>
        <member name="P:Akka.Actor.FSM`2.Listeners">
            <summary>
            Retrieves the support needed to interact with an actor's listeners.
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2.DebugEvent">
            <summary>
            Can be set to enable debugging on certain actions taken by the FSM
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._currentState">
            <summary>
            FSM state data and current timeout handling
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._timers">
            <summary>
            Timer handling
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._stateFunctions">
            <summary>
            State definitions
            </summary>
        </member>
        <member name="P:Akka.Actor.FSM`2.HandleEventDefault">
            <summary>
            Unhandled event handler
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._terminateEvent">
            <summary>
            Termination handling
            </summary>
        </member>
        <member name="F:Akka.Actor.FSM`2._transitionEvent">
            <summary>
            Transition handling
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.OrElse(Akka.Actor.FSM{`0,`1}.StateFunction,Akka.Actor.FSM{`0,`1}.StateFunction)">
            <summary>
            C# port of Scala's orElse method for partial function chaining.
            
            See http://scalachina.com/api/scala/PartialFunction.html
            </summary>
            <param name="original">The original <see cref="T:Akka.Actor.FSM`2.StateFunction"/> to be called</param>
            <param name="fallback">The <see cref="T:Akka.Actor.FSM`2.StateFunction"/> to be called if <paramref name="original"/> returns null</param>
            <returns>A <see cref="T:Akka.Actor.FSM`2.StateFunction"/> which combines both the results of <paramref name="original"/> and <paramref name="fallback"/></returns>
        </member>
        <member name="M:Akka.Actor.FSM`2.Receive(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.FSM`2.PostStop">
            <summary>
            Call the <see cref="M:Akka.Actor.FSM`2.OnTermination(System.Action{Akka.Actor.FSMBase.StopEvent{`0,`1}})"/> hook if you want to retain this behavior.
            When overriding make sure to call base.PostStop();
            
            Please note that this method is called by default from <see cref="M:Akka.Actor.ActorBase.PreRestart(System.Exception,System.Object)"/> so
            override that one if <see cref="M:Akka.Actor.FSM`2.OnTermination(System.Action{Akka.Actor.FSMBase.StopEvent{`0,`1}})"/> shall not be called during restart.
            </summary>
        </member>
        <member name="M:Akka.Actor.FSM`2.LogTermination(Akka.Actor.FSMBase.Reason)">
            <summary>
            By default, <see cref="T:Akka.Actor.Failure"/> is logged at error level and other
            reason types are not logged. It is possible to override this behavior.
            </summary>
            <param name="reason">TBD</param>
        </member>
        <member name="T:Akka.Actor.ILoggingFSM">
            <summary>
            Marker interface to let the setting "akka.actor.debug.fsm" control if logging should occur in <see cref="T:Akka.Actor.FSM`2"/>
            </summary>
        </member>
        <member name="T:Akka.Actor.Futures">
            <summary>
                Extension method class designed to create Ask support for
                non-ActorRef objects such as <see cref="T:Akka.Actor.ActorSelection" />.
            </summary>
        </member>
        <member name="M:Akka.Actor.Futures.Ask(Akka.Actor.ICanTell,System.Object,System.Nullable{System.TimeSpan})">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <param name="message">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Futures.Ask(Akka.Actor.ICanTell,System.Object,System.Threading.CancellationToken)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <param name="message">TBD</param>
            <param name="cancellationToken">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Futures.Ask(Akka.Actor.ICanTell,System.Object,System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <param name="message">TBD</param>
            <param name="timeout">TBD</param>
            <param name="cancellationToken">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Futures.Ask``1(Akka.Actor.ICanTell,System.Object,System.Nullable{System.TimeSpan})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="self">TBD</param>
            <param name="message">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Futures.Ask``1(Akka.Actor.ICanTell,System.Object,System.Threading.CancellationToken)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="self">TBD</param>
            <param name="message">TBD</param>
            <param name="cancellationToken">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Futures.Ask``1(Akka.Actor.ICanTell,System.Object,System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="self">TBD</param>
            <param name="message">TBD</param>
            <param name="timeout">TBD</param>
            <param name="cancellationToken">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the system can't resolve the target provider.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Futures.ResolveProvider(Akka.Actor.ICanTell)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.PromiseActorRef">
            <summary>
            Akka private optimized representation of the temporary actor spawned to
            receive the reply to an "ask" operation.
            
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.#ctor(Akka.Actor.IActorRefProvider,System.Threading.Tasks.TaskCompletionSource{System.Object},System.String)">
            <summary>
            Can't access constructor directly - use <see cref="M:Akka.Actor.PromiseActorRef.Apply(Akka.Actor.IActorRefProvider,System.TimeSpan,System.Object,System.String,Akka.Actor.IActorRef)"/> instead.
            </summary>
        </member>
        <member name="P:Akka.Actor.PromiseActorRef.Result">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Actor.PromiseActorRef._mcn">
            <summary>
            This is necessary for weaving the PromiseActorRef into the asked message, i.e. the replyTo pattern.
            </summary>
        </member>
        <member name="F:Akka.Actor.PromiseActorRef._stateDoNotCallMeDirectly">
             As an optimization for the common (local) case we only register this PromiseActorRef
             with the provider when the `path` member is actually queried, which happens during
             serialization (but also during a simple call to `ToString`, `Equals` or `GetHashCode`!).
            
             Defined states:
             null                  => started, path not yet created
             Registering           => currently creating temp path and registering it
             path: ActorPath       => path is available and was registered
             StoppedWithPath(path) => stopped, path available
             Stopped               => stopped, path not yet created
        </member>
        <member name="T:Akka.Actor.PromiseActorRef.Registering">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.PromiseActorRef.Registering.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.PromiseActorRef.Stopped">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.PromiseActorRef.Stopped.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.PromiseActorRef.StoppedWithPath">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.StoppedWithPath.#ctor(Akka.Actor.ActorPath)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
        </member>
        <member name="P:Akka.Actor.PromiseActorRef.StoppedWithPath.Path">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.StoppedWithPath.Equals(Akka.Actor.PromiseActorRef.StoppedWithPath)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.StoppedWithPath.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.StoppedWithPath.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.Apply(Akka.Actor.IActorRefProvider,System.TimeSpan,System.Object,System.String,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="provider">TBD</param>
            <param name="timeout">TBD</param>
            <param name="targetName">TBD</param>
            <param name="messageClassName">TBD</param>
            <param name="sender">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.AddWatcher(Akka.Actor.IActorRef)">
            <summary>
            Returns false if the <see cref="F:Akka.Actor.PromiseActorRef._promise"/> is already completed.
            </summary>
        </member>
        <member name="P:Akka.Actor.PromiseActorRef.Parent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.PromiseActorRef.Path">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.GetPath">
            <summary>
             Contract of this method:
             Must always return the same ActorPath, which must have
             been registered if we haven't been stopped yet.
            </summary>
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.TellInternal(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
            <exception cref="T:Akka.Actor.InvalidMessageException">
            This exception is thrown if the given <paramref name="message"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Actor.PromiseActorRef.Stop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.GracefulStopSupport">
            <summary>
            Returns a <see cref="T:System.Threading.Tasks.Task"/> that will be completed with success when existing messages
            of the target actor have been processed and the actor has been terminated.
            
            Useful when you need to wait for termination or compose ordered termination of several actors,
            which should only be done outside of the <see cref="T:Akka.Actor.ActorSystem"/> as blocking inside <see cref="T:Akka.Actor.ActorBase"/> is discouraged.
            
            <remarks><c>IMPORTANT:</c> the actor being terminated and its supervisor being informed of the availability of the deceased actor's name
            are two distinct operations, which do not obey any reliable ordering.</remarks>
            
            If the target actor isn't terminated within the timeout the <see cref="T:System.Threading.Tasks.Task"/> is completed with failure.
            
            If you want to invoke specialized stopping logic on your target actor instead of <see cref="T:Akka.Actor.PoisonPill"/>, you can pass your stop command as a parameter:
            <code>
                GracefulStop(someChild, timeout, MyStopGracefullyMessage).ContinueWith(r => {
                    // Do something after someChild starts being stopped.
                });
            </code>
            </summary>
        </member>
        <member name="M:Akka.Actor.GracefulStopSupport.GracefulStop(Akka.Actor.IActorRef,System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="target">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.GracefulStopSupport.GracefulStop(Akka.Actor.IActorRef,System.TimeSpan,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="target">TBD</param>
            <param name="timeout">TBD</param>
            <param name="stopMessage">TBD</param>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException">
            This exception is thrown if the underlying task is <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/>.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.ICanWatch">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ICanWatch.Watch(Akka.Actor.IActorRef)">
            <summary>
            Monitors the specified actor for termination. When the <paramref name="subject"/> terminates
            the instance watching will receive a <see cref="T:Akka.Actor.Terminated"/> message.
            <remarks>Note that if the <see cref="T:Akka.Actor.Terminated"/> message isn't handled by the actor,
            by default the actor will crash by throwing a <see cref="T:Akka.Actor.DeathPactException"/>. To change
            the default behavior, override <see cref="M:Akka.Actor.ActorBase.Unhandled(System.Object)"/>.
            </remarks>
            </summary>
            <param name="subject">The actor to monitor for termination.</param>
            <returns>Returns the provided subject</returns>
        </member>
        <member name="M:Akka.Actor.ICanWatch.Unwatch(Akka.Actor.IActorRef)">
            <summary>
            Stops monitoring the <paramref name="subject"/> for termination.
            </summary>
            <param name="subject">The actor to stop monitor for termination.</param>
            <returns>Returns the provided subject</returns>
        </member>
        <member name="T:Akka.Actor.IActorContext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorContext.Self">
            <summary>
            Gets the <see cref="T:Akka.Actor.IActorRef"/> belonging to the current actor.
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorContext.Props">
            <summary>
            The <see cref="P:Akka.Actor.IActorContext.Props"/> used to originally create this <see cref="T:Akka.Actor.IActorRef"/>
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorContext.Dispatcher">
            <summary>
            The dispatcher this actor is running on
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorContext.Sender">
            <summary>
            Gets the <see cref="T:Akka.Actor.IActorRef"/> of the actor who sent the current message.
            
            If the message was not sent by an actor (i.e. some external non-actor code
            sent this actor a message) then this value will default to <see cref="F:Akka.Actor.ActorRefs.NoSender"/>.
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorContext.System">
            <summary>
            Gets a reference to the <see cref="T:Akka.Actor.ActorSystem"/> to which this actor belongs.
            
            <remarks>
            This property is how you can get access to the <see cref="T:Akka.Actor.IScheduler"/> and other parts
            of Akka.NET from within an actor instance.
            </remarks>
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorContext.Parent">
            <summary>
            Gets the <see cref="T:Akka.Actor.IActorRef"/> of the parent of the current actor.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorContext.Become(Akka.Actor.Receive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.IActorContext.BecomeStacked(Akka.Actor.Receive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.IActorContext.BecomeStacked(Akka.Actor.Receive)"/>
            is matched with a call to <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.IActorContext.UnbecomeStacked">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the previous one on the behavior stack.
            <remarks>In order to store an actor on the behavior stack, a call to <see cref="M:Akka.Actor.IActorContext.BecomeStacked(Akka.Actor.Receive)"/> must have been made
            prior to this call</remarks>
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorContext.Child(System.String)">
            <summary>
            Retrieves a child actor with the specified name, if it exists.
            
            If the child with the given name cannot be found, 
            then <see cref="F:Akka.Actor.ActorRefs.Nobody"/> will be returned instead.
            </summary>
            <param name="name">
            The name of the child actor.
            
            e.g. "child1", "foo"
            
            Not the path, just the name of the child at the time it was created by this parent.
            </param>
            <returns>The <see cref="T:Akka.Actor.IActorRef"/> belonging to the child if found, <see cref="F:Akka.Actor.ActorRefs.Nobody"/> otherwise.</returns>
        </member>
        <member name="M:Akka.Actor.IActorContext.GetChildren">
            <summary>
            Gets all of the children that belong to this actor.
            
            If this actor has no children, 
            an empty collection of <see cref="T:Akka.Actor.IActorRef"/> is returned instead.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IActorContext.SetReceiveTimeout(System.Nullable{System.TimeSpan})">
            <summary>
            <para>
            Defines the inactivity timeout after which the sending of a <see cref="P:Akka.Actor.IActorContext.ReceiveTimeout"/> message is triggered.
            When specified, the receive function should be able to handle a <see cref="P:Akka.Actor.IActorContext.ReceiveTimeout"/> message.
            </para>
            
            <para>
            Please note that the receive timeout might fire and enqueue the <see cref="P:Akka.Actor.IActorContext.ReceiveTimeout"/> message right after
            another message was enqueued; hence it is not guaranteed that upon reception of the receive
            timeout there must have been an idle period beforehand as configured via this method.
            </para>
            
            <para>
            Once set, the receive timeout stays in effect (i.e. continues firing repeatedly after inactivity
            periods). Pass in <c>null</c> to switch off this feature.
            </para>
            </summary>
            <param name="timeout">The timeout. Pass in <c>null</c> to switch off this feature.</param>
        </member>
        <member name="P:Akka.Actor.IActorContext.ReceiveTimeout">
            <summary>
            Gets the inactivity deadline timeout set using <see cref="M:Akka.Actor.IActorContext.SetReceiveTimeout(System.Nullable{System.TimeSpan})"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorContext.Stop(Akka.Actor.IActorRef)">
            <summary>
            Issues a stop command to the provided <see cref="T:Akka.Actor.IActorRef"/>, which will cause that actor
            to terminate.
            </summary>
            <param name="child">The actor who will be stopped.</param>
        </member>
        <member name="T:Akka.Actor.IActorRefFactory">
            <summary>
            Interface IActorRefFactory
            </summary>
        </member>
        <member name="M:Akka.Actor.IActorRefFactory.ActorOf(Akka.Actor.Props,System.String)">
            <summary>
            Create new actor as child of this context with the given name, which must
            not start with "$". If the given name is already in use,
            and <see cref="T:Akka.Actor.InvalidActorNameException"/> is thrown.
            
            See <see cref="T:Akka.Actor.Props"/> for details on how to obtain a <see cref="T:Akka.Actor.Props"/> object.
            </summary>
            <param name="props">The props used to create this actor.</param>
            <param name="name">Optional. The name of this actor.</param>
            <returns>A reference to the underlying actor.</returns>
            <exception cref="T:Akka.Actor.InvalidActorNameException">Thrown if the given name is
            invalid or already in use</exception>
            <exception cref="T:Akka.Configuration.ConfigurationException">Thrown if deployment, dispatcher
            or mailbox configuration is wrong</exception>
        </member>
        <member name="M:Akka.Actor.IActorRefFactory.ActorSelection(Akka.Actor.ActorPath)">
            <summary>
            Construct an <see cref="T:Akka.Actor.ActorSelection" /> from the given path, which is
            parsed for wildcards (these are replaced by regular expressions
            internally). No attempt is made to verify the existence of any part of
            the supplied path, it is recommended to send a message and gather the
            replies in order to resolve the matching set of actors.
            </summary>
            <param name="actorPath">The actor path.</param>
            <returns>ActorSelection.</returns>
        </member>
        <member name="M:Akka.Actor.IActorRefFactory.ActorSelection(System.String)">
            <summary>
            Construct an <see cref="T:Akka.Actor.ActorSelection" /> from the given path, which is
            parsed for wildcards (these are replaced by regular expressions
            internally). No attempt is made to verify the existence of any part of
            the supplied path, it is recommended to send a message and gather the
            replies in order to resolve the matching set of actors.
            </summary>
            <param name="actorPath">The actor path.</param>
            <returns>ActorSelection.</returns>
        </member>
        <member name="T:Akka.Actor.IAutoReceivedMessage">
            <summary>
            Marker trait to show which Messages are automatically handled by Akka.NET
            </summary>
        </member>
        <member name="T:Akka.Actor.Terminated">
            <summary>
            When Death Watch is used, the watcher will receive a Terminated(watched) message when watched is terminated.
            Terminated message can't be forwarded to another actor, since that actor might not be watching the subject.
            Instead, if you need to forward Terminated to another actor you should send the information in your own message.
            </summary>
        </member>
        <member name="M:Akka.Actor.Terminated.#ctor(Akka.Actor.IActorRef,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Terminated" /> class.
            </summary>
            <param name="actorRef">the watched actor that terminated</param>
            <param name="existenceConfirmed">is false when the Terminated message was not sent directly from the watched actor, but derived from another source, such as when watching a non-local ActorRef, which might not have been resolved</param>
            <param name="addressTerminated">the Terminated message was derived from that the remote node hosting the watched actor was detected as unreachable</param>
        </member>
        <member name="P:Akka.Actor.Terminated.ActorRef">
            <summary>
            The watched actor that terminated
            </summary>
        </member>
        <member name="P:Akka.Actor.Terminated.AddressTerminated">
            <summary>
            Is false when the Terminated message was not sent
            directly from the watched actor, but derived from another source, such as 
            when watching a non-local ActorRef, which might not have been resolved
            </summary>
        </member>
        <member name="P:Akka.Actor.Terminated.ExistenceConfirmed">
            <summary>
            The Terminated message was derived from that the remote node hosting the watched actor was detected as unreachable
            </summary>
        </member>
        <member name="M:Akka.Actor.Terminated.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Actor.Identify">
            <summary>
            Request to an <see cref="T:Akka.Actor.ICanTell"/> to get back the identity of the underlying actors.
            </summary>
        </member>
        <member name="M:Akka.Actor.Identify.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Identify" /> class.
            </summary>
            <param name="messageId">A correlating ID used to distinguish multiple <see cref="T:Akka.Actor.Identify"/> requests to the same receiver.</param>
        </member>
        <member name="P:Akka.Actor.Identify.MessageId">
            <summary>
            A correlating ID used to distinguish multiple <see cref="T:Akka.Actor.Identify"/> requests to the same receiver.
            </summary>
        </member>
        <member name="M:Akka.Actor.Identify.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Actor.ActorIdentity">
            <summary>
            Response to the <see cref="T:Akka.Actor.Identify"/> message, get identity by Sender
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorIdentity.#ctor(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.ActorIdentity" /> class.
            </summary>
            <param name="messageId">The same correlating ID used in the original <see cref="T:Akka.Actor.Identify"/> message.</param>
            <param name="subject">A reference to the underyling actor.</param>
        </member>
        <member name="P:Akka.Actor.ActorIdentity.MessageId">
            <summary>
            The same correlating ID used in the original <see cref="T:Akka.Actor.Identify"/> message.
            </summary>
        </member>
        <member name="P:Akka.Actor.ActorIdentity.Subject">
            <summary>
            A reference to the underyling actor.
            </summary>
            <remarks>Will be <c>null</c> if sent an <see cref="T:Akka.Actor.ActorSelection"/> that could not be resolved.</remarks>
        </member>
        <member name="M:Akka.Actor.ActorIdentity.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Actor.PoisonPill">
            <summary>
            Sending a <see cref="T:Akka.Actor.PoisonPill"/> to an will stop the actor when the message 
            is processed. <see cref="T:Akka.Actor.PoisonPill"/> is enqueued as ordinary messages and will be handled after 
            messages that were already queued in the mailbox.
            <para>See also <see cref="T:Akka.Actor.Kill"/> which causes the actor to throw an  <see cref="T:Akka.Actor.ActorKilledException"/> when 
            it processes the message, which gets handled using the normal supervisor mechanism, and
            <see cref="M:Akka.Actor.IActorContext.Stop(Akka.Actor.IActorRef)"/> which causes the actor to stop without processing any more messages. </para>
            </summary>
        </member>
        <member name="P:Akka.Actor.PoisonPill.Instance">
            <summary>
            The singleton instance of PoisonPill.
            </summary>
        </member>
        <member name="M:Akka.Actor.PoisonPill.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Actor.Kill">
            <summary>
            Sending an <see cref="T:Akka.Actor.Kill"/> message to an actor causes the actor to throw an 
            <see cref="T:Akka.Actor.ActorKilledException"/> when it processes the message, which gets handled using the normal supervisor mechanism.
            <para>See also <see cref="T:Akka.Actor.PoisonPill"/> which causes the actor to stop when the <see cref="T:Akka.Actor.PoisonPill"/>
            is processed, without throwing an exception, and 
            <see cref="M:Akka.Actor.IActorContext.Stop(Akka.Actor.IActorRef)"/> which causes the actor to stop without processing any more messages. </para>
            </summary>
        </member>
        <member name="P:Akka.Actor.Kill.Instance">
            <summary>
            The singleton instance of Kill.
            </summary>
        </member>
        <member name="M:Akka.Actor.Kill.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Actor.AddressTerminated">
            <summary>
            INTERNAL API
            
            Used for remote death watch. Failure detectors publish this to the
            <see cref="T:Akka.Event.AddressTerminatedTopic"/> when a remote node is detected to be unreachable and / or decided
            to be removed.
            
            The watcher <see cref="!:DeathWatch"/> subscribes to the <see cref="T:Akka.Event.AddressTerminatedTopic"/> and translates this
            event to <see cref="T:Akka.Actor.Terminated"/>, which is sent to itself.
            </summary>
        </member>
        <member name="M:Akka.Actor.AddressTerminated.#ctor(Akka.Actor.Address)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.AddressTerminated" /> class.
            </summary>
            <param name="address">TBD</param>
        </member>
        <member name="P:Akka.Actor.AddressTerminated.Address">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.AddressTerminated.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Actor.ICanTell">
            <summary>
            A shared interface for both <see cref="T:Akka.Actor.IActorRef"/> and <see cref="T:Akka.Actor.ActorSelection"/>,
            both of which can be sent messages via the <see cref="M:Akka.Actor.ICanTell.Tell(System.Object,Akka.Actor.IActorRef)"/> command.
            </summary>
        </member>
        <member name="M:Akka.Actor.ICanTell.Tell(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Asynchronously delivers a message to this <see cref="T:Akka.Actor.IActorRef"/> or <see cref="T:Akka.Actor.ActorSelection"/>
            in a non-blocking fashion. Uses "at most once" delivery semantics.
            </summary>
            <param name="message">The message to be sent to the target.</param>
            <param name="sender">The sender of this message. Defaults to <see cref="F:Akka.Actor.ActorRefs.NoSender"/> if left to <c>null</c>.</param>
        </member>
        <member name="T:Akka.Actor.InboxActor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.InboxActor.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="size">TBD</param>
        </member>
        <member name="M:Akka.Actor.InboxActor.EnqueueQuery(Akka.Actor.IQuery)">
            <summary>
            TBD
            </summary>
            <param name="q">TBD</param>
        </member>
        <member name="M:Akka.Actor.InboxActor.EnqueueMessage(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="msg">TBD</param>
        </member>
        <member name="M:Akka.Actor.InboxActor.ClientPredicate(Akka.Actor.IQuery)">
            <summary>
            TBD
            </summary>
            <param name="query">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.InboxActor.MessagePredicate(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="msg">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.InboxActor.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.IQuery">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.IQuery.Deadline">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.IQuery.Client">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.IQuery.WithClient(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="client">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.Get">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Get.#ctor(System.TimeSpan,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="deadline">TBD</param>
            <param name="client">TBD</param>
        </member>
        <member name="P:Akka.Actor.Get.Deadline">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Get.Client">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Get.WithClient(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="client">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.Select">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Select.#ctor(System.TimeSpan,System.Predicate{System.Object},Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="deadline">TBD</param>
            <param name="predicate">TBD</param>
            <param name="client">TBD</param>
        </member>
        <member name="P:Akka.Actor.Select.Deadline">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Select.Predicate">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Select.Client">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Select.WithClient(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="client">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.StartWatch">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.StartWatch.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="target">TBD</param>
        </member>
        <member name="P:Akka.Actor.StartWatch.Target">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.StopWatch">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.StopWatch.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="target">TBD</param>
        </member>
        <member name="P:Akka.Actor.StopWatch.Target">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.InboxQueue`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Actor.InboxQueue`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.InboxQueue`1.Add(`0)">
            <summary>
            TBD
            </summary>
            <param name="item">TBD</param>
        </member>
        <member name="M:Akka.Actor.InboxQueue`1.Clear">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.InboxQueue`1.Contains(`0)">
            <summary>
            TBD
            </summary>
            <param name="item">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.InboxQueue`1.CopyTo(`0[],System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="array">TBD</param>
            <param name="arrayIndex">TBD</param>
        </member>
        <member name="M:Akka.Actor.InboxQueue`1.Remove(`0)">
            <summary>
            TBD
            </summary>
            <param name="item">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.InboxQueue`1.RemoveAll(System.Predicate{`0})">
            <summary>
            TBD
            </summary>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.InboxQueue`1.Enqueue(`0)">
            <summary>
            TBD
            </summary>
            <param name="item">TBD</param>
        </member>
        <member name="M:Akka.Actor.InboxQueue`1.Dequeue">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.InboxQueue`1.DequeueFirstOrDefault(System.Predicate{`0})">
            <summary>
            TBD
            </summary>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.InboxQueue`1.Count">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.InboxQueue`1.IsReadOnly">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.DeadlineComparer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.DeadlineComparer.Instance">
            <summary>
            The singleton instance of this comparer
            </summary>
        </member>
        <member name="M:Akka.Actor.DeadlineComparer.Compare(Akka.Actor.IQuery,Akka.Actor.IQuery)">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.IInboxable">
            <summary>
            <see cref="T:Akka.Actor.IInboxable"/> is an actor-like object to be listened by external objects.
            It can watch other actors lifecycle and contains inner actor, which could be passed
            as reference to other actors.
            </summary>
        </member>
        <member name="P:Akka.Actor.IInboxable.Receiver">
            <summary>
            Get a reference to internal actor. It may be for example registered in event stream.
            </summary>
        </member>
        <member name="M:Akka.Actor.IInboxable.Receive">
            <summary>
            Receive a next message from current <see cref="T:Akka.Actor.IInboxable"/> with default timeout. This call will return immediately,
            if the internal actor previously received a message, or will block until it'll receive a message.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IInboxable.Receive(System.TimeSpan)">
            <summary>
            Receive a next message from current <see cref="T:Akka.Actor.IInboxable"/>. This call will return immediately,
            if the internal actor previously received a message, or will block for time specified by 
            <paramref name="timeout"/> until it'll receive a message.
            </summary>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IInboxable.ReceiveAsync">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IInboxable.ReceiveAsync(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IInboxable.ReceiveWhere(System.Predicate{System.Object})">
            <summary>
            Receive a next message satisfying specified <paramref name="predicate"/> under default timeout.
            </summary>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IInboxable.ReceiveWhere(System.Predicate{System.Object},System.TimeSpan)">
            <summary>
            Receive a next message satisfying specified <paramref name="predicate"/> under provided <paramref name="timeout"/>.
            </summary>
            <param name="predicate">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IInboxable.Send(Akka.Actor.IActorRef,System.Object)">
            <summary>
            Makes an internal actor act as a proxy of a given <paramref name="message"/>, 
            which is sent to a given target actor. It means, that all <paramref name="target"/>'s
            replies will be sent to current inbox instead.
            </summary>
            <param name="target">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="T:Akka.Actor.Inbox">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Inbox.Create(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.Inbox.Receiver">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Inbox.Watch(Akka.Actor.IActorRef)">
            <summary>
            Make the inboxs actor watch the <paramref name="subject"/> actor such that 
            reception of the <see cref="T:Akka.Actor.Terminated"/> message can then be awaited.
            </summary>
            <param name="subject">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Inbox.Unwatch(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="subject">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Inbox.Send(Akka.Actor.IActorRef,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="actorRef">TBD</param>
            <param name="msg">TBD</param>
        </member>
        <member name="M:Akka.Actor.Inbox.Receive">
            <summary>
            Receive a single message from <see cref="P:Akka.Actor.Inbox.Receiver"/> actor with default timeout. 
            NOTE: Timeout resolution depends on system's scheduler.
            </summary>
            <remarks>
            Don't use this method within actors, since it block current thread until a message is received.
            </remarks>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Inbox.Receive(System.TimeSpan)">
            <summary>
            Receive a single message from <see cref="P:Akka.Actor.Inbox.Receiver"/> actor. 
            Provided <paramref name="timeout"/> is used for cleanup purposes.
            NOTE: <paramref name="timeout"/> resolution depends on system's scheduler.
            </summary>
            <remarks>
            Don't use this method within actors, since it block current thread until a message is received.
            </remarks>
            <param name="timeout">TBD</param>
            <exception cref="T:System.TimeoutException">
            This exception is thrown if the inbox received a <see cref="T:Akka.Actor.Status.Failure"/> response message or
            it didn't receive a response message by the given <paramref name="timeout"/> .
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Inbox.ReceiveWhere(System.Predicate{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="predicate">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Inbox.ReceiveWhere(System.Predicate{System.Object},System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="predicate">TBD</param>
            <param name="timeout">TBD</param>
            <exception cref="T:System.TimeoutException">
            This exception is thrown if the inbox received a <see cref="T:Akka.Actor.Status.Failure"/> response message or
            it didn't receive a response message by the given <paramref name="timeout"/> .
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Inbox.ReceiveAsync">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Inbox.ReceiveAsync(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Inbox.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.Inbox.Dispose(System.Boolean)">
            <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
            <param name="disposing">if set to <c>true</c> the method has been called directly or indirectly by a 
            user's code. Managed and unmanaged resources will be disposed.<br />
            if set to <c>false</c> the method has been called by the runtime from inside the finalizer and only 
            unmanaged resources can be disposed.</param>
        </member>
        <member name="T:Akka.Actor.INoSerializationVerificationNeeded">
            <summary>
                Marker Interface INoSerializationVerificationNeeded, this interface prevents
                implementing message types from being serialized if configuration setting 'akka.actor.serialize-messages' is "on"
            </summary>
        </member>
        <member name="T:Akka.Actor.IPossiblyHarmful">
            <summary>
            Marker interface to indicate that a message might be potentially harmful;
            this is used to block messages coming in over remoting.
            </summary>
        </member>
        <member name="T:Akka.Actor.IUntypedActorContext">
            <summary>
            Interface IUntypedActorContext
            </summary>
        </member>
        <member name="M:Akka.Actor.IUntypedActorContext.Become(Akka.Actor.UntypedReceive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.IUntypedActorContext.BecomeStacked(Akka.Actor.UntypedReceive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.IUntypedActorContext.BecomeStacked(Akka.Actor.UntypedReceive)"/>
            is matched with a call to <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="T:Akka.Actor.LocalActorRef">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalActorRef.#ctor(Akka.Actor.Internal.ActorSystemImpl,Akka.Actor.Props,Akka.Dispatch.MessageDispatcher,Akka.Dispatch.MailboxType,Akka.Actor.IInternalActorRef,Akka.Actor.ActorPath)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <param name="props">TBD</param>
            <param name="dispatcher">TBD</param>
            <param name="mailboxType">TBD</param>
            <param name="supervisor">TBD</param>
            <param name="path">TBD</param>
        </member>
        <member name="M:Akka.Actor.LocalActorRef.NewActorCell(Akka.Actor.Internal.ActorSystemImpl,Akka.Actor.IInternalActorRef,Akka.Actor.Props,Akka.Dispatch.MessageDispatcher,Akka.Actor.IInternalActorRef)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <param name="self">TBD</param>
            <param name="props">TBD</param>
            <param name="dispatcher">TBD</param>
            <param name="supervisor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.LocalActorRef.Underlying">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRef.Cell">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRef.Provider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRef.Parent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRef.Children">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalActorRef.Start">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalActorRef.Stop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalActorRef.Suspend">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRef.IsLocal">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalActorRef.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="P:Akka.Actor.LocalActorRef.Path">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRef.System">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRef.Props">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRef.Dispatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRef.Supervisor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRef.IsTerminated">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.LocalActorRef.MailboxType">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalActorRef.Resume(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="causedByFailure">TBD</param>
        </member>
        <member name="M:Akka.Actor.LocalActorRef.Restart(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Actor.LocalActorRef.TellInternal(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
        </member>
        <member name="M:Akka.Actor.LocalActorRef.GetSingleChild(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.LocalActorRef.GetChild(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.LocalScope">
            <summary>
            This class represents a binding of an actor deployment to a local system.
            </summary>
        </member>
        <member name="T:Akka.Actor.LocalScope.LocalScopeSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Actor.LocalScope"/> binding.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalScope.LocalScopeSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Actor.LocalScope"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Actor.LocalScope"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Actor.LocalScope.Instance">
            <summary>
            The singleton instance of this scope.
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalScope.WithFallback(Akka.Actor.Scope)">
             <summary>
             Creates a new <see cref="T:Akka.Actor.Scope" /> from this scope using another <see cref="T:Akka.Actor.Scope" />
             to backfill options that might be missing from this scope.
            
             <note>
             This method ignores the given scope and returns the singleton instance of this scope.
             </note>
             </summary>
             <param name="other">The <see cref="T:Akka.Actor.Scope" /> used for fallback configuration.</param>
             <returns>The singleton instance of this scope</returns>
        </member>
        <member name="M:Akka.Actor.LocalScope.Copy">
             <summary>
             Creates a copy of the current instance.
            
             <note>
             This method returns the singleton instance of this scope.
             </note>
             </summary>
             <returns>The singleton instance of this scope</returns>
        </member>
        <member name="M:Akka.Actor.LocalScope.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Actor.LocalScope"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Actor.LocalScope"/>.</returns>
        </member>
        <member name="T:Akka.Actor.Envelope">
            <summary>
            Envelope class, represents a message and the sender of the message.
            </summary>
        </member>
        <member name="M:Akka.Actor.Envelope.#ctor(System.Object,Akka.Actor.IActorRef,Akka.Actor.ActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Envelope"/> struct.
            </summary>
            <param name="message">The message being sent.</param>
            <param name="sender">The actor who sent the message.</param>
            <param name="system">The current actor system.</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if the given <paramref name="message"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Actor.Envelope.#ctor(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Envelope"/> struct.
            </summary>
            <param name="message">The message being sent.</param>
            <param name="sender">The actor who sent the message.</param>
        </member>
        <member name="P:Akka.Actor.Envelope.Sender">
            <summary>
            Gets or sets the sender.
            </summary>
            <value>The sender.</value>
        </member>
        <member name="P:Akka.Actor.Envelope.Message">
            <summary>
            Gets or sets the message.
            </summary>
            <value>The message.</value>
        </member>
        <member name="M:Akka.Actor.Envelope.ToString">
            <summary>
            Converts the <see cref="T:Akka.Actor.Envelope"/> to a string representation.
            </summary>
            <returns>A string.</returns>
        </member>
        <member name="T:Akka.Actor.NameAndUid">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.NameAndUid.#ctor(System.String,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="uid">TBD</param>
        </member>
        <member name="P:Akka.Actor.NameAndUid.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.NameAndUid.Uid">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.NameAndUid.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.PipeToSupport">
            <summary>
            Creates the PipeTo pattern for automatically sending the results of completed tasks
            into the inbox of a designated Actor
            </summary>
        </member>
        <member name="M:Akka.Actor.PipeToSupport.PipeTo``1(System.Threading.Tasks.Task{``0},Akka.Actor.ICanTell,Akka.Actor.IActorRef,System.Func{``0,System.Object},System.Func{System.Exception,System.Object})">
            <summary>
            Pipes the output of a Task directly to the <paramref name="recipient"/>'s mailbox once
            the task completes
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="taskToPipe">TBD</param>
            <param name="recipient">TBD</param>
            <param name="sender">TBD</param>
            <param name="success">TBD</param>
            <param name="failure">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.PipeToSupport.PipeTo(System.Threading.Tasks.Task,Akka.Actor.ICanTell,Akka.Actor.IActorRef,System.Func{System.Object},System.Func{System.Exception,System.Object})">
            <summary>
            Pipes the output of a Task directly to the <paramref name="recipient"/>'s mailbox once
            the task completes.  As this task has no result, only exceptions will be piped to the <paramref name="recipient"/>
            </summary>
            <param name="taskToPipe">TBD</param>
            <param name="recipient">TBD</param>
            <param name="sender">TBD</param>
            <param name="success">TBD</param>
            <param name="failure">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.Props">
            <summary>
            This class represents a configuration object used in creating an <see cref="T:Akka.Actor.ActorBase">actor</see>.
            It is immutable and thus thread-safe.
            <example>
            <code>
              private Props props = Props.Empty();
              private Props props = Props.Create(() => new MyActor(arg1, arg2));
            
              private Props otherProps = props.WithDispatcher("dispatcher-id");
              private Props otherProps = props.WithDeploy(deployment info);
            </code>
            </example>
            </summary>
        </member>
        <member name="T:Akka.Actor.Props.PropsSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Actor.Props"/> configuration object.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="P:Akka.Actor.Props.PropsSurrogate.Type">
            <summary>
            The type of actor to create
            </summary>
        </member>
        <member name="P:Akka.Actor.Props.PropsSurrogate.Deploy">
            <summary>
            The configuration used to deploy the actor.
            </summary>
        </member>
        <member name="P:Akka.Actor.Props.PropsSurrogate.Arguments">
            <summary>
            The arguments used to create the actor.
            </summary>
        </member>
        <member name="M:Akka.Actor.Props.PropsSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Actor.Props"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Actor.Props"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="M:Akka.Actor.Props.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Actor.Props"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Actor.Props"/>.</returns>
        </member>
        <member name="M:Akka.Actor.Props.Equals(Akka.Actor.Props)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            <c>true</c> if the current object is equal to the <paramref name="other" /> parameter; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Actor.Props.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.Props.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="F:Akka.Actor.Props.None">
            <summary>
            A pre-configured <see cref="T:Akka.Actor.Props"/> that doesn't create actors.
            
            <note>
            The value of this field is null.
            </note>
            </summary>
        </member>
        <member name="M:Akka.Actor.Props.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Props"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(Akka.Actor.Props)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class.
            </summary>
            <param name="copy">The object that is being cloned.</param>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(System.Type,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class.
            
            <note>
            <see cref="T:Akka.Actor.Props"/> configured in this way uses the <see cref="T:Akka.Actor.Deploy"/> deployer.
            </note>
            </summary>
            <param name="type">The type of the actor to create.</param>
            <param name="args">The arguments needed to create the actor.</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if <see cref="T:Akka.Actor.Props"/> is not instantiated with an actor type.
            </exception>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(System.Type)">
             <summary>
             Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class.
            
             <note>
             <see cref="T:Akka.Actor.Props"/> configured in this way uses the <see cref="T:Akka.Actor.Deploy"/> deployer.
             </note>
             </summary>
             <param name="type">The type of the actor to create.</param>
             <exception cref="T:System.ArgumentNullException">
             This exception is thrown if <see cref="T:Akka.Actor.Props"/> is not instantiated with an actor type.
             </exception>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(System.Type,Akka.Actor.SupervisorStrategy,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class.
            </summary>
            <param name="type">The type of the actor to create.</param>
            <param name="supervisorStrategy">The supervisor strategy used to manage the actor.</param>
            <param name="args">The arguments needed to create the actor.</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if <see cref="T:Akka.Actor.Props"/> is not instantiated with an actor type.
            </exception>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(System.Type,Akka.Actor.SupervisorStrategy,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class.
            </summary>
            <param name="type">The type of the actor to create.</param>
            <param name="supervisorStrategy">The supervisor strategy used to manage the actor.</param>
            <param name="args">The arguments needed to create the actor.</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if <see cref="T:Akka.Actor.Props"/> is not instantiated with an actor type.
            </exception>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(Akka.Actor.Deploy,System.Type,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class.
            </summary>
            <param name="deploy">The configuration used to deploy the actor.</param>
            <param name="type">The type of the actor to create.</param>
            <param name="args">The arguments needed to create the actor.</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if <see cref="T:Akka.Actor.Props"/> is not instantiated with an actor type.
            </exception>
        </member>
        <member name="M:Akka.Actor.Props.#ctor(Akka.Actor.Deploy,System.Type,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.Props" /> class.
            </summary>
            <param name="deploy">The configuration used to deploy the actor.</param>
            <param name="type">The type of the actor to create.</param>
            <param name="args">The arguments needed to create the actor.</param>
            <exception cref="T:System.ArgumentException">This exception is thrown if <paramref name="type"/> is an unknown actor producer.</exception>
        </member>
        <member name="P:Akka.Actor.Props.Type">
            <summary>
            The type of the actor that is created.
            </summary>
        </member>
        <member name="P:Akka.Actor.Props.Dispatcher">
            <summary>
            The dispatcher used in the deployment of the actor.
            </summary>
        </member>
        <member name="P:Akka.Actor.Props.Mailbox">
            <summary>
            The mailbox used in the deployment of the actor.
            </summary>
        </member>
        <member name="P:Akka.Actor.Props.TypeName">
            <summary>
            The assembly qualified name of the type of the actor that is created.
            </summary>
        </member>
        <member name="P:Akka.Actor.Props.RouterConfig">
            <summary>
            The router used in the deployment of the actor.
            </summary>
        </member>
        <member name="P:Akka.Actor.Props.Deploy">
            <summary>
            The configuration used to deploy the actor.
            </summary>
        </member>
        <member name="P:Akka.Actor.Props.SupervisorStrategy">
            <summary>
            The supervisor strategy used to manage the actor.
            </summary>
        </member>
        <member name="P:Akka.Actor.Props.Empty">
            <summary>
            A pre-configured <see cref="T:Akka.Actor.Props"/> that creates an actor that doesn't respond to messages.
            </summary>
        </member>
        <member name="P:Akka.Actor.Props.Arguments">
            <summary>
            The arguments needed to create the actor.
            </summary>
        </member>
        <member name="M:Akka.Actor.Props.Create``1(System.Linq.Expressions.Expression{System.Func{``0}},Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates an actor using a specified lambda expression.
            </summary>
            <typeparam name="TActor">The type of the actor to create.</typeparam>
            <param name="factory">The lambda expression used to create the actor.</param>
            <param name="supervisorStrategy">Optional: The supervisor strategy used to manage the actor.</param>
            <returns>The newly created <see cref="T:Akka.Actor.Props" />.</returns>
            <exception cref="T:System.ArgumentException">The create function must be a 'new T (args)' expression</exception>
        </member>
        <member name="M:Akka.Actor.Props.Create``1(System.Object[])">
            <summary>
            Creates an actor using the given arguments.
            </summary>
            <typeparam name="TActor">The type of the actor to create.</typeparam>
            <param name="args">The arguments needed to create the actor.</param>
            <returns>The newly created <see cref="T:Akka.Actor.Props" />.</returns>
        </member>
        <member name="M:Akka.Actor.Props.CreateBy``1(System.Object[])">
            <summary>
            Creates an actor using a specified actor producer.
            </summary>
            <typeparam name="TProducer">The type of producer used to create the actor.</typeparam>
            <param name="args">The arguments needed to create the actor.</param>
            <returns>The newly created <see cref="T:Akka.Actor.Props" />.</returns>
        </member>
        <member name="M:Akka.Actor.Props.Create``1(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates an actor using a specified supervisor strategy.
            </summary>
            <typeparam name="TActor">The type of the actor to create.</typeparam>
            <param name="supervisorStrategy">The supervisor strategy used to manage the actor.</param>
            <returns>The newly created <see cref="T:Akka.Actor.Props" />.</returns>
        </member>
        <member name="M:Akka.Actor.Props.Create(System.Type,System.Object[])">
            <summary>
            Creates an actor of a specified type.
            </summary>
            <param name="type">The type of the actor to create.</param>
            <param name="args">The arguments needed to create the actor.</param>
            <returns>The newly created <see cref="T:Akka.Actor.Props" />.</returns>
            <exception cref="T:System.ArgumentNullException">Props must be instantiated with an actor type.</exception>
        </member>
        <member name="M:Akka.Actor.Props.WithMailbox(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Props" /> with a given <paramref name="mailbox" />.
            
            <note>
            This method is immutable and returns a new instance of <see cref="T:Akka.Actor.Props" />.
            </note>
            </summary>
            <param name="mailbox">The mailbox used when deploying the actor.</param>
            <returns>A new <see cref="T:Akka.Actor.Props" /> with the provided <paramref name="mailbox" />.</returns>
        </member>
        <member name="M:Akka.Actor.Props.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Props" /> with a given <paramref name="dispatcher" />.
            
            <note>
            This method is immutable and returns a new instance of <see cref="T:Akka.Actor.Props" />.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher used when deploying the actor.</param>
            <returns>A new <see cref="T:Akka.Actor.Props" /> with the provided <paramref name="dispatcher" />.</returns>
        </member>
        <member name="M:Akka.Actor.Props.WithRouter(Akka.Routing.RouterConfig)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Props" /> with a given router.
            
            <note>
            This method is immutable and returns a new instance of <see cref="T:Akka.Actor.Props" />.
            </note>
            </summary>
            <param name="routerConfig">The router used when deploying the actor.</param>
            <returns>A new <see cref="T:Akka.Actor.Props" /> with the provided <paramref name="routerConfig" />.</returns>
        </member>
        <member name="M:Akka.Actor.Props.WithDeploy(Akka.Actor.Deploy)">
             <summary>
             Creates a new <see cref="T:Akka.Actor.Props" /> with a given deployment configuration.
            
             <note>
             This method is immutable and returns a new instance of <see cref="T:Akka.Actor.Props" />.
             </note>
             </summary>
             <param name="deploy">The configuration used to deploy the actor.</param>
             <returns>A new <see cref="T:Akka.Actor.Props" /> with the provided <paramref name="deploy" />.</returns>
        </member>
        <member name="M:Akka.Actor.Props.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
             <summary>
             Creates a new <see cref="T:Akka.Actor.Props" /> with a given supervisor strategy.
            
             <note>
             This method is immutable and returns a new instance of <see cref="T:Akka.Actor.Props" />.
             </note>
             </summary>
             <param name="supervisorStrategy">The supervisor strategy used to manage the actor.</param>
            <returns>A new <see cref="T:Akka.Actor.Props" /> with the provided <paramref name="supervisorStrategy" />.</returns>
        </member>
        <member name="M:Akka.Actor.Props.NewActor">
            <summary>
            Creates a new actor using the configured actor producer.
            
            <remarks>
            This method is only useful when called during actor creation by the ActorSystem.
            </remarks>
            </summary>
            <exception cref="T:System.TypeLoadException">
            This exception is thrown if there was an error creating an actor of type <see cref="P:Akka.Actor.Props.Type"/>
            with the arguments from <see cref="P:Akka.Actor.Props.Arguments"/>.
            </exception>
            <returns>The newly created actor</returns>
        </member>
        <member name="M:Akka.Actor.Props.Copy">
            <summary>
            Creates a copy of the current instance.
            </summary>
            <returns>The newly created <see cref="T:Akka.Actor.Props"/></returns>
        </member>
        <member name="T:Akka.Actor.Props.EmptyActor">
            <summary>
            This class represents a specialized <see cref="T:Akka.Actor.UntypedActor" /> that doesn't respond to messages.
            </summary>
        </member>
        <member name="M:Akka.Actor.Props.EmptyActor.OnReceive(System.Object)">
            <summary>
            Handles messages received by the actor.
            </summary>
            <param name="message">The message past to the actor.</param>
        </member>
        <member name="M:Akka.Actor.Props.Release(Akka.Actor.ActorBase)">
            <summary>
            Signals the producer that it can release its reference to the actor.
            </summary>
            <param name="actor">The actor to release</param>
        </member>
        <member name="T:Akka.Actor.TerminatedProps">
            <summary>
            This class represents a specialized <see cref="T:Akka.Actor.Props"/> used when the actor has been terminated.
            </summary>
        </member>
        <member name="M:Akka.Actor.TerminatedProps.NewActor">
            <summary>
            N/A
            </summary>
            <exception cref="T:System.InvalidOperationException">This exception is thrown automatically since the actor has been terminated.</exception>
            <returns>N/A</returns>
        </member>
        <member name="T:Akka.Actor.DynamicProps`1">
            <summary>
            This class represents a specialized <see cref="T:Akka.Actor.Props"/> that uses dynamic invocation
            to create new actor instances, rather than a traditional <see cref="T:System.Activator"/>.
            
            <note>
            This is intended to be used in conjunction with Dependency Injection.
            </note>
            </summary>
            <typeparam name="TActor">The type of the actor to create.</typeparam>
        </member>
        <member name="M:Akka.Actor.DynamicProps`1.#ctor(System.Func{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.DynamicProps`1" /> class.
            </summary>
            <param name="invoker">The factory method used to create an actor.</param>
        </member>
        <member name="M:Akka.Actor.DynamicProps`1.NewActor">
            <summary>
            Creates a new actor using the configured factory method.
            </summary>
            <returns>The actor created using the factory method.</returns>
        </member>
        <member name="M:Akka.Actor.DynamicProps`1.Copy">
            <summary>
            Creates a copy of the current instance.
            </summary>
            <returns>The newly created <see cref="T:Akka.Actor.Props"/></returns>
        </member>
        <member name="T:Akka.Actor.IIndirectActorProducer">
            <summary>
            This interface defines a class of actor creation strategies deviating from
            the usual default of just reflectively instantiating the <see cref="T:Akka.Actor.ActorBase">Actor</see>
            subclass. It can be used to allow a dependency injection framework to
            determine the actual actor class and how it shall be instantiated.
            </summary>
        </member>
        <member name="M:Akka.Actor.IIndirectActorProducer.Produce">
            <summary>
            This factory method must produce a fresh actor instance upon each
            invocation. It is not permitted to return the same instance more than
            once.
            </summary>
            <returns>A fresh actor instance.</returns>
        </member>
        <member name="P:Akka.Actor.IIndirectActorProducer.ActorType">
            <summary>
            This method is used by <see cref="T:Akka.Actor.Props"/> to determine the type of actor to create.
            The returned type is not used to produce the actor.
            </summary>
            <returns>The type of the actor created.</returns>
        </member>
        <member name="M:Akka.Actor.IIndirectActorProducer.Release(Akka.Actor.ActorBase)">
            <summary>
            This method is used by <see cref="T:Akka.Actor.Props"/> to signal the producer that it can
            release it's reference.
            
            <remarks>
            To learn more about using Dependency Injection in .NET, see <see href="http://www.amazon.com/Dependency-Injection-NET-Mark-Seemann/dp/1935182501">HERE</see>.
            </remarks>
            </summary>
            <param name="actor">The actor to release</param>
        </member>
        <member name="T:Akka.Actor.Receive">
            <summary>
                Delegate Receive
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Actor.ReceiveActor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.PrepareConfigureMessageHandlers">
            <summary>
            Creates and pushes a new MatchBuilder
            </summary>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.OnReceive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Become(System.Action)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="configure">Configures the new handler by calling the different Receive overloads.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.ActorBase.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>
            is matched with a call to <see cref="M:Akka.Actor.ActorBase.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="configure">Configures the new handler by calling the different Receive overloads.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.ReceiveAsync``1(System.Func{``0,System.Threading.Tasks.Task},System.Predicate{``0})">
            <summary>
            Registers an asynchronous handler for incoming messages of the specified type <typeparamref name="T"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>The actor will be suspended until the task returned by <paramref name="handler"/> completes.</remarks>
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type of the message</typeparam>
            <param name="handler">The message handler that is invoked for incoming messages of the specified type <typeparamref name="T"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.ReceiveAsync``1(System.Predicate{``0},System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            Registers an asynchronous handler for incoming messages of the specified type <typeparamref name="T"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>The actor will be suspended until the task returned by <paramref name="handler"/> completes.</remarks>
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type of the message</typeparam>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
            <param name="handler">The message handler that is invoked for incoming messages of the specified type <typeparamref name="T"/></param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.ReceiveAsync(System.Type,System.Func{System.Object,System.Threading.Tasks.Task},System.Predicate{System.Object})">
            <summary>
            Registers an asynchronous handler for incoming messages of the specified <paramref name="messageType"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>The actor will be suspended until the task returned by <paramref name="handler"/> completes.</remarks>
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="messageType">The type of the message</param>
            <param name="handler">The message handler that is invoked for incoming messages of the specified <paramref name="messageType"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.ReceiveAsync(System.Type,System.Predicate{System.Object},System.Func{System.Object,System.Threading.Tasks.Task})">
            <summary>
            Registers an asynchronous handler for incoming messages of the specified <paramref name="messageType"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>The actor will be suspended until the task returned by <paramref name="handler"/> completes.</remarks>
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="messageType">The type of the message</param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
            <param name="handler">The message handler that is invoked for incoming messages of the specified <paramref name="messageType"/></param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.ReceiveAnyAsync(System.Func{System.Object,System.Threading.Tasks.Task})">
            <summary>
            Registers an asynchronous handler for incoming messages of any type.
            <remarks>The actor will be suspended until the task returned by <paramref name="handler"/> completes.</remarks>
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="handler">The message handler that is invoked for all</param>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive``1(System.Action{``0},System.Predicate{``0})">
            <summary>
            Registers a handler for incoming messages of the specified type <typeparamref name="T"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type of the message</typeparam>
            <param name="handler">The message handler that is invoked for incoming messages of the specified type <typeparamref name="T"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if this method is called outside of the actor's constructor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/>.</exception>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive``1(System.Predicate{``0},System.Action{``0})">
            <summary>
            Registers a handler for incoming messages of the specified type <typeparamref name="T"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type of the message</typeparam>
            <param name="handler">The message handler that is invoked for incoming messages of the specified type <typeparamref name="T"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if this method is called outside of the actor's constructor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/>.</exception>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive(System.Type,System.Action{System.Object},System.Predicate{System.Object})">
            <summary>
            Registers a handler for incoming messages of the specified <paramref name="messageType"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="messageType">The type of the message</param>
            <param name="handler">The message handler that is invoked for incoming messages of the specified <paramref name="messageType"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if this method is called outside of the actor's constructor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/>.</exception>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive(System.Type,System.Predicate{System.Object},System.Action{System.Object})">
            <summary>
            Registers a handler for incoming messages of the specified <paramref name="messageType"/>.
            If <paramref name="shouldHandle"/>!=<c>null</c> then it must return true before a message is passed to <paramref name="handler"/>.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="messageType">The type of the message</param>
            <param name="handler">The message handler that is invoked for incoming messages of the specified <paramref name="messageType"/></param>
            <param name="shouldHandle">When not <c>null</c> it is used to determine if the message matches.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if this method is called outside of the actor's constructor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/>.</exception>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive``1(System.Func{``0,System.Boolean})">
            <summary>
            Registers a handler for incoming messages of the specified type <typeparamref name="T"/>.
            The handler should return <c>true</c> if it has handled the message. 
            If the handler returns true no more handlers will be tried; otherwise the next registered handler will be tried.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type of the message</typeparam>
            <param name="handler">The message handler that is invoked for incoming messages of the 
            specified type <typeparamref name="T"/>. It should return <c>true</c>if it handled/matched 
            the message; <c>false</c> otherwise.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if this method is called outside of the actor's constructor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/>.</exception>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.Receive(System.Type,System.Func{System.Object,System.Boolean})">
            <summary>
            Registers a handler for incoming messages of the specified <paramref name="messageType"/>.
            The handler should return <c>true</c> if it has handled the message. 
            If the handler returns true no more handlers will be tried; otherwise the next registered handler will be tried.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="messageType">The type of the message</param>
            <param name="handler">The message handler that is invoked for incoming messages of the 
            specified type <paramref name="messageType"/>. It should return <c>true</c>if it handled/matched 
            the message; <c>false</c> otherwise.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if this method is called outside of the actor's constructor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/>.</exception>
        </member>
        <member name="M:Akka.Actor.ReceiveActor.ReceiveAny(System.Action{System.Object})">
            <summary>
            Registers a handler for incoming messages of any type.
            <remarks>This method may only be called when constructing the actor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/> or <see cref="M:Akka.Actor.ReceiveActor.BecomeStacked(System.Action)"/>.</remarks>
            <remarks>Note that handlers registered prior to this may have handled the message already. 
            In that case, this handler will not be invoked.</remarks>
            </summary>
            <param name="handler">The message handler that is invoked for all</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if this method is called outside of the actor's constructor or from <see cref="M:Akka.Actor.ReceiveActor.Become(System.Action)"/>.</exception>
        </member>
        <member name="T:Akka.Actor.ReceiveTimeout">
            <summary>
            This message is sent to an actor that has set a receive timeout, either by calling 
            <see cref="M:Akka.Actor.IActorContext.SetReceiveTimeout(System.Nullable{System.TimeSpan})">Context.SetReceiveTimeout</see> or
            <see cref="M:Akka.Actor.ActorBase.SetReceiveTimeout(System.Nullable{System.TimeSpan})">SetReceiveTimeout</see>
            and no message has been sent to the actor during the specified amount of time.
            </summary>
        </member>
        <member name="P:Akka.Actor.ReceiveTimeout.Instance">
            <summary>
            Gets the <see cref="T:Akka.Actor.ReceiveTimeout"/> singleton instance.
            </summary>
        </member>
        <member name="T:Akka.Actor.RemoteScope">
            <summary>
            This class represents a binding of an actor deployment to a remote system.
            Actors in this scope are deployed to a specified <see cref="P:Akka.Actor.RemoteScope.Address"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.RemoteScope.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.RemoteScope"/> class.
            </summary>
        </member>
        <member name="M:Akka.Actor.RemoteScope.#ctor(Akka.Actor.Address)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.RemoteScope"/> class.
            </summary>
            <param name="address">The address to which actors are deployed.</param>
        </member>
        <member name="P:Akka.Actor.RemoteScope.Address">
            <summary>
            The address to which actors are deployed.
            </summary>
        </member>
        <member name="M:Akka.Actor.RemoteScope.Equals(Akka.Actor.RemoteScope)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            <c>true</c> if the current object is equal to the <paramref name="other" /> parameter; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Actor.RemoteScope.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Actor.RemoteScope.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Akka.Actor.RemoteScope.WithFallback(Akka.Actor.Scope)">
             <summary>
             Creates a new <see cref="T:Akka.Actor.Scope" /> from this scope using another <see cref="T:Akka.Actor.Scope" />
             to backfill options that might be missing from this scope.
            
             <note>
             This method ignores the given scope and returns the current instance.
             </note>
             </summary>
             <param name="other">The <see cref="T:Akka.Actor.Scope" /> used for fallback configuration.</param>
             <returns>The instance of this scope</returns>
        </member>
        <member name="M:Akka.Actor.RemoteScope.Copy">
            <summary>
            Creates a new <see cref="T:Akka.Actor.RemoteScope" /> that uses the current <see cref="P:Akka.Actor.RemoteScope.Address"/>.
            </summary>
            <returns>The newly created <see cref="T:Akka.Actor.RemoteScope" /></returns>
        </member>
        <member name="T:Akka.Actor.RepointableActorRef">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Actor.RepointableActorRef.System">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Actor.RepointableActorRef.Props">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Actor.RepointableActorRef.Dispatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Actor.RepointableActorRef.MailboxType">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Actor.RepointableActorRef.Supervisor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Actor.RepointableActorRef._path">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.#ctor(Akka.Actor.Internal.ActorSystemImpl,Akka.Actor.Props,Akka.Dispatch.MessageDispatcher,Akka.Dispatch.MailboxType,Akka.Actor.IInternalActorRef,Akka.Actor.ActorPath)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <param name="props">TBD</param>
            <param name="dispatcher">TBD</param>
            <param name="mailboxType">TBD</param>
            <param name="supervisor">TBD</param>
            <param name="path">TBD</param>
        </member>
        <member name="P:Akka.Actor.RepointableActorRef.Underlying">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.RepointableActorRef.Lookup">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.RepointableActorRef.IsTerminated">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.SwapUnderlying(Akka.Actor.ICell)">
            <summary>
            TBD
            </summary>
            <param name="cell">TBD</param>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.Initialize(System.Boolean)">
            <summary>
            Initialize: make a dummy cell which holds just a mailbox, then tell our
            supervisor that we exist so that he can create the real Cell in
            handleSupervise().
            </summary>
            <param name="async">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">This exception is thrown if this function is called more than once.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.Point">
            <summary>
            This method is supposed to be called by the supervisor in HandleSupervise()
            to replace the UnstartedCell with the real one. It assumes no concurrent
            modification of the `underlying` field, though it is safe to send messages
            at any time.
            </summary>
            <exception cref="T:Akka.Pattern.IllegalStateException">This exception is thrown if the underlying cell is undefined.</exception>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.NewCell">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.RepointableActorRef.Path">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.RepointableActorRef.Parent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.RepointableActorRef.Provider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.RepointableActorRef.IsLocal">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.Start">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.Suspend">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.Resume(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="causedByFailure">TBD</param>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.Stop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.Restart(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="P:Akka.Actor.RepointableActorRef.IsStarted">
            <summary>
            TBD
            </summary>
            <exception cref="T:Akka.Pattern.IllegalStateException">This exception is thrown if this property is called before actor is initialized (<see cref="M:Akka.Actor.RepointableActorRef.Initialize(System.Boolean)"/>).</exception>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.TellInternal(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.GetChild(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.RepointableActorRef.GetSingleChild(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.RepointableActorRef.Children">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.UnstartedCell">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Actor.UnstartedCell.#ctor(Akka.Actor.Internal.ActorSystemImpl,Akka.Actor.RepointableActorRef,Akka.Actor.Props,Akka.Actor.IInternalActorRef)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <param name="self">TBD</param>
            <param name="props">TBD</param>
            <param name="supervisor">TBD</param>
        </member>
        <member name="M:Akka.Actor.UnstartedCell.ReplaceWith(Akka.Actor.ICell)">
            <summary>
            TBD
            </summary>
            <param name="cell">TBD</param>
        </member>
        <member name="P:Akka.Actor.UnstartedCell.System">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.UnstartedCell.SystemImpl">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.UnstartedCell.Start">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.UnstartedCell.Suspend">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.UnstartedCell.Resume(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="causedByFailure">TBD</param>
        </member>
        <member name="M:Akka.Actor.UnstartedCell.Restart(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="M:Akka.Actor.UnstartedCell.Stop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.UnstartedCell.Parent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.UnstartedCell.GetChildren">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Actor.UnstartedCell.ChildrenContainer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.UnstartedCell.GetSingleChild(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.UnstartedCell.GetChildByName(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.UnstartedCell.TryGetChildStatsByName(System.String,Akka.Actor.Internal.IChildStats@)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="child">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.UnstartedCell.SendMessage(Akka.Actor.IActorRef,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="sender">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Actor.UnstartedCell.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="P:Akka.Actor.UnstartedCell.IsLocal">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.UnstartedCell.IsTerminated">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.UnstartedCell.HasMessages">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.UnstartedCell.NumberOfMessages">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.UnstartedCell.Self">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.UnstartedCell.Props">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.RootGuardianActorRef">
            <summary>
            INTERNAL API.
            
            Used by <see cref="T:Akka.Actor.GuardianActor"/>
            </summary>
        </member>
        <member name="M:Akka.Actor.RootGuardianActorRef.#ctor(Akka.Actor.Internal.ActorSystemImpl,Akka.Actor.Props,Akka.Dispatch.MessageDispatcher,Akka.Dispatch.MailboxType,Akka.Actor.IInternalActorRef,Akka.Actor.ActorPath,Akka.Actor.IInternalActorRef,System.Collections.Generic.IReadOnlyDictionary{System.String,Akka.Actor.IInternalActorRef})">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <param name="props">TBD</param>
            <param name="dispatcher">TBD</param>
            <param name="mailboxType">TBD</param>
            <param name="supervisor">TBD</param>
            <param name="path">TBD</param>
            <param name="deadLetters">TBD</param>
            <param name="extraNames">TBD</param>
        </member>
        <member name="P:Akka.Actor.RootGuardianActorRef.Parent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.RootGuardianActorRef.SetTempContainer(Akka.Actor.IInternalActorRef)">
            <summary>
            TBD
            </summary>
            <param name="tempContainer">TBD</param>
        </member>
        <member name="M:Akka.Actor.RootGuardianActorRef.GetSingleChild(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.RootGuardianSupervisor">
            <summary>
            Top-level anchor for the supervision hierarchy of this actor system.
            Note: This class is called theOneWhoWalksTheBubblesOfSpaceTime in Akka
            </summary>
        </member>
        <member name="M:Akka.Actor.RootGuardianSupervisor.#ctor(Akka.Actor.RootActorPath,Akka.Actor.IActorRefProvider,System.Threading.Tasks.TaskCompletionSource{Akka.Actor.Status},Akka.Event.ILoggingAdapter)">
            <summary>
            TBD
            </summary>
            <param name="root">TBD</param>
            <param name="provider">TBD</param>
            <param name="terminationPromise">TBD</param>
            <param name="log">TBD</param>
        </member>
        <member name="M:Akka.Actor.RootGuardianSupervisor.TellInternal(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
            <exception cref="T:Akka.Actor.InvalidMessageException">This exception is thrown if the given <paramref name="message"/> is undefined.</exception>
        </member>
        <member name="M:Akka.Actor.RootGuardianSupervisor.SendSystemMessage(Akka.Dispatch.SysMsg.ISystemMessage)">
            <summary>
            TBD
            </summary>
            <param name="systemMessage">TBD</param>
        </member>
        <member name="P:Akka.Actor.RootGuardianSupervisor.CauseOfTermination">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.RootGuardianSupervisor.Stop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.RootGuardianSupervisor.Path">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.RootGuardianSupervisor.Provider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.DateTimeOffsetNowTimeProvider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.DateTimeOffsetNowTimeProvider.Now">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.DateTimeOffsetNowTimeProvider.MonotonicClock">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.DateTimeOffsetNowTimeProvider.HighResMonotonicClock">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.DateTimeOffsetNowTimeProvider.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.DedicatedThreadScheduler">
            <summary>
            Obsolete. Use <see cref="T:Akka.Actor.HashedWheelTimerScheduler"/> instead.
            </summary>
        </member>
        <member name="P:Akka.Actor.DedicatedThreadScheduler.TimeNow">
            <summary>
            Obsolete. Use <see cref="P:Akka.Actor.HashedWheelTimerScheduler.TimeNow"/> instead.
            </summary>
        </member>
        <member name="P:Akka.Actor.DedicatedThreadScheduler.MonotonicClock">
            <summary>
            Obsolete. Use <see cref="P:Akka.Actor.HashedWheelTimerScheduler.MonotonicClock"/> instead.
            </summary>
        </member>
        <member name="P:Akka.Actor.DedicatedThreadScheduler.HighResMonotonicClock">
            <summary>
            Obsolete. Use <see cref="P:Akka.Actor.HashedWheelTimerScheduler.HighResMonotonicClock"/> instead.
            </summary>
        </member>
        <member name="M:Akka.Actor.DedicatedThreadScheduler.#ctor(Akka.Actor.ActorSystem)">
            <summary>
            Obsolete. Use <see cref="!:HashedWheelTimerScheduler(Config, ILoggingAdapter"/> instead.
            </summary>
            <param name="sys">N/A</param>
        </member>
        <member name="M:Akka.Actor.DedicatedThreadScheduler.#ctor(Akka.Configuration.Config,Akka.Event.ILoggingAdapter)">
            <summary>
            Obsolete. Use <see cref="!:HashedWheelTimerScheduler(Config, ILoggingAdapter"/> instead.
            </summary>
            <param name="config">N/A</param>
            <param name="log">N/A</param>
        </member>
        <member name="M:Akka.Actor.DedicatedThreadScheduler.InternalScheduleTellOnce(System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>
            Obsolete. Use <see cref="M:Akka.Actor.HashedWheelTimerScheduler.InternalScheduleTellOnce(System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)"/> instead.
            </summary>
            <param name="delay">N/A</param>
            <param name="receiver">N/A</param>
            <param name="message">N/A</param>
            <param name="sender">N/A</param>
            <param name="cancelable">N/A</param>
        </member>
        <member name="M:Akka.Actor.DedicatedThreadScheduler.InternalScheduleTellRepeatedly(System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>
            Obsolete. Use <see cref="M:Akka.Actor.HashedWheelTimerScheduler.InternalScheduleTellRepeatedly(System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)"/> instead.
            </summary>
            <param name="initialDelay">N/A</param>
            <param name="interval">N/A</param>
            <param name="receiver">N/A</param>
            <param name="message">N/A</param>
            <param name="sender">N/A</param>
            <param name="cancelable">N/A</param>
        </member>
        <member name="M:Akka.Actor.DedicatedThreadScheduler.InternalScheduleOnce(System.TimeSpan,System.Action,Akka.Actor.ICancelable)">
            <summary>
            Obsolete. Use <see cref="M:Akka.Actor.HashedWheelTimerScheduler.InternalScheduleOnce(System.TimeSpan,System.Action,Akka.Actor.ICancelable)"/> instead.
            </summary>
            <param name="delay">N/A</param>
            <param name="action">N/A</param>
            <param name="cancelable">N/A</param>
        </member>
        <member name="M:Akka.Actor.DedicatedThreadScheduler.InternalScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action,Akka.Actor.ICancelable)">
            <summary>
            Obsolete. Use <see cref="M:Akka.Actor.HashedWheelTimerScheduler.InternalScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action,Akka.Actor.ICancelable)"/> instead.
            </summary>
            <param name="initialDelay">N/A</param>
            <param name="interval">N/A</param>
            <param name="action">N/A</param>
            <param name="cancelable">N/A</param>
        </member>
        <member name="M:Akka.Actor.DedicatedThreadScheduler.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.ScheduledWork">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ScheduledWork.#ctor(System.Int64,System.Action,System.Threading.CancellationToken)">
            <summary>
            TBD
            </summary>
            <param name="tickExpires">TBD</param>
            <param name="action">TBD</param>
            <param name="token">TBD</param>
        </member>
        <member name="P:Akka.Actor.ScheduledWork.Token">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ScheduledWork.TickExpires">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ScheduledWork.Action">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.DeprecatedSchedulerExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.DeprecatedSchedulerExtensions.ScheduleOnce(Akka.Actor.IScheduler,System.TimeSpan,Akka.Actor.IActorRef,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="scheduler">TBD</param>
            <param name="initialDelay">TBD</param>
            <param name="receiver">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Actor.DeprecatedSchedulerExtensions.ScheduleOnce(Akka.Actor.IScheduler,System.TimeSpan,Akka.Actor.IActorRef,System.Object,System.Threading.CancellationToken)">
            <summary>
            TBD
            </summary>
            <param name="scheduler">TBD</param>
            <param name="initialDelay">TBD</param>
            <param name="receiver">TBD</param>
            <param name="message">TBD</param>
            <param name="cancellationToken">TBD</param>
        </member>
        <member name="M:Akka.Actor.DeprecatedSchedulerExtensions.Schedule(Akka.Actor.IScheduler,System.TimeSpan,System.TimeSpan,Akka.Actor.IActorRef,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="scheduler">TBD</param>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
            <param name="receiver">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Actor.DeprecatedSchedulerExtensions.Schedule(Akka.Actor.IScheduler,System.TimeSpan,System.TimeSpan,Akka.Actor.IActorRef,System.Object,System.Threading.CancellationToken)">
            <summary>
            TBD
            </summary>
            <param name="scheduler">TBD</param>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
            <param name="receiver">TBD</param>
            <param name="message">TBD</param>
            <param name="cancellationToken">TBD</param>
        </member>
        <member name="M:Akka.Actor.DeprecatedSchedulerExtensions.Schedule(Akka.Actor.IScheduler,System.TimeSpan,System.TimeSpan,System.Action)">
            <summary>
            TBD
            </summary>
            <param name="scheduler">TBD</param>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
            <param name="action">TBD</param>
        </member>
        <member name="M:Akka.Actor.DeprecatedSchedulerExtensions.Schedule(Akka.Actor.IScheduler,System.TimeSpan,System.TimeSpan,System.Action,System.Threading.CancellationToken)">
            <summary>
            TBD
            </summary>
            <param name="scheduler">TBD</param>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
            <param name="action">TBD</param>
            <param name="cancellationToken">TBD</param>
        </member>
        <member name="M:Akka.Actor.DeprecatedSchedulerExtensions.ScheduleOnce(Akka.Actor.IScheduler,System.TimeSpan,System.Action)">
            <summary>
            TBD
            </summary>
            <param name="scheduler">TBD</param>
            <param name="initialDelay">TBD</param>
            <param name="action">TBD</param>
        </member>
        <member name="M:Akka.Actor.DeprecatedSchedulerExtensions.ScheduleOnce(Akka.Actor.IScheduler,System.TimeSpan,System.Action,System.Threading.CancellationToken)">
            <summary>
            TBD
            </summary>
            <param name="scheduler">TBD</param>
            <param name="initialDelay">TBD</param>
            <param name="action">TBD</param>
            <param name="cancellationToken">TBD</param>
        </member>
        <member name="T:Akka.Actor.HashedWheelTimerScheduler">
            <summary>
            This <see cref="T:Akka.Actor.IScheduler"/> implementation is built using a revolving wheel of buckets
            with each bucket belonging to a specific time resolution. As the "clock" of the scheduler ticks it advances
            to the next bucket in the circle and processes the items in it, and optionally reschedules recurring
            tasks into the future into the next relevant bucket.
            
            There are `akka.scheduler.ticks-per-wheel` initial buckets (we round up to the nearest power of 2) with 512
            being the initial default value. The timings are approximated and are still limited by the ceiling of the operating
            system's clock resolution.
            
            Further reading: http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf
            Presentation: http://www.cse.wustl.edu/~cdgill/courses/cs6874/TimingWheels.ppt
            </summary>
        </member>
        <member name="M:Akka.Actor.HashedWheelTimerScheduler.#ctor(Akka.Configuration.Config,Akka.Event.ILoggingAdapter)">
            <summary>
            TBD
            </summary>
            <param name="scheduler">TBD</param>
            <param name="log">TBD</param>
            <exception cref="T:System.ArgumentOutOfRangeException">TBD</exception>
        </member>
        <member name="F:Akka.Actor.HashedWheelTimerScheduler._workerState">
            <summary>
            0 - init, 1 - started, 2 - shutdown
            </summary>
        </member>
        <member name="M:Akka.Actor.HashedWheelTimerScheduler.NormalizeTicksPerWheel(System.Int32)">
            <summary>
            Normalize a wheel size to the nearest power of 2.
            </summary>
            <param name="ticksPerWheel">The original input per wheel.</param>
            <returns><paramref name="ticksPerWheel"/> normalized to the nearest power of 2.</returns>
        </member>
        <member name="M:Akka.Actor.HashedWheelTimerScheduler.Run">
            <summary>
            Scheduler thread entry method
            </summary>
        </member>
        <member name="P:Akka.Actor.HashedWheelTimerScheduler.TimeNow">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.HashedWheelTimerScheduler.MonotonicClock">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.HashedWheelTimerScheduler.HighResMonotonicClock">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.HashedWheelTimerScheduler.InternalScheduleTellOnce(System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>
            TBD
            </summary>
            <param name="delay">TBD</param>
            <param name="receiver">TBD</param>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
            <param name="cancelable">TBD</param>
        </member>
        <member name="M:Akka.Actor.HashedWheelTimerScheduler.InternalScheduleTellRepeatedly(System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>
            TBD
            </summary>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
            <param name="receiver">TBD</param>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
            <param name="cancelable">TBD</param>
        </member>
        <member name="M:Akka.Actor.HashedWheelTimerScheduler.InternalScheduleOnce(System.TimeSpan,System.Action,Akka.Actor.ICancelable)">
            <summary>
            TBD
            </summary>
            <param name="delay">TBD</param>
            <param name="action">TBD</param>
            <param name="cancelable">TBD</param>
        </member>
        <member name="M:Akka.Actor.HashedWheelTimerScheduler.InternalScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action,Akka.Actor.ICancelable)">
            <summary>
            TBD
            </summary>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
            <param name="action">TBD</param>
            <param name="cancelable">TBD</param>
        </member>
        <member name="M:Akka.Actor.HashedWheelTimerScheduler.Dispose">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.HashedWheelTimerScheduler.ScheduledTell">
            <summary>
            INTERNAL API.
            </summary>
        </member>
        <member name="F:Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration.Cancellation">
            <summary>
            The cancellation handle, if any
            </summary>
        </member>
        <member name="F:Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration.Action">
            <summary>
            The task to be executed
            </summary>
        </member>
        <member name="F:Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration.Offset">
            <summary>
            Used to determine the delay for repeatable sends
            </summary>
        </member>
        <member name="F:Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration.Deadline">
            <summary>
            The deadline for determining when to execute
            </summary>
        </member>
        <member name="P:Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration.Repeat">
            <summary>
            Determines if this task will need to be re-scheduled according to its <see cref="F:Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration.Offset"/>.
            </summary>
        </member>
        <member name="P:Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration.Cancelled">
            <summary>
            If <c>true</c>, we skip execution of this task.
            </summary>
        </member>
        <member name="F:Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration.Bucket">
            <summary>
            The <see cref="F:Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration.Bucket"/> to which this registration belongs.
            </summary>
        </member>
        <member name="M:Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration.Reset">
            <summary>
            Resets all of the fields so this registration object can be used again
            </summary>
        </member>
        <member name="M:Akka.Actor.HashedWheelTimerScheduler.Bucket.AddRegistration(Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration)">
            <summary>
            Adds a <see cref="T:Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration"/> to this bucket.
            </summary>
            <param name="reg">The scheduled task.</param>
        </member>
        <member name="M:Akka.Actor.HashedWheelTimerScheduler.Bucket.Reschedule(Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration)">
            <summary>
            Slot a repeating task into the "reschedule" linked list.
            </summary>
            <param name="reg">The registration scheduled for repeating</param>
        </member>
        <member name="M:Akka.Actor.HashedWheelTimerScheduler.Bucket.ClearRegistrations(System.Collections.Generic.HashSet{Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration})">
            <summary>
            Empty this bucket
            </summary>
            <param name="registrations">A set of registrations to populate.</param>
        </member>
        <member name="M:Akka.Actor.HashedWheelTimerScheduler.Bucket.ClearReschedule(System.Collections.Generic.HashSet{Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration})">
            <summary>
            Reset the reschedule list for this bucket
            </summary>
            <param name="registrations">A set of registrations to populate.</param>
        </member>
        <member name="M:Akka.Actor.HashedWheelTimerScheduler.Bucket.Execute(System.Int64)">
            <summary>
            Execute all <see cref="T:Akka.Actor.HashedWheelTimerScheduler.SchedulerRegistration"/>s that are due by or after <paramref name="deadline"/>.
            </summary>
            <param name="deadline">The execution time.</param>
        </member>
        <member name="T:Akka.Actor.IActionScheduler">
            <summary>
            A scheduler able of scheduling actions
            </summary>
        </member>
        <member name="M:Akka.Actor.IActionScheduler.ScheduleOnce(System.TimeSpan,System.Action,Akka.Actor.ICancelable)">
            <summary>
            Schedules an action to be invoked after an delay.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor.
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="delay">The time period that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <param name="cancelable">A cancelable that can be used to cancel the action from being executed</param>
        </member>
        <member name="M:Akka.Actor.IActionScheduler.ScheduleOnce(System.TimeSpan,System.Action)">
            <summary>
            Schedules an action to be invoked after an delay.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor.
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="delay">The time period that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Akka.Actor.IActionScheduler.ScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action,Akka.Actor.ICancelable)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="initialDelay">The time period that has to pass before first invocation.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <param name="cancelable">A cancelable that can be used to cancel the action from being executed</param>
        </member>
        <member name="M:Akka.Actor.IActionScheduler.ScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="initialDelay">The time period that has to pass before first invocation.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between the action is invoked.</param>
            <param name="action">The action to perform.</param>
        </member>
        <member name="T:Akka.Actor.IAdvancedScheduler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.IDateTimeOffsetNowTimeProvider">
            <summary>
            Marks that an <see cref="T:Akka.Actor.ITimeProvider"/> uses <see cref="P:System.DateTimeOffset.UtcNow"/>, 
            i.e. system time, to provide <see cref="P:Akka.Actor.ITimeProvider.Now"/>.
            </summary>
        </member>
        <member name="T:Akka.Actor.IScheduler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.IScheduler.Advanced">
            <summary>
            Gets the advanced scheduler which will allow you to schedule actions. 
            <remarks>Note! It's considered bad practice to use concurrency inside actors and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
        </member>
        <member name="T:Akka.Actor.ITellScheduler">
            <summary>
            A scheduler that's able to schedule sending messages.
            </summary>
        </member>
        <member name="M:Akka.Actor.ITellScheduler.ScheduleTellOnce(System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="delay">The time period that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
        </member>
        <member name="M:Akka.Actor.ITellScheduler.ScheduleTellOnce(System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="delay">The time period that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="cancelable">An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message has been sent, it cannot be canceled.</param>
        </member>
        <member name="M:Akka.Actor.ITellScheduler.ScheduleTellRepeatedly(System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="initialDelay">The time period that has to pass before the first message is sent.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between messages are being sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
        </member>
        <member name="M:Akka.Actor.ITellScheduler.ScheduleTellRepeatedly(System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="initialDelay">The time period that has to pass before the first message is sent.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between messages are being sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="cancelable">An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message has been sent, it cannot be canceled.</param>
        </member>
        <member name="T:Akka.Actor.ITimeProvider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ITimeProvider.Now">
            <summary>
            Gets the scheduler's notion of current time.
            </summary>
        </member>
        <member name="P:Akka.Actor.ITimeProvider.MonotonicClock">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.ITimeProvider.HighResMonotonicClock">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.SchedulerBase">
            <summary>
            Abstract base class for implementing any custom <see cref="T:Akka.Actor.IScheduler"/> implementation used by Akka.NET.
            
            All constructed schedulers are expected to support the <see cref="T:Akka.Configuration.Config"/> and <see cref="T:Akka.Event.ILoggingAdapter"/> arguments
            provided on the default constructor for this class.
            </summary>
        </member>
        <member name="F:Akka.Actor.SchedulerBase.SchedulerConfig">
            <summary>
            The configuration section for a specific <see cref="T:Akka.Actor.IScheduler"/> implementation.
            </summary>
        </member>
        <member name="F:Akka.Actor.SchedulerBase.Log">
            <summary>
            The <see cref="T:Akka.Event.ILoggingAdapter"/> provided by the <see cref="T:Akka.Actor.ActorSystem"/> at startup.
            </summary>
        </member>
        <member name="M:Akka.Actor.SchedulerBase.#ctor(Akka.Configuration.Config,Akka.Event.ILoggingAdapter)">
            <summary>
            TBD
            </summary>
            <param name="scheduler">TBD</param>
            <param name="log">TBD</param>
        </member>
        <member name="P:Akka.Actor.SchedulerBase.TimeNow">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.SchedulerBase.MonotonicClock">
            <summary>
            The current time since startup, as determined by the monotonic clock implementation.
            </summary>
            <remarks>
            Typically uses <see cref="P:Akka.Actor.SchedulerBase.MonotonicClock"/> in most implementations, but in some cases a 
            custom implementation is used - such as when we need to do virtual time scheduling in the Akka.TestKit.
            </remarks>
        </member>
        <member name="P:Akka.Actor.SchedulerBase.HighResMonotonicClock">
            <summary>
            The current time since startup, as determined by the high resolution monotonic clock implementation.
            </summary>
            <remarks>
            Typically uses <see cref="P:Akka.Actor.SchedulerBase.MonotonicClock"/> in most implementations, but in some cases a 
            custom implementation is used - such as when we need to do virtual time scheduling in the Akka.TestKit.
            </remarks>
        </member>
        <member name="M:Akka.Actor.SchedulerBase.InternalScheduleTellOnce(System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>
            TBD
            </summary>
            <param name="delay">TBD</param>
            <param name="receiver">TBD</param>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
            <param name="cancelable">TBD</param>
        </member>
        <member name="M:Akka.Actor.SchedulerBase.InternalScheduleTellRepeatedly(System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>
            TBD
            </summary>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
            <param name="receiver">TBD</param>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
            <param name="cancelable">TBD</param>
        </member>
        <member name="M:Akka.Actor.SchedulerBase.InternalScheduleOnce(System.TimeSpan,System.Action,Akka.Actor.ICancelable)">
            <summary>
            TBD
            </summary>
            <param name="delay">TBD</param>
            <param name="action">TBD</param>
            <param name="cancelable">TBD</param>
        </member>
        <member name="M:Akka.Actor.SchedulerBase.InternalScheduleRepeatedly(System.TimeSpan,System.TimeSpan,System.Action,Akka.Actor.ICancelable)">
            <summary>
            TBD
            </summary>
            <param name="initialDelay">TBD</param>
            <param name="interval">TBD</param>
            <param name="action">TBD</param>
            <param name="cancelable">TBD</param>
        </member>
        <member name="M:Akka.Actor.SchedulerBase.ValidateInterval(System.TimeSpan,System.String)">
            <summary>
            TBD
            </summary>
            <param name="interval">TBD</param>
            <param name="parameterName">TBD</param>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if the given <paramref name="interval"/> is negative or zero.</exception>
        </member>
        <member name="M:Akka.Actor.SchedulerBase.ValidateDelay(System.TimeSpan,System.String)">
            <summary>
            TBD
            </summary>
            <param name="delay">TBD</param>
            <param name="parameterName">TBD</param>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if the given <paramref name="delay"/> is negative.</exception>
        </member>
        <member name="T:Akka.Actor.SchedulerException">
            <summary>
            An <see cref="T:Akka.Actor.AkkaException"/> that is thrown by the <see cref="!:IScheduler.Schedule*"/> methods
            when scheduling is not possible, e.g. after shutting down the <see cref="T:Akka.Actor.IScheduler"/>.
            </summary>
        </member>
        <member name="M:Akka.Actor.SchedulerException.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="T:Akka.Actor.SchedulerExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellOnce(Akka.Actor.ITellScheduler,System.Int32,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="millisecondsDelay">The time in milliseconds that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="cancelable">OPTIONAL. An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Note that once the message has been sent, it cannot be canceled.</param>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellRepeatedly(Akka.Actor.ITellScheduler,System.Int32,System.Int32,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef,Akka.Actor.ICancelable)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialMillisecondsDelay">The time in milliseconds that has to pass before the first message is sent.</param>
            <param name="millisecondsInterval">The interval, i.e. the time in milliseconds that has to pass between messages are being sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <param name="cancelable">OPTIONAL. An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Note that once the message has been sent, it cannot be canceled.</param>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleOnce(Akka.Actor.IActionScheduler,System.Int32,System.Action,Akka.Actor.ICancelable)">
            <summary>
            Schedules an action to be invoked after an delay.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor.
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="millisecondsDelay">The time in milliseconds that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <param name="cancelable">OPTIONAL. A cancelable that can be used to cancel the action from being executed. Defaults to <c>null</c></param>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleRepeatedly(Akka.Actor.IActionScheduler,System.Int32,System.Int32,System.Action,Akka.Actor.ICancelable)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            The action will be wrapped so that it completes inside the currently active actor if it is called from within an actor
            <remarks>Note! It's considered bad practice to use concurrency inside actors, and very easy to get wrong so usage is discouraged.</remarks>
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialMillisecondsDelay">The time in milliseconds that has to pass before first invocation.</param>
            <param name="millisecondsInterval">The interval, i.e. the time in milliseconds that has to pass before the action is invoked again.</param>
            <param name="action">The action to perform.</param>
            <param name="cancelable">OPTIONAL. A cancelable that can be used to cancel the action from being executed. Defaults to <c>null</c></param>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellOnceCancelable(Akka.Actor.IScheduler,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="delay">The time period that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <returns>An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message already has been sent, it cannot be cancelled.</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellOnceCancelable(Akka.Actor.IScheduler,System.Int32,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message once after a specified period of time.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="millisecondsDelay">The time in milliseconds that has to pass before the message is sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <returns>An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message already has been sent, it cannot be cancelled.</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellRepeatedlyCancelable(Akka.Actor.IScheduler,System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialDelay">The time period that has to pass before the first message is sent.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between messages are being sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <returns>An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message already has been sent, it cannot be cancelled.</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleTellRepeatedlyCancelable(Akka.Actor.IScheduler,System.Int32,System.Int32,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
            <summary>Schedules to send a message repeatedly. The first message will be sent after the specified initial delay and there after at the rate specified.</summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialMillisecondsDelay">The time in milliseconds that has to pass before the first message is sent.</param>
            <param name="millisecondsInterval">The interval, i.e. the time in milliseconds that has to pass between messages are sent.</param>
            <param name="receiver">The receiver.</param>
            <param name="message">The message.</param>
            <param name="sender">The sender.</param>
            <returns>An <see cref="T:Akka.Actor.ICancelable"/> that can be used to cancel sending of the message. Once the message already has been sent, it cannot be cancelled.</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleOnceCancelable(Akka.Actor.IActionScheduler,System.TimeSpan,System.Action)">
            <summary>
            Schedules an action to be invoked after an delay.
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="delay">The time period that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <returns>A cancelable that can be used to cancel the action from being executed</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleOnceCancelable(Akka.Actor.IActionScheduler,System.Int32,System.Action)">
            <summary>
            Schedules an action to be invoked after an delay.
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="millisecondsDelay">The time in milliseconds that has to pass before the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <returns>A cancelable that can be used to cancel the action from being executed</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleRepeatedlyCancelable(Akka.Actor.IActionScheduler,System.TimeSpan,System.TimeSpan,System.Action)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialDelay">The time period that has to pass before first invocation.</param>
            <param name="interval">The interval, i.e. the time period that has to pass between the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <returns>A cancelable that can be used to cancel the action from being executed</returns>
        </member>
        <member name="M:Akka.Actor.SchedulerExtensions.ScheduleRepeatedlyCancelable(Akka.Actor.IActionScheduler,System.Int32,System.Int32,System.Action)">
            <summary>
            Schedules an action to be invoked after an initial delay and then repeatedly.
            </summary>
            <param name="scheduler">The scheduler</param>
            <param name="initialMillisecondsDelay">The time in milliseconds that has to pass before first invocation.</param>
            <param name="millisecondsInterval">The interval, i.e. the time in milliseconds that has to pass between the action is invoked.</param>
            <param name="action">The action to perform.</param>
            <returns>A cancelable that can be used to cancel the action from being executed</returns>
        </member>
        <member name="T:Akka.Actor.Scope">
            <summary>
            This class provides base functionality when defining a system binding (e.g. local/remote/cluster) used during actor deployment.
            </summary>
        </member>
        <member name="F:Akka.Actor.Scope.Local">
            <summary>
            A binding that binds actor deployments to the local system.
            </summary>
        </member>
        <member name="M:Akka.Actor.Scope.WithFallback(Akka.Actor.Scope)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Scope" /> from this scope using another <see cref="T:Akka.Actor.Scope" />
            to backfill options that might be missing from this scope.
            
            <note>
            This method is immutable and returns a new instance of <see cref="T:Akka.Actor.Scope" />.
            </note>
            </summary>
            <param name="other">The <see cref="T:Akka.Actor.Scope" /> used for fallback configuration.</param>
            <returns>A new <see cref="T:Akka.Actor.Scope" /> using <paramref name="other" /> for fallback configuration.</returns>
        </member>
        <member name="M:Akka.Actor.Scope.Copy">
            <summary>
            Creates a copy of the current instance.
            </summary>
            <returns>The newly created <see cref="T:Akka.Actor.Scope"/></returns>
        </member>
        <member name="M:Akka.Actor.Scope.Equals(Akka.Actor.Scope)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            <c>true</c> if the current object is equal to the <paramref name="other" /> parameter; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:Akka.Actor.NoScopeGiven">
            <summary>
            This class represents a binding of an actor deployment to an unspecified system.
            </summary>
        </member>
        <member name="P:Akka.Actor.NoScopeGiven.Instance">
            <summary>
            The singleton instance of this scope.
            </summary>
        </member>
        <member name="M:Akka.Actor.NoScopeGiven.WithFallback(Akka.Actor.Scope)">
            <summary>
            Creates a new <see cref="T:Akka.Actor.Scope" /> from this scope using another <see cref="T:Akka.Actor.Scope" />
            to backfill options that might be missing from this scope.
            
            <note>
            This method returns the given scope unaltered.
            </note>
            </summary>
            <param name="other">The <see cref="T:Akka.Actor.Scope" /> used for fallback configuration.</param>
            <returns>The scope passed in as the parameter.</returns>
        </member>
        <member name="M:Akka.Actor.NoScopeGiven.Copy">
             <summary>
             Creates a copy of the current instance.
            
             <note>
             This method returns a singleton instance of this scope.
             </note>
             </summary>
             <returns>The singleton instance of this scope</returns>
        </member>
        <member name="T:Akka.Actor.Settings">
            <summary>
                Settings are the overall ActorSystem Settings which also provides a convenient access to the Config object.
                For more detailed information about the different possible configuration options, look in the Akka .NET
                Documentation under "Configuration"
            </summary>
        </member>
        <member name="M:Akka.Actor.Settings.RebuildConfig">
            <summary>
            Combines the user config and the fallback chain of configs
            </summary>
        </member>
        <member name="M:Akka.Actor.Settings.InjectTopLevelFallback(Akka.Configuration.Config)">
            <summary>
            Injects a system config at the top of the fallback chain
            </summary>
            <param name="config">TBD</param>
        </member>
        <member name="M:Akka.Actor.Settings.#ctor(Akka.Actor.ActorSystem,Akka.Configuration.Config)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Settings" /> class.
            </summary>
            <param name="system">The system.</param>
            <param name="config">The configuration.</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown if the 'akka.actor.provider' configuration item is not a valid type name or a valid actor ref provider.
            </exception>
        </member>
        <member name="P:Akka.Actor.Settings.System">
            <summary>
                Gets the system.
            </summary>
            <value>The system.</value>
        </member>
        <member name="P:Akka.Actor.Settings.Config">
            <summary>
                Gets the configuration.
            </summary>
            <value>The configuration.</value>
        </member>
        <member name="P:Akka.Actor.Settings.ConfigVersion">
            <summary>
                Gets the configuration version.
            </summary>
            <value>The configuration version.</value>
        </member>
        <member name="P:Akka.Actor.Settings.ProviderClass">
            <summary>
                Gets the provider class.
            </summary>
            <value>The provider class.</value>
        </member>
        <member name="P:Akka.Actor.Settings.SupervisorStrategyClass">
            <summary>
                Gets the supervisor strategy class.
            </summary>
            <value>The supervisor strategy class.</value>
        </member>
        <member name="P:Akka.Actor.Settings.SerializeAllMessages">
            <summary>
                Gets a value indicating whether [serialize all messages].
            </summary>
            <value><c>true</c> if [serialize all messages]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.SerializeAllCreators">
            <summary>
                Gets a value indicating whether [serialize all creators].
            </summary>
            <value><c>true</c> if [serialize all creators]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.AskTimeout">
            <summary>
                Gets the default timeout for <see cref="M:Akka.Actor.Futures.Ask(Akka.Actor.ICanTell,System.Object,System.Nullable{System.TimeSpan})" /> calls.
            </summary>
            <value>The ask timeout.</value>
        </member>
        <member name="P:Akka.Actor.Settings.CreationTimeout">
            <summary>
                Gets the creation timeout.
            </summary>
            <value>The creation timeout.</value>
        </member>
        <member name="P:Akka.Actor.Settings.UnstartedPushTimeout">
            <summary>
                Gets the unstarted push timeout.
            </summary>
            <value>The unstarted push timeout.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LogLevel">
            <summary>
                Gets the log level.
            </summary>
            <value>The log level.</value>
        </member>
        <member name="P:Akka.Actor.Settings.StdoutLogLevel">
            <summary>
                Gets the stdout log level.
            </summary>
            <value>The stdout log level.</value>
        </member>
        <member name="P:Akka.Actor.Settings.Loggers">
            <summary>
                Gets the loggers.
            </summary>
            <value>The loggers.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LoggersDispatcher">
            <summary>
                Gets the default loggers dispatcher.
            </summary>
            <value>The loggers dispatcher.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LoggerStartTimeout">
            <summary>
                Gets the logger start timeout.
            </summary>
            <value>The logger start timeout.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LogConfigOnStart">
            <summary>
                Gets a value indicating whether [log configuration on start].
            </summary>
            <value><c>true</c> if [log configuration on start]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LogDeadLetters">
            <summary>
                Gets the log dead letters.
            </summary>
            <value>The log dead letters.</value>
        </member>
        <member name="P:Akka.Actor.Settings.LogDeadLettersDuringShutdown">
            <summary>
                Gets a value indicating whether [log dead letters during shutdown].
            </summary>
            <value><c>true</c> if [log dead letters during shutdown]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.AddLoggingReceive">
            <summary>
                Gets a value indicating whether [add logging receive].
            </summary>
            <value><c>true</c> if [add logging receive]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugAutoReceive">
            <summary>
                Gets a value indicating whether [debug automatic receive].
            </summary>
            <value><c>true</c> if [debug automatic receive]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugEventStream">
            <summary>
                Gets a value indicating whether [debug event stream].
            </summary>
            <value><c>true</c> if [debug event stream]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugUnhandledMessage">
            <summary>
                Gets a value indicating whether [debug unhandled message].
            </summary>
            <value><c>true</c> if [debug unhandled message]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugRouterMisconfiguration">
            <summary>
                Gets a value indicating whether [debug router misconfiguration].
            </summary>
            <value><c>true</c> if [debug router misconfiguration]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.Home">
            <summary>
                Gets the home.
            </summary>
            <value>The home.</value>
        </member>
        <member name="P:Akka.Actor.Settings.DebugLifecycle">
            <summary>
                Gets a value indicating whether [debug lifecycle].
            </summary>
            <value><c>true</c> if [debug lifecycle]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Actor.Settings.FsmDebugEvent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.Settings.DefaultVirtualNodesFactor">
            <summary>
            The number of default virtual nodes to use with <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/>.
            </summary>
        </member>
        <member name="P:Akka.Actor.Settings.SchedulerClass">
            <summary>
            Gets the scheduler implementation used by this system.
            </summary>
        </member>
        <member name="P:Akka.Actor.Settings.SchedulerShutdownTimeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Settings.ToString">
            <summary>
                Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Actor.IActorStash">
            <summary>
            Marker interface for adding stash support
            </summary>
        </member>
        <member name="P:Akka.Actor.IActorStash.Stash">
            <summary>
            Gets or sets the stash. This will be automatically populated by the framework AFTER the constructor has been run.
            Implement this as an auto property.
            </summary>
            <value>
            The stash.
            </value>
        </member>
        <member name="T:Akka.Actor.ActorStashPlugin">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.ActorStashPlugin.CanBeAppliedTo(System.Type)">
            <summary>
            Stash plugin is applied to all actors implementing <see cref="T:Akka.Actor.IActorStash"/> interface.
            </summary>
            <param name="actorType">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.ActorStashPlugin.AfterIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Creates a new stash for specified <paramref name="actor"/> if it has not been initialized already.
            </summary>
            <param name="actor">TBD</param>
            <param name="context">TBD</param>
        </member>
        <member name="M:Akka.Actor.ActorStashPlugin.BeforeIncarnated(Akka.Actor.ActorBase,Akka.Actor.IActorContext)">
            <summary>
            Ensures, that all stashed messages inside <paramref name="actor"/> stash have been unstashed.
            </summary>
            <param name="actor">TBD</param>
            <param name="context">TBD</param>
        </member>
        <member name="T:Akka.Actor.IStash">
            <summary>
            Public interface used to expose stash capabilities to user-level actors
            </summary>
        </member>
        <member name="M:Akka.Actor.IStash.Stash">
            <summary>
            Stashes the current message (the message that the actor received last)
            </summary>
        </member>
        <member name="M:Akka.Actor.IStash.Unstash">
            <summary>
            Unstash the oldest message in the stash and prepends it to the actor's mailbox.
            The message is removed from the stash.
            </summary>
        </member>
        <member name="M:Akka.Actor.IStash.UnstashAll">
            <summary>
            Unstashes all messages by prepending them to the actor's mailbox.
            The stash is guaranteed to be empty afterwards.
            </summary>
        </member>
        <member name="M:Akka.Actor.IStash.UnstashAll(System.Func{Akka.Actor.Envelope,System.Boolean})">
            <summary>
            Unstashes all messages selected by the predicate function. Other messages are discarded.
            The stash is guaranteed to be empty afterwards.
            </summary>
            <param name="predicate">TBD</param>
        </member>
        <member name="M:Akka.Actor.IStash.ClearStash">
            <summary>
            Returns all messages and clears the stash.
            The stash is guaranteed to be empty afterwards.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.IStash.Prepend(System.Collections.Generic.IEnumerable{Akka.Actor.Envelope})">
            <summary>
            TBD
            </summary>
            <param name="envelopes">TBD</param>
        </member>
        <member name="T:Akka.Actor.IWithBoundedStash">
            <summary>
            Lets the <see cref="T:Akka.Actor.StashFactory"/> know that this Actor needs stash support
            with restricted storage capacity
            You need to add the property:
            <code>public IStash Stash { get; set; }</code>
            </summary>
        </member>
        <member name="T:Akka.Actor.IWithUnboundedStash">
            <summary>
            Lets the <see cref="T:Akka.Actor.StashFactory"/> know that this Actor needs stash support
            with unrestricted storage capacity.
            You need to add the property:
            <code>public IStash Stash { get; set; }</code>
            </summary>
        </member>
        <member name="T:Akka.Actor.StashFactory">
            <summary>
            Static factor used for creating Stash instances
            </summary>
        </member>
        <member name="M:Akka.Actor.StashFactory.CreateStash``1(Akka.Actor.IActorContext)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.StashFactory.CreateStash(Akka.Actor.IActorContext,Akka.Actor.IActorStash)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="actorInstance">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.StashFactory.CreateStash(Akka.Actor.IActorContext,System.Type)">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="actorType">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the given <paramref name="actorType"/> implements an unrecognized subclass of <see cref="T:Akka.Actor.IActorStash"/>.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.StashOverflowException">
            <summary>
            This exception is thrown when the size of the Stash exceeds the capacity of the stash.
            </summary>
        </member>
        <member name="M:Akka.Actor.StashOverflowException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.StashOverflowException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="cause">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Actor.StashOverflowException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Actor.StashOverflowException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Actor.SupervisorStrategy">
            <summary>
                Base class for supervision strategies
            </summary>
        </member>
        <member name="P:Akka.Actor.SupervisorStrategy.Decider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.Handle(Akka.Actor.IActorRef,System.Exception)">
            <summary>
                Handles the specified child.
            </summary>
            <param name="child">The actor that caused the evaluation to occur</param>
            <param name="x">The exception that caused the evaluation to occur.</param>
            <returns>Directive.</returns>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.HandleFailure(Akka.Actor.ActorCell,System.Exception,Akka.Actor.Internal.ChildRestartStats,System.Collections.Generic.IReadOnlyCollection{Akka.Actor.Internal.ChildRestartStats})">
            <summary>
            TBD
            </summary>
            <param name="actorCell">TBD</param>
            <param name="cause">TBD</param>
            <param name="failedChildStats">TBD</param>
            <param name="allChildren">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.HandleFailure(Akka.Actor.ActorCell,Akka.Actor.IActorRef,System.Exception,Akka.Actor.Internal.ChildRestartStats,System.Collections.Generic.IReadOnlyCollection{Akka.Actor.Internal.ChildRestartStats})">
            <summary>
                This is the main entry point: in case of a childs failure, this method
                must try to handle the failure by resuming, restarting or stopping the
                child (and returning `true`), or it returns `false` to escalate the
                failure, which will lead to this actor re-throwing the exception which
                caused the failure. The exception will not be wrapped.
                This method calls <see cref="T:Akka.Actor.SupervisorStrategy"/>, which will
                log the failure unless it is escalated. You can customize the logging by
                setting <see cref="T:Akka.Actor.SupervisorStrategy" /> to `false` and
                do the logging inside the `decider` or override the `LogFailure` method.
            </summary>
            <param name="actorCell">The actor cell.</param>
            <param name="child">The child actor.</param>
            <param name="cause">The cause.</param>
            <param name="stats">The stats for the failed child.</param>
            <param name="children">TBD</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="F:Akka.Actor.SupervisorStrategy.DefaultDecider">
            <summary>
                When supervisorStrategy is not specified for an actor this
                Decider is used by default in the supervisor strategy.
                The child will be stopped when <see cref="T:Akka.Actor.ActorInitializationException"/>,
                <see cref="T:Akka.Actor.ActorKilledException"/>, or <see cref="T:Akka.Actor.DeathPactException"/> is
                thrown. It will be restarted for other `Exception` types.
                The error is escalated if it's a `Exception`, i.e. `Error`.
            </summary>
            <returns>Directive.</returns>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.RestartChild(Akka.Actor.IActorRef,System.Exception,System.Boolean)">
            <summary>
                Restarts the child.
            </summary>
            <param name="child">The child.</param>
            <param name="cause">The cause.</param>
            <param name="suspendFirst">if set to <c>true</c> [suspend first].</param>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.ProcessFailure(Akka.Actor.IActorContext,System.Boolean,System.Exception,Akka.Actor.Internal.ChildRestartStats,System.Collections.Generic.IReadOnlyCollection{Akka.Actor.Internal.ChildRestartStats})">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="restart">TBD</param>
            <param name="cause">TBD</param>
            <param name="failedChildStats">TBD</param>
            <param name="allChildren">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.ProcessFailure(Akka.Actor.IActorContext,System.Boolean,Akka.Actor.IActorRef,System.Exception,Akka.Actor.Internal.ChildRestartStats,System.Collections.Generic.IReadOnlyCollection{Akka.Actor.Internal.ChildRestartStats})">
            <summary>
            This method is called to act on the failure of a child: restart if the flag is true, stop otherwise.
            </summary>
            <param name="context">The actor context.</param>
            <param name="restart">if set to <c>true</c> restart, stop otherwise.</param>
            <param name="child">The child actor</param>
            <param name="cause">The exception that caused the child to fail.</param>
            <param name="stats">The stats for the child that failed. The ActorRef to the child can be obtained via the <see cref="P:Akka.Actor.Internal.ChildRestartStats.Child"/> property</param>
            <param name="children">The stats for all children</param>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.ResumeChild(Akka.Actor.IActorRef,System.Exception)">
            <summary>
             Resume the previously failed child: <b>do never apply this to a child which
             is not the currently failing child</b>. Suspend/resume needs to be done in
             matching pairs, otherwise actors will wake up too soon or never at all.
            </summary>
            <param name="child">The child.</param>
            <param name="exception">The exception.</param>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.LogFailure(Akka.Actor.IActorContext,Akka.Actor.IActorRef,System.Exception,Akka.Actor.Directive)">
            <summary>
                Logs the failure.
            </summary>
            <param name="context">The actor cell.</param>
            <param name="child">The child.</param>
            <param name="cause">The cause.</param>
            <param name="directive">The directive.</param>
        </member>
        <member name="P:Akka.Actor.SupervisorStrategy.LoggingEnabled">
            <summary>
            Determines if failures are logged
            </summary>
        </member>
        <member name="F:Akka.Actor.SupervisorStrategy.DefaultStrategy">
            <summary>
                When supervisorStrategy is not specified for an actor this
                is used by default. OneForOneStrategy with decider defined in
                <see cref="F:Akka.Actor.SupervisorStrategy.DefaultDecider" />.
            </summary>
            <value>The default.</value>
        </member>
        <member name="F:Akka.Actor.SupervisorStrategy.StoppingStrategy">
            <summary>
                This strategy resembles Erlang in that failing children are always
                terminated (one-for-one).
            </summary>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.HandleChildTerminated(Akka.Actor.IActorContext,Akka.Actor.IActorRef,System.Collections.Generic.IEnumerable{Akka.Actor.IInternalActorRef})">
            <summary>
            This method is called after the child has been removed from the set of children.
            It does not need to do anything special. Exceptions thrown from this method
            do NOT make the actor fail if this happens during termination.
            </summary>
            <param name="actorContext">TBD</param>
            <param name="child">TBD</param>
            <param name="children">TBD</param>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategy.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Actor.SupervisorStrategy"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Actor.SupervisorStrategy"/>.</returns>
        </member>
        <member name="T:Akka.Actor.OneForOneStrategy">
            <summary>
                Class OneForOneStrategy. This class cannot be inherited.
             The result of this strategy is applied only to the failing child
            </summary>
        </member>
        <member name="P:Akka.Actor.OneForOneStrategy.MaxNumberOfRetries">
            <summary>
            The number of times a child actor is allowed to be restarted, negative value means no limit,
            if the limit is exceeded the child actor is stopped.
            </summary>
        </member>
        <member name="P:Akka.Actor.OneForOneStrategy.WithinTimeRangeMilliseconds">
            <summary>
            The duration in milliseconds of the time window for <see cref="P:Akka.Actor.OneForOneStrategy.MaxNumberOfRetries"/>, negative values means no window.
            </summary>
        </member>
        <member name="P:Akka.Actor.OneForOneStrategy.Decider">
            <summary>
            The mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/>
            </summary>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Nullable{System.Int32},System.Nullable{System.TimeSpan},System.Func{System.Exception,Akka.Actor.Directive})">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                only to the child that failed, as opposed to <see cref="T:Akka.Actor.AllForOneStrategy" /> that applies
                it to all children when one failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeRange">duration of the time window for maxNrOfRetries, System.Threading.Timeout.InfiniteTimeSpan means no window.</param>
            <param name="localOnlyDecider">mapping from Exception to <see cref="T:Akka.Actor.Directive" /></param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Nullable{System.Int32},System.Nullable{System.TimeSpan},Akka.Actor.IDecider)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                only to the child that failed, as opposed to <see cref="T:Akka.Actor.AllForOneStrategy" /> that applies
                it to all children when one failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeRange">duration of the time window for maxNrOfRetries, System.Threading.Timeout.InfiniteTimeSpan means no window.</param>
            <param name="decider">mapping from Exception to <see cref="T:Akka.Actor.Directive" /></param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Int32,System.Int32,System.Func{System.Exception,Akka.Actor.Directive},System.Boolean)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                only to the child that failed, as opposed to <see cref="T:Akka.Actor.AllForOneStrategy" /> that applies
                it to all children when one failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeMilliseconds">duration in milliseconds of the time window for <paramref name="maxNrOfRetries"/>, negative values means no window.</param>
            <param name="localOnlyDecider">Mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/></param>
            <param name="loggingEnabled">If <c>true</c> failures will be logged</param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Int32,System.Int32,Akka.Actor.IDecider,System.Boolean)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                only to the child that failed, as opposed to <see cref="T:Akka.Actor.AllForOneStrategy" /> that applies
                it to all children when one failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeMilliseconds">duration in milliseconds of the time window for <paramref name="maxNrOfRetries"/>, negative values means no window.</param>
            <param name="decider">Mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/></param>
            <param name="loggingEnabled">If <c>true</c> failures will be logged</param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Func{System.Exception,Akka.Actor.Directive})">
            <summary>
            Constructor that accepts only a decider and uses reasonable defaults for the other settings
            </summary>
            <param name="localOnlyDecider">mapping from Exception to <see cref="T:Akka.Actor.Directive" /></param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(System.Func{System.Exception,Akka.Actor.Directive},System.Boolean)">
            <summary>
            Constructor that accepts only a decider and uses reasonable defaults for the other settings
            </summary>
            <param name="localOnlyDecider">mapping from Exception to <see cref="T:Akka.Actor.Directive" /></param>
            <param name="loggingEnabled">If <c>true</c> failures will be logged</param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor(Akka.Actor.IDecider)">
            <summary>
            Constructor that accepts only a decider and uses reasonable defaults for the other settings
            </summary>
            <param name="decider">TBD</param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.#ctor">
            <summary>
            Serialization-friendly constructor
            </summary>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.Handle(Akka.Actor.IActorRef,System.Exception)">
            <summary>
                Handles the specified child.
            </summary>
            <param name="child">The child.</param>
            <param name="x">The x.</param>
            <returns>Directive.</returns>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.ProcessFailure(Akka.Actor.IActorContext,System.Boolean,System.Exception,Akka.Actor.Internal.ChildRestartStats,System.Collections.Generic.IReadOnlyCollection{Akka.Actor.Internal.ChildRestartStats})">
            <summary>
            Obsolete. Use <see cref="M:Akka.Actor.OneForOneStrategy.ProcessFailure(Akka.Actor.IActorContext,System.Boolean,Akka.Actor.IActorRef,System.Exception,Akka.Actor.Internal.ChildRestartStats,System.Collections.Generic.IReadOnlyCollection{Akka.Actor.Internal.ChildRestartStats})"/> instead.
            </summary>
            <param name="context">N/A</param>
            <param name="restart">N/A</param>
            <param name="cause">N/A</param>
            <param name="failedChildStats">N/A</param>
            <param name="allChildren">N/A</param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.ProcessFailure(Akka.Actor.IActorContext,System.Boolean,Akka.Actor.IActorRef,System.Exception,Akka.Actor.Internal.ChildRestartStats,System.Collections.Generic.IReadOnlyCollection{Akka.Actor.Internal.ChildRestartStats})">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="restart">TBD</param>
            <param name="child">TBD</param>
            <param name="cause">TBD</param>
            <param name="stats">TBD</param>
            <param name="children">TBD</param>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.HandleChildTerminated(Akka.Actor.IActorContext,Akka.Actor.IActorRef,System.Collections.Generic.IEnumerable{Akka.Actor.IInternalActorRef})">
            <summary>
            TBD
            </summary>
            <param name="actorContext">TBD</param>
            <param name="child">TBD</param>
            <param name="children">TBD</param>
        </member>
        <member name="T:Akka.Actor.OneForOneStrategy.OneForOneStrategySurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Actor.OneForOneStrategy"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="P:Akka.Actor.OneForOneStrategy.OneForOneStrategySurrogate.MaxNumberOfRetries">
            <summary>
            The number of times a child actor is allowed to be restarted, negative value means no limit,
            if the limit is exceeded the child actor is stopped.
            </summary>
        </member>
        <member name="P:Akka.Actor.OneForOneStrategy.OneForOneStrategySurrogate.WithinTimeRangeMilliseconds">
            <summary>
            The duration in milliseconds of the time window for <see cref="P:Akka.Actor.OneForOneStrategy.OneForOneStrategySurrogate.MaxNumberOfRetries"/>, negative values means no window.
            </summary>
        </member>
        <member name="P:Akka.Actor.OneForOneStrategy.OneForOneStrategySurrogate.Decider">
            <summary>
            The mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/>
            </summary>
        </member>
        <member name="P:Akka.Actor.OneForOneStrategy.OneForOneStrategySurrogate.LoggingEnabled">
            <summary>
            Determines if failures are logged
            </summary>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.OneForOneStrategySurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Actor.OneForOneStrategy"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Actor.OneForOneStrategy"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Actor.OneForOneStrategy"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <exception cref="T:System.NotSupportedException">This exception is thrown if the <see cref="P:Akka.Actor.OneForOneStrategy.Decider"/> is of type <see cref="T:Akka.Actor.LocalOnlyDecider"/>.</exception>
            <returns>The surrogate representation of the current <see cref="T:Akka.Actor.OneForOneStrategy"/>.</returns>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.Equals(Akka.Actor.OneForOneStrategy)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.OneForOneStrategy.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.AllForOneStrategy">
            <summary>
                Class AllForOneStrategy. This class cannot be inherited.
            The result of this strategy is applied to the failed child and all its siblings.
            </summary>
        </member>
        <member name="P:Akka.Actor.AllForOneStrategy.MaxNumberOfRetries">
            <summary>
            The number of times a child actor is allowed to be restarted, negative value means no limit,
            if the limit is exceeded the child actor is stopped.
            </summary>
        </member>
        <member name="P:Akka.Actor.AllForOneStrategy.WithinTimeRangeMilliseconds">
            <summary>
            The duration in milliseconds of the time window for <see cref="P:Akka.Actor.AllForOneStrategy.MaxNumberOfRetries"/>, negative values means no window.
            </summary>
        </member>
        <member name="P:Akka.Actor.AllForOneStrategy.Decider">
            <summary>
            The mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/>
            </summary>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Nullable{System.Int32},System.Nullable{System.TimeSpan},System.Func{System.Exception,Akka.Actor.Directive})">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.OneForOneStrategy" /> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value and null means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeRange">duration of the time window for maxNrOfRetries, <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> means no window.</param>
            <param name="localOnlyDecider">mapping from Exception to <see cref="T:Akka.Actor.Directive"/></param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Nullable{System.Int32},System.Nullable{System.TimeSpan},Akka.Actor.IDecider)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.OneForOneStrategy" /> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value and null means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeRange">duration of the time window for maxNrOfRetries, <see cref="F:System.Threading.Timeout.InfiniteTimeSpan"/> means no window.</param>
            <param name="decider">mapping from Exception to <see cref="T:Akka.Actor.Directive"/></param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Int32,System.Int32,System.Func{System.Exception,Akka.Actor.Directive},System.Boolean)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.OneForOneStrategy" /> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeMilliseconds">duration in milliseconds of the time window for <paramref name="maxNrOfRetries"/>, negative values means no window.</param>
            <param name="localOnlyDecider">Mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/></param>
            <param name="loggingEnabled">If <c>true</c> failures will be logged</param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Int32,System.Int32,Akka.Actor.IDecider,System.Boolean)">
            <summary>
                Applies the fault handling `Directive` (Resume, Restart, Stop) specified in the `Decider`
                to all children when one fails, as opposed to <see cref="T:Akka.Actor.OneForOneStrategy" /> that applies
                it only to the child actor that failed.
            </summary>
            <param name="maxNrOfRetries">
                the number of times a child actor is allowed to be restarted, negative value means no limit,
                if the limit is exceeded the child actor is stopped.
            </param>
            <param name="withinTimeMilliseconds">duration in milliseconds of the time window for <paramref name="maxNrOfRetries"/>, negative values means no window.</param>
            <param name="decider">Mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/></param>
            <param name="loggingEnabled">If <c>true</c> failures will be logged</param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(System.Func{System.Exception,Akka.Actor.Directive})">
            <summary>
            Constructor that accepts only a decider and uses reasonable defaults for the other settings
            </summary>
            <param name="localOnlyDecider">TBD</param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor(Akka.Actor.IDecider)">
            <summary>
            Constructor that accepts only a decider and uses reasonable defaults for the other settings
            </summary>
            <param name="decider">TBD</param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.#ctor">
            <summary>
            Serialization-friendly constructor
            </summary>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.Handle(Akka.Actor.IActorRef,System.Exception)">
            <summary>
                Determines what to do with the child when the given exception occurs.
            </summary>
            <param name="child">The child.</param>
            <param name="x">The x.</param>
            <returns>Directive.</returns>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.ProcessFailure(Akka.Actor.IActorContext,System.Boolean,System.Exception,Akka.Actor.Internal.ChildRestartStats,System.Collections.Generic.IReadOnlyCollection{Akka.Actor.Internal.ChildRestartStats})">
            <summary>
            Obsolete. Use <see cref="M:Akka.Actor.AllForOneStrategy.ProcessFailure(Akka.Actor.IActorContext,System.Boolean,Akka.Actor.IActorRef,System.Exception,Akka.Actor.Internal.ChildRestartStats,System.Collections.Generic.IReadOnlyCollection{Akka.Actor.Internal.ChildRestartStats})"/> instead.
            </summary>
            <param name="context">N/A</param>
            <param name="restart">N/A</param>
            <param name="cause">N/A</param>
            <param name="failedChildStats">N/A</param>
            <param name="allChildren">N/A</param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.ProcessFailure(Akka.Actor.IActorContext,System.Boolean,Akka.Actor.IActorRef,System.Exception,Akka.Actor.Internal.ChildRestartStats,System.Collections.Generic.IReadOnlyCollection{Akka.Actor.Internal.ChildRestartStats})">
            <summary>
            TBD
            </summary>
            <param name="context">TBD</param>
            <param name="restart">TBD</param>
            <param name="child">TBD</param>
            <param name="cause">TBD</param>
            <param name="stats">TBD</param>
            <param name="children">TBD</param>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.HandleChildTerminated(Akka.Actor.IActorContext,Akka.Actor.IActorRef,System.Collections.Generic.IEnumerable{Akka.Actor.IInternalActorRef})">
            <summary>
            TBD
            </summary>
            <param name="actorContext">TBD</param>
            <param name="child">TBD</param>
            <param name="children">TBD</param>
        </member>
        <member name="T:Akka.Actor.AllForOneStrategy.AllForOneStrategySurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Actor.AllForOneStrategy"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="P:Akka.Actor.AllForOneStrategy.AllForOneStrategySurrogate.MaxNumberOfRetries">
            <summary>
            The number of times a child actor is allowed to be restarted, negative value means no limit,
            if the limit is exceeded the child actor is stopped.
            </summary>
        </member>
        <member name="P:Akka.Actor.AllForOneStrategy.AllForOneStrategySurrogate.WithinTimeRangeMilliseconds">
            <summary>
            The duration in milliseconds of the time window for <see cref="P:Akka.Actor.AllForOneStrategy.AllForOneStrategySurrogate.MaxNumberOfRetries"/>, negative values means no window.
            </summary>
        </member>
        <member name="P:Akka.Actor.AllForOneStrategy.AllForOneStrategySurrogate.Decider">
            <summary>
            The mapping from an <see cref="T:System.Exception"/> to <see cref="T:Akka.Actor.Directive"/>
            </summary>
        </member>
        <member name="P:Akka.Actor.AllForOneStrategy.AllForOneStrategySurrogate.LoggingEnabled">
            <summary>
            Determines if failures are logged
            </summary>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.AllForOneStrategySurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Actor.OneForOneStrategy"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Actor.OneForOneStrategy"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Actor.AllForOneStrategy"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Actor.AllForOneStrategy"/>.</returns>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.Equals(Akka.Actor.AllForOneStrategy)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.AllForOneStrategy.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.Failures">
            <summary>
                Collection of failures, used to keep track of how many times a given actor have failed.
            </summary>
        </member>
        <member name="M:Akka.Actor.Failures.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Actor.Failures" /> class.
            </summary>
        </member>
        <member name="P:Akka.Actor.Failures.Entries">
            <summary>
                Gets the entries.
            </summary>
            <value>The entries.</value>
        </member>
        <member name="T:Akka.Actor.Failure">
            <summary>
                Represents a single failure.
            </summary>
        </member>
        <member name="P:Akka.Actor.Failure.Exception">
            <summary>
                The exception that caused the failure.
            </summary>
            <value>The exception.</value>
        </member>
        <member name="P:Akka.Actor.Failure.Timestamp">
            <summary>
                The timestamp when the failure occurred.
            </summary>
            <value>The timestamp.</value>
        </member>
        <member name="T:Akka.Actor.Directive">
            <summary>
                Enum Directive for supervisor actions
            </summary>
        </member>
        <member name="F:Akka.Actor.Directive.Resume">
            <summary>
                Resumes message processing for the failed Actor
            </summary>
        </member>
        <member name="F:Akka.Actor.Directive.Restart">
            <summary>
                Discards the old Actor instance and replaces it with a new,
                then resumes message processing.
            </summary>
        </member>
        <member name="F:Akka.Actor.Directive.Escalate">
            <summary>
                Escalates the failure to the supervisor of the supervisor,
                by rethrowing the cause of the failure, i.e. the supervisor fails with
                the same exception as the child.
            </summary>
        </member>
        <member name="F:Akka.Actor.Directive.Stop">
            <summary>
                Stops the Actor
            </summary>
        </member>
        <member name="T:Akka.Actor.DirectiveExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.DirectiveExtensions.When``1(Akka.Actor.Directive)">
            <summary>
            TBD
            </summary>
            <typeparam name="TException">TBD</typeparam>
            <param name="self">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.IDecider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.IDecider.Decide(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.Decider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.Decider.From(Akka.Actor.Directive,System.Collections.Generic.KeyValuePair{System.Type,Akka.Actor.Directive}[])">
            <summary>
            TBD
            </summary>
            <param name="defaultDirective">TBD</param>
            <param name="pairs">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Decider.From(Akka.Actor.Directive,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Type,Akka.Actor.Directive}})">
            <summary>
            TBD
            </summary>
            <param name="defaultDirective">TBD</param>
            <param name="pairs">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.Decider.From(System.Func{System.Exception,Akka.Actor.Directive})">
            <summary>
            TBD
            </summary>
            <param name="localOnlyDecider">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.LocalOnlyDecider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.LocalOnlyDecider.#ctor(System.Func{System.Exception,Akka.Actor.Directive})">
            <summary>
            TBD
            </summary>
            <param name="decider">TBD</param>
        </member>
        <member name="M:Akka.Actor.LocalOnlyDecider.Decide(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.DeployableDecider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.DeployableDecider.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.DeployableDecider.#ctor(Akka.Actor.Directive,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.Type,Akka.Actor.Directive}})">
            <summary>
            TBD
            </summary>
            <param name="defaultDirective">TBD</param>
            <param name="pairs">TBD</param>
        </member>
        <member name="M:Akka.Actor.DeployableDecider.#ctor(Akka.Actor.Directive,System.Collections.Generic.KeyValuePair{System.Type,Akka.Actor.Directive}[])">
            <summary>
            TBD
            </summary>
            <param name="defaultDirective">TBD</param>
            <param name="pairs">TBD</param>
        </member>
        <member name="P:Akka.Actor.DeployableDecider.DefaultDirective">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Actor.DeployableDecider.Pairs">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.DeployableDecider.Decide(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.DeployableDecider.Equals(Akka.Actor.DeployableDecider)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.DeployableDecider.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Actor.DeployableDecider.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Actor.SupervisorStrategyConfigurator">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategyConfigurator.Create">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.SupervisorStrategyConfigurator.CreateConfigurator(System.String)">
            <summary>
            TBD
            </summary>
            <param name="typeName">TBD</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown if the given <paramref name="typeName"/> is undefined or references an unknown type.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.DefaultSupervisorStrategy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.DefaultSupervisorStrategy.Create">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.StoppingSupervisorStrategy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Actor.StoppingSupervisorStrategy.Create">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.IHandle`1">
            <summary>
                Interface IHandle
            </summary>
            <typeparam name="TMessage">The type of the t message.</typeparam>
        </member>
        <member name="M:Akka.Actor.IHandle`1.Handle(`0)">
            <summary>
                Handles the specified message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Actor.TypedActor">
            <summary>
                Class TypedActor.
            </summary>
        </member>
        <member name="M:Akka.Actor.TypedActor.Receive(System.Object)">
            <summary>
                Processor for user defined messages.
            </summary>
            <param name="message">The message.</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Actor.UntypedActor">
            <summary>
            Class UntypedActor.
            </summary>
        </member>
        <member name="M:Akka.Actor.UntypedActor.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Actor.UntypedActor.RunTask(System.Action)">
            <summary>
            TBD
            </summary>
            <param name="action">TBD</param>
        </member>
        <member name="M:Akka.Actor.UntypedActor.RunTask(System.Func{System.Threading.Tasks.Task})">
            <summary>
            TBD
            </summary>
            <param name="action">TBD</param>
        </member>
        <member name="M:Akka.Actor.UntypedActor.OnReceive(System.Object)">
            <summary>
            To be implemented by concrete UntypedActor, this defines the behavior of the UntypedActor.
            This method is called for every message received by the actor.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Actor.UntypedActor.Become(Akka.Actor.UntypedReceive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="M:Akka.Actor.UntypedActor.BecomeStacked(Akka.Actor.UntypedReceive)">
            <summary>
            Changes the actor's behavior and replaces the current receive handler with the specified handler.
            The current handler is stored on a stack, and you can revert to it by calling <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>
            <remarks>Please note, that in order to not leak memory, make sure every call to <see cref="M:Akka.Actor.UntypedActor.BecomeStacked(Akka.Actor.UntypedReceive)"/>
            is matched with a call to <see cref="M:Akka.Actor.IActorContext.UnbecomeStacked"/>.</remarks>
            </summary>
            <param name="receive">The new message handler.</param>
        </member>
        <member name="P:Akka.Actor.UntypedActor.Context">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Actor.UntypedReceive">
            <summary>
                Delegate UntypedReceive
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Configuration.Config">
            <summary>
            This class represents the main configuration object used by Akka.NET
            when configuring objects within the system. To put it simply, it's
            the internal representation of a HOCON (Human-Optimized Config Object Notation)
            configuration string.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Config.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Config"/> class.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Config.#ctor(Akka.Configuration.Hocon.HoconRoot)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Config"/> class.
            </summary>
            <param name="root">The root node to base this configuration.</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the given <paramref name="root"/> value is undefined.</exception>
        </member>
        <member name="M:Akka.Configuration.Config.#ctor(Akka.Configuration.Config,Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Config"/> class.
            </summary>
            <param name="source">The configuration to use as the primary source.</param>
            <param name="fallback">The configuration to use as a secondary source.</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown if the given <paramref name="source"/> is undefined.</exception>
        </member>
        <member name="P:Akka.Configuration.Config.Fallback">
            <summary>
            The configuration used as a secondary source.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Config.IsEmpty">
            <summary>
            Determines if this root node contains any values
            </summary>
        </member>
        <member name="P:Akka.Configuration.Config.Root">
            <summary>
            The root node of this configuration section
            </summary>
        </member>
        <member name="P:Akka.Configuration.Config.Substitutions">
            <summary>
            An enumeration of substitutions values
            </summary>
        </member>
        <member name="M:Akka.Configuration.Config.Copy(Akka.Configuration.Config)">
            <summary>
            Generates a deep clone of the current configuration.
            </summary>
            <returns>A deep clone of the current configuration</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetBoolean(System.String,System.Boolean)">
            <summary>
            Retrieves a boolean value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The boolean value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetByteSize(System.String)">
            <summary>
            Retrieves a long value, optionally suffixed with a 'b', from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The long value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetInt(System.String,System.Int32)">
            <summary>
            Retrieves an integer value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The integer value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetLong(System.String,System.Int64)">
            <summary>
            Retrieves a long value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The long value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetString(System.String,System.String)">
            <summary>
            Retrieves a string value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The string value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetFloat(System.String,System.Single)">
            <summary>
            Retrieves a float value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The float value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetDecimal(System.String,System.Decimal)">
            <summary>
            Retrieves a decimal value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The decimal value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetDouble(System.String,System.Double)">
            <summary>
            Retrieves a double value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The double value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetBooleanList(System.String)">
            <summary>
            Retrieves a list of boolean values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The list of boolean values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetDecimalList(System.String)">
            <summary>
            Retrieves a list of decimal values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The list of decimal values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetFloatList(System.String)">
            <summary>
            Retrieves a list of float values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The list of float values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetDoubleList(System.String)">
            <summary>
            Retrieves a list of double values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The list of double values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetIntList(System.String)">
            <summary>
            Retrieves a list of int values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The list of int values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetLongList(System.String)">
            <summary>
            Retrieves a list of long values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The list of long values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetByteList(System.String)">
            <summary>
            Retrieves a list of byte values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The list of byte values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetStringList(System.String)">
            <summary>
            Retrieves a list of string values from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the values to retrieve.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The list of string values defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetConfig(System.String)">
            <summary>
            Retrieves a new configuration from the current configuration
            with the root node being the supplied path.
            </summary>
            <param name="path">The path that contains the configuration to retrieve.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>A new configuration with the root node being the supplied path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetValue(System.String)">
            <summary>
            Retrieves a <see cref="T:Akka.Configuration.Hocon.HoconValue"/> from a specific path.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The <see cref="T:Akka.Configuration.Hocon.HoconValue"/> found at the location if one exists, otherwise <c>null</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.GetTimeSpan(System.String,System.Nullable{System.TimeSpan},System.Boolean)">
            <summary>
            Retrieves a <see cref="T:System.TimeSpan"/> value from the specified path in the configuration.
            </summary>
            <param name="path">The path that contains the value to retrieve.</param>
            <param name="default">The default value to return if the value doesn't exist.</param>
            <param name="allowInfinite"><c>true</c> if infinite timespans are allowed; otherwise <c>false</c>.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns>The <see cref="T:System.TimeSpan"/> value defined in the specified path.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.ToString">
            <summary>
            Converts the current configuration to a string.
            </summary>
            <returns>A string containing the current configuration.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.ToString(System.Boolean)">
            <summary>
            Converts the current configuration to a string 
            </summary>
            <param name="includeFallback">if true returns string with current config combined with fallback key-values else only current config key-values</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Configuration.Config.WithFallback(Akka.Configuration.Config)">
            <summary>
            Configure the current configuration with a secondary source.
            </summary>
            <param name="fallback">The configuration to use as a secondary source.</param>
            <exception cref="T:System.ArgumentException">This exception is thrown if the given <paramref name="fallback"/> is a reference to this instance.</exception>
            <returns>The current configuration configured with the specified fallback.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.HasPath(System.String)">
            <summary>
            Determine if a HOCON configuration element exists at the specified location
            </summary>
            <param name="path">The location to check for a configuration value.</param>
            <exception cref="T:System.InvalidOperationException">This exception is thrown if the current node is undefined.</exception>
            <returns><c>true</c> if a value was found, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.op_Addition(Akka.Configuration.Config,System.String)">
            <summary>
            Adds the supplied configuration string as a fallback to the supplied configuration.
            </summary>
            <param name="config">The configuration used as the source.</param>
            <param name="fallback">The string used as the fallback configuration.</param>
            <returns>The supplied configuration configured with the supplied fallback.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.op_Addition(System.String,Akka.Configuration.Config)">
            <summary>
            Adds the supplied configuration as a fallback to the supplied configuration string.
            </summary>
            <param name="configHocon">The configuration string used as the source.</param>
            <param name="fallbackConfig">The configuration used as the fallback.</param>
            <returns>A configuration configured with the supplied fallback.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.op_Implicit(System.String)~Akka.Configuration.Config">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Akka.Configuration.Config"/>.
            </summary>
            <param name="str">The string that contains a configuration.</param>
            <returns>A configuration based on the supplied string.</returns>
        </member>
        <member name="M:Akka.Configuration.Config.AsEnumerable">
            <summary>
            Retrieves an enumerable key value pair representation of the current configuration.
            </summary>
            <returns>The current configuration represented as an enumerable key value pair.</returns>
        </member>
        <member name="F:Akka.Configuration.Config.Empty">
            <summary>
            A static "Empty" configuration we can use instead of <c>null</c> in some key areas.
            </summary>
        </member>
        <member name="T:Akka.Configuration.ConfigExtensions">
            <summary>
            This class contains convenience methods for working with <see cref="T:Akka.Configuration.Config"/>.
            </summary>
        </member>
        <member name="M:Akka.Configuration.ConfigExtensions.SafeWithFallback(Akka.Configuration.Config,Akka.Configuration.Config)">
            <summary>
            Retrieves the current configuration or the fallback
            configuration if the current one is null.
            </summary>
            <param name="config">The configuration used as the source.</param>
            <param name="fallback">The configuration to use as a secondary source.</param>
            <returns>The current configuration or the fallback configuration if the current one is null.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigExtensions.IsNullOrEmpty(Akka.Configuration.Config)">
            <summary>
            Determines if the supplied configuration has any usable content period.
            </summary>
            <param name="config">The configuration used as the source.</param>
            <returns><c>true></c> if the <see cref="T:Akka.Configuration.Config" /> is null or <see cref="P:Akka.Configuration.Config.IsEmpty" />; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Akka.Configuration.ConfigurationException">
            <summary>
            The exception that is thrown when a configuration is invalid.
            </summary>
        </member>
        <member name="M:Akka.Configuration.ConfigurationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.ConfigurationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Configuration.ConfigurationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.ConfigurationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="exception">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Configuration.ConfigurationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.ConfigurationException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Configuration.ConfigurationFactory">
            <summary>
            This class contains methods used to retrieve configuration information
            from a variety of sources including user-supplied strings, configuration
            files and assembly resources.
            </summary>
        </member>
        <member name="P:Akka.Configuration.ConfigurationFactory.Empty">
            <summary>
            Generates an empty configuration.
            </summary>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.ParseString(System.String,System.Func{System.String,Akka.Configuration.Hocon.HoconRoot})">
            <summary>
            Generates a configuration defined in the supplied
            HOCON (Human-Optimized Config Object Notation) string.
            </summary>
            <param name="hocon">A string that contains configuration options to use.</param>
            <param name="includeCallback">callback used to resolve includes</param>
            <returns>The configuration defined in the supplied HOCON string.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.ParseString(System.String)">
            <summary>
            Generates a configuration defined in the supplied
            HOCON (Human-Optimized Config Object Notation) string.
            </summary>
            <param name="hocon">A string that contains configuration options to use.</param>
            <returns>The configuration defined in the supplied HOCON string.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.Load">
            <summary>
            Loads a configuration defined in the current application's
            configuration file, e.g. app.config or web.config
            </summary>
            <returns>The configuration defined in the configuration file.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.Default">
            <summary>
            Retrieves the default configuration that Akka.NET uses
            when no configuration has been defined.
            </summary>
            <returns>The configuration that contains default values for all options.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.FromResource(System.String)">
            <summary>
            Retrieves a configuration defined in a resource of the
            current executing assembly.
            </summary>
            <param name="resourceName">The name of the resource that contains the configuration.</param>
            <returns>The configuration defined in the current executing assembly.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.FromResource(System.String,System.Object)">
            <summary>
            Retrieves a configuration defined in a resource of the
            assembly containing the supplied instance object.
            </summary>
            <param name="resourceName">The name of the resource that contains the configuration.</param>
            <param name="instanceInAssembly">An instance object located in the assembly to search.</param>
            <returns>The configuration defined in the assembly that contains the instanced object.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.FromResource``1(System.String)">
            <summary>
            Retrieves a configuration defined in a resource of the assembly
            containing the supplied type <typeparamref name="TAssembly"/>.
            </summary>
            <typeparam name="TAssembly">A type located in the assembly to search.</typeparam>
            <param name="resourceName">The name of the resource that contains the configuration.</param>
            <returns>The configuration defined in the assembly that contains the type <typeparamref name="TAssembly"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.FromResource(System.String,System.Reflection.Assembly)">
            <summary>
            Retrieves a configuration defined in a resource of the supplied assembly.
            </summary>
            <param name="resourceName">The name of the resource that contains the configuration.</param>
            <param name="assembly">The assembly that contains the given resource.</param>
            <returns>The configuration defined in the assembly that contains the given resource.</returns>
        </member>
        <member name="M:Akka.Configuration.ConfigurationFactory.FromObject(System.Object)">
            <summary>
            Creates a configuration based on the supplied source object
            </summary>
            <param name="source">The source object</param>
            <returns>The configuration created from the source object</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.AkkaConfigurationSection">
            <summary>
            This class represents a custom akka node within a configuration file.
            <code>
            <![CDATA[
            <?xml version="1.0" encoding="utf-8" ?>
            <configuration>
              <configSections>
                <section name="akka" type="Akka.Configuration.Hocon.AkkaConfigurationSection, Akka" />
              </configSections>
              <akka>
              ...
              </akka>
            </configuration>
            ]]>
            </code>
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.AkkaConfigurationSection.AkkaConfig">
            <summary>
            Retrieves a <see cref="T:Akka.Configuration.Config"/> from the contents of the
            custom akka node within a configuration file.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.AkkaConfigurationSection.Hocon">
            <summary>
            Retrieves the HOCON (Human-Optimized Config Object Notation)
            configuration string from the custom akka node.
            <code>
            <![CDATA[
            <?xml version="1.0" encoding="utf-8" ?>
            <configuration>
              <configSections>
                <section name="akka" type="Akka.Configuration.Hocon.AkkaConfigurationSection, Akka" />
              </configSections>
              <akka>
                 <hocon>
                 ...
                 </hocon>
              </akka>
            </configuration>
            ]]>
            </code>
            </summary>
        </member>
        <member name="T:Akka.Configuration.Hocon.CDataConfigurationElement">
            <summary>
            This class represents the base implementation for retrieving text from
            an XML CDATA node within a configuration file.
            <code>
            <![CDATA[
            <?xml version="1.0" encoding="utf-8" ?>
            <configuration>
              <configSections>
                <section name="akka" type="Akka.Configuration.Hocon.AkkaConfigurationSection, Akka" />
              </configSections>
              <akka>
                <hocon>
                  &lt;![CDATA[
                  ...
                  ]]&gt;
                </hocon>
              </akka>
            </configuration>
            ]]>
            </code>
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.CDataConfigurationElement.ContentPropertyName">
            <summary>
            The name of the property that contains the content to deserialize.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.CDataConfigurationElement.DeserializeElement(System.Xml.XmlReader,System.Boolean)">
            <summary>
            Deserializes the text located in a CDATA node of the configuration file.
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader" /> that reads from the configuration file.</param>
            <param name="serializeCollectionKey"><c>true</c> to serialize only the collection key properties; otherwise, <c>false</c>.</param>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconArray">
            <summary>
            This class represents an array element in a HOCON (Human-Optimized Config Object Notation)
            configuration string.
            <code>
            akka {
              cluster {
                seed-nodes = [
                  "akka.tcp://ClusterSystem@127.0.0.1:2551",
                  "akka.tcp://ClusterSystem@127.0.0.1:2552"]
              }
            }
            </code>
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.IsString">
            <summary>
            Determines whether this element is a string.
            </summary>
            <returns><c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.GetString">
            <summary>
            N/A
            </summary>
            <returns>N/A</returns>
            <exception cref="T:System.NotImplementedException">
            This exception is thrown automatically since this element is an array and not a string.
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.IsArray">
            <summary>
            Determines whether this element is an array.
            </summary>
            <returns><c>true</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.GetArray">
            <summary>
            Retrieves a list of elements associated with this element.
            </summary>
            <returns>
            A list of elements associated with this element.
            </returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconArray.ToString">
            <summary>
            Returns a HOCON string representation of this element.
            </summary>
            <returns>A HOCON string representation of this element.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconConfigurationElement">
            <summary>
            This class represents a custom HOCON (Human-Optimized Config Object Notation)
            node within a configuration file.
            <code>
            <![CDATA[
            <?xml version="1.0" encoding="utf-8" ?>
            <configuration>
              <configSections>
                <section name="akka" type="Akka.Configuration.Hocon.AkkaConfigurationSection, Akka" />
              </configSections>
              <akka>
                <hocon>
                ...
                </hocon>
              </akka>
            </configuration>
            ]]>
            </code>
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconConfigurationElement.Content">
            <summary>
            Gets or sets the HOCON configuration string contained in the hocon node.
            </summary>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconLiteral">
            <summary>
            This class represents a string literal element in a HOCON (Human-Optimized Config Object Notation)
            configuration string.
            <code>
            akka {  
              actor {
                provider = "Akka.Remote.RemoteActorRefProvider, Akka.Remote"
              }
            }
            </code>
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconLiteral.Value">
            <summary>
            Gets or sets the value of this element.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconLiteral.IsString">
            <summary>
            Determines whether this element is a string.
            </summary>
            <returns><c>true</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconLiteral.GetString">
            <summary>
            Retrieves the string representation of this element.
            </summary>
            <returns>The value of this element.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconLiteral.IsArray">
            <summary>
            Determines whether this element is an array.
            </summary>
            <returns><c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconLiteral.GetArray">
            <summary>
            N/A
            </summary>
            <returns>N/A</returns>
            <exception cref="T:System.NotImplementedException">
            This exception is thrown automatically since this element is a string literal and not an array.
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconLiteral.ToString">
            <summary>
            Returns the string representation of this element.
            </summary>
            <returns>The value of this element.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconObject">
            <summary>
            This class represents an object element in a HOCON (Human-Optimized Config Object Notation)
            configuration string.
            <code>
            akka {  
              actor {
                debug {  
                  receive = on 
                  autoreceive = on
                  lifecycle = on
                  event-stream = on
                  unhandled = on
                }
              }
            }
            </code>
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconObject"/> class.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconObject.Unwrapped">
            <summary>
            Retrieves the underlying map that contains the barebones
            object values.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconObject.Items">
            <summary>
            Retrieves the underlying map that this element is based on.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.IsString">
            <summary>
            Determines whether this element is a string.
            </summary>
            <returns><c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.GetString">
            <summary>
            N/A
            </summary>
            <returns>N/A</returns>
            <exception cref="T:System.NotImplementedException">
            This exception is thrown automatically since this element is an object and not a string.
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.IsArray">
            <summary>
            Determines whether this element is an array.
            </summary>
            <returns><c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.GetArray">
            <summary>
            N/A
            </summary>
            <returns>N/A</returns>
            <exception cref="T:System.NotImplementedException">
            This exception is thrown automatically since this element is an object and not an array.
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.GetKey(System.String)">
            <summary>
            Retrieves the value associated with the supplied key.
            </summary>
            <param name="key">The key associated with the value to retrieve.</param>
            <returns>
            The value associated with the supplied key or null
            if they key does not exist.
            </returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.GetOrCreateKey(System.String)">
            <summary>
            Retrieves the value associated with the supplied key.
            If the supplied key is not found, then one is created
            with a blank value.
            </summary>
            <param name="key">The key associated with the value to retrieve.</param>
            <returns>The value associated with the supplied key.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.ToString">
            <summary>
            Returns a HOCON string representation of this element.
            </summary>
            <returns>A HOCON string representation of this element.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.ToString(System.Int32)">
            <summary>
            Returns a HOCON string representation of this element.
            </summary>
            <param name="indent">The number of spaces to indent the string.</param>
            <returns>A HOCON string representation of this element.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.Merge(Akka.Configuration.Hocon.HoconObject)">
            <summary>
            Merges the specified object into this instance.
            </summary>
            <param name="other">The object to merge into this instance.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconObject.MergeImmutable(Akka.Configuration.Hocon.HoconObject)">
            <summary>
            Merges the specified object with this instance producing new one.
            </summary>
            <param name="other">The object to merge into this instance.</param>
        </member>
        <member name="T:Akka.Configuration.Hocon.Parser">
            <summary>
            This class contains methods used to parse HOCON (Human-Optimized Config Object Notation)
            configuration strings.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.Parse(System.String,System.Func{System.String,Akka.Configuration.Hocon.HoconRoot})">
            <summary>
            Parses the supplied HOCON configuration string into a root element.
            </summary>
            <param name="text">The string that contains a HOCON configuration string.</param>
            <param name="includeCallback">Callback used to resolve includes</param>
            <exception cref="T:System.FormatException">This exception is thrown if an unresolved substitution or an unknown token is encountered.</exception>
            <exception cref="T:System.Exception">This exception is thrown if the end of the file has been reached while trying to read a value.</exception>
            <returns>The root element created from the supplied HOCON configuration string.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.ParseValue(Akka.Configuration.Hocon.HoconValue,System.String)">
            <summary>
            Retrieves the next value token from the tokenizer and appends it
            to the supplied element <paramref name="owner"/>.
            </summary>
            <param name="owner">The element to append the next token.</param>
            <param name="currentPath">The location in the HOCON object hierarchy that the parser is currently reading.</param>
            <exception cref="T:System.Exception">This exception is thrown if the end of the file has been reached while trying to read a value.</exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.Parser.ParseArray(System.String)">
            <summary>
            Retrieves the next array token from the tokenizer.
            </summary>
            <param name="currentPath">The location in the HOCON object hierarchy that the parser is currently reading.</param>
            <returns>An array of elements retrieved from the token.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconRoot">
            <summary>
            This class represents the root element in a HOCON (Human-Optimized Config Object Notation)
            configuration string.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconRoot.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconRoot"/> class.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconRoot.#ctor(Akka.Configuration.Hocon.HoconValue,System.Collections.Generic.IEnumerable{Akka.Configuration.Hocon.HoconSubstitution})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconRoot"/> class.
            </summary>
            <param name="value">The value to associate with this element.</param>
            <param name="substitutions">An enumeration of substitutions to associate with this element.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconRoot.#ctor(Akka.Configuration.Hocon.HoconValue)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconRoot"/> class.
            </summary>
            <param name="value">The value to associate with this element.</param>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconRoot.Value">
            <summary>
            Retrieves the value associated with this element.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconRoot.Substitutions">
            <summary>
            Retrieves an enumeration of substitutions associated with this element.
            </summary>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconSubstitution">
            <summary>
            This class represents a substitution element in a HOCON (Human-Optimized Config Object Notation)
            configuration string.
            <code>
            akka {  
              defaultInstances = 10
              deployment{
                /user/time{
                  nr-of-instances = $defaultInstances
                }
              }
            }
            </code>
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconSubstitution"/> class.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconSubstitution" /> class.
            </summary>
            <param name="path">The path.</param>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconSubstitution.Path">
            <summary>
                The full path to the value which should substitute this instance.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconSubstitution.ResolvedValue">
            <summary>
                The evaluated value from the Path property
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.IsString">
            <summary>
            Determines whether this element is a string.
            </summary>
            <returns><c>true</c> if this element is a string; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.GetString">
            <summary>
            Retrieves the string representation of this element.
            </summary>
            <returns>The string representation of this element.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.IsArray">
            <summary>
            Determines whether this element is an array.
            </summary>
            <returns><c>true</c> if this element is aan array; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.GetArray">
            <summary>
            Retrieves a list of elements associated with this element.
            </summary>
            <returns>A list of elements associated with this element.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.IsObject">
            <summary>
            Determines whether this element is a HOCON object.
            </summary>
            <returns><c>true</c> if this element is a HOCON object; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconSubstitution.GetObject">
            <summary>
            Retrieves the HOCON object representation of this element.
            </summary>
            <returns>The HOCON object representation of this element.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.TokenType">
            <summary>
            This enumeration defines the different types of tokens found within
            a HOCON (Human-Optimized Config Object Notation) configuration string.
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Comment">
            <summary>
            This token type represents a comment.
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Key">
            <summary>
            This token type represents the key portion of a key-value pair.
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.LiteralValue">
            <summary>
            This token type represents the value portion of a key-value pair.
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Assign">
            <summary>
            This token type represents the assignment operator, <c>=</c> or <c>:</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.ObjectStart">
            <summary>
            This token type represents the beginning of an object, <c>{</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.ObjectEnd">
            <summary>
            This token type represents the end of an object, <c>}</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Dot">
            <summary>
            This token type represents a namespace separator, <c>.</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.EoF">
            <summary>
            This token type represents the end of the configuration string.
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.ArrayStart">
            <summary>
            This token type represents the beginning of an array, <c>[</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.ArrayEnd">
            <summary>
            This token type represents the end of an array, <c>]</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Comma">
            <summary>
            This token type represents the separator in an array, <c>,</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Substitute">
            <summary>
            This token type represents a replacement variable, <c>$foo</c> .
            </summary>
        </member>
        <member name="F:Akka.Configuration.Hocon.TokenType.Include">
            <summary>
            This token type represents an include statement.
            </summary>
        </member>
        <member name="T:Akka.Configuration.Hocon.Token">
            <summary>
            This class represents a token within a HOCON (Human-Optimized Config Object Notation)
            configuration string.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.Token"/> class.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.#ctor(Akka.Configuration.Hocon.TokenType)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.Token"/> class.
            </summary>
            <param name="type">The type of token to associate with.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.Token"/> class.
            </summary>
            <param name="value">The string literal value to associate with this token.</param>
        </member>
        <member name="P:Akka.Configuration.Hocon.Token.Value">
            <summary>
            The value associated with this token. If this token is
            a <see cref="F:Akka.Configuration.Hocon.TokenType.LiteralValue"/>, then this property
            holds the string literal.
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.Token.Type">
            <summary>
            The type that represents this token.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.Key(System.String)">
            <summary>
            Creates a key token with a given <paramref name="key"/>.
            </summary>
            <param name="key">The key to associate with this token.</param>
            <returns>A key token with the given key.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.Substitution(System.String)">
            <summary>
            Creates a substitution token with a given <paramref name="path"/>.
            </summary>
            <param name="path">The path to associate with this token.</param>
            <returns>A substitution token with the given path.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Token.LiteralValue(System.String)">
            <summary>
            Creates a string literal token with a given <paramref name="value"/>.
            </summary>
            <param name="value">The value to associate with this token.</param>
            <returns>A string literal token with the given value.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.Tokenizer">
            <summary>
            This class contains methods used to tokenize a string.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Push">
            <summary>
            Adds the current index to the tokenizer's bookkeeping stack.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Pop">
            <summary>
            Removes an index from the tokenizer's bookkeeping stack. 
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.Tokenizer"/> class.
            </summary>
            <param name="text">The string that contains the text to tokenize.</param>
        </member>
        <member name="P:Akka.Configuration.Hocon.Tokenizer.EoF">
            <summary>
            A value indicating whether the tokenizer has reached the end of the string.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Matches(System.String)">
            <summary>
            Determines whether the given pattern matches the value at the current
            position of the tokenizer.
            </summary>
            <param name="pattern">The string that contains the characters to match.</param>
            <returns><c>true</c> if the pattern matches, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Take(System.Int32)">
            <summary>
            Retrieves a string of the given length from the current position of the tokenizer.
            </summary>
            <param name="length">The length of the string to return.</param>
            <returns>
            The string of the given length. If the length exceeds where the
            current index is located, then null is returned.
            </returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Matches(System.String[])">
            <summary>
            Determines whether any of the given patterns match the value at the current
            position of the tokenizer.
            </summary>
            <param name="patterns">The string array that contains the characters to match.</param>
            <returns><c>true</c> if any one of the patterns match, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Peek">
            <summary>
            Retrieves the next character in the tokenizer without advancing its position.
            </summary>
            <returns>The character at the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.Take">
            <summary>
            Retrieves the next character in the tokenizer.
            </summary>
            <returns>The character at the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.Tokenizer.PullWhitespace">
            <summary>
            Advances the tokenizer to the next non-whitespace character.
            </summary>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconTokenizer">
            <summary>
            This class contains methods used to tokenize HOCON (Human-Optimized Config Object Notation)
            configuration strings.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconTokenizer"/> class.
            </summary>
            <param name="text">The string that contains the text to tokenize.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullWhitespaceAndComments">
            <summary>
            Advances the tokenizer to the next non-whitespace, non-comment token.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullRestOfLine">
            <summary>
            Retrieves the current line from where the current token
            is located in the string.
            </summary>
            <returns>The current line from where the current token is located.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullNext">
            <summary>
            Retrieves the next token from the string.
            </summary>
            <exception cref="T:System.FormatException">This exception is thrown if an unknown token or escape code is encountered.</exception>
            <returns>The next token contained in the string.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullArrayEnd">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.ArrayEnd"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.ArrayEnd"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsArrayEnd">
            <summary>
            Determines whether the current token matches an <see cref="F:Akka.Configuration.Hocon.TokenType.ArrayEnd"/> token.
            </summary>
            <returns><c>true</c> if the token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsArrayStart">
            <summary>
            Determines whether the current token matches an <see cref="F:Akka.Configuration.Hocon.TokenType.ArrayStart"/> token.
            </summary>
            <returns><c>true</c> if the token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullArrayStart">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.ArrayStart"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.ArrayStart"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullDot">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.Dot"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.Dot"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullComma">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.Comma"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.Comma"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullStartOfObject">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.ObjectStart"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.ObjectStart"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullEndOfObject">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.ObjectEnd"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.ObjectEnd"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullAssignment">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.Assign"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.Assign"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsComma">
            <summary>
            Determines whether the current token matches an <see cref="F:Akka.Configuration.Hocon.TokenType.Comma"/> token.
            </summary>
            <returns><c>true</c> if the token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsDot">
            <summary>
            Determines whether the current token matches an <see cref="F:Akka.Configuration.Hocon.TokenType.Dot"/> token.
            </summary>
            <returns><c>true</c> if the token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsObjectStart">
            <summary>
            Determines whether the current token matches an <see cref="F:Akka.Configuration.Hocon.TokenType.ObjectStart"/> token.
            </summary>
            <returns><c>true</c> if the token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsEndOfObject">
            <summary>
            Determines whether the current token matches an <see cref="F:Akka.Configuration.Hocon.TokenType.ObjectEnd"/> token.
            </summary>
            <returns><c>true</c> if the token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsAssignment">
            <summary>
            Determines whether the current token matches an <see cref="F:Akka.Configuration.Hocon.TokenType.Assign"/> token.
            </summary>
            <returns><c>true</c> if the token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsStartOfQuotedText">
            <summary>
            Determines whether the current token matches the start of a quoted string.
            </summary>
            <returns><c>true</c> if token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsStartOfTripleQuotedText">
            <summary>
            Determines whether the current token matches the start of a triple quoted string.
            </summary>
            <returns><c>true</c> if token matches; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullComment">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.Comment"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.Comment"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullUnquotedKey">
            <summary>
            Retrieves an unquoted <see cref="F:Akka.Configuration.Hocon.TokenType.Key"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.Key"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsUnquotedKey">
            <summary>
            Determines whether the current token is an unquoted key.
            </summary>
            <returns><c>true</c> if token is an unquoted key; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsUnquotedKeyStart">
            <summary>
            Determines whether the current token is the start of an unquoted key.
            </summary>
            <returns><c>true</c> if token is the start of an unquoted key; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsWhitespace">
            <summary>
            Determines whether the current token is whitespace.
            </summary>
            <returns><c>true</c> if token is whitespace; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsWhitespaceOrComment">
            <summary>
            Determines whether the current token is whitespace or a comment.
            </summary>
            <returns><c>true</c> if token is whitespace or a comment; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullTripleQuotedText">
            <summary>
            Retrieves a triple quoted <see cref="F:Akka.Configuration.Hocon.TokenType.LiteralValue"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.LiteralValue"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullQuotedText">
            <summary>
            Retrieves a quoted <see cref="F:Akka.Configuration.Hocon.TokenType.LiteralValue"/> token from the tokenizer's current position.
            </summary>
            <exception cref="T:System.FormatException">This exception is thrown if an unknown escape code is encountered.</exception>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.LiteralValue"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullQuotedKey">
            <summary>
            Retrieves a quoted <see cref="F:Akka.Configuration.Hocon.TokenType.Key"/> token from the tokenizer's current position.
            </summary>
            <exception cref="T:System.FormatException">This exception is thrown if an unknown escape code is encountered.</exception>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.Key"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullInclude">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.FormatException">This exception is thrown if an unknown escape code is encountered.</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsStartOfComment">
            <summary>
            Determines whether the current token is the start of a comment.
            </summary>
            <returns><c>true</c> if token is the start of a comment; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullValue">
            <summary>
            Retrieves a value token from the tokenizer's current position.
            </summary>
            <returns>A value token from the tokenizer's current position.</returns>
            <exception cref="T:System.FormatException">
            This exception is thrown if an unknown token is encountered. Expected values include the following:
            Null literal, Array, Quoted Text, Unquoted Text, Triple quoted Text, Object or End of array.
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsSubstitutionStart">
            <summary>
            Determines whether the current token is the start of a substitution.
            </summary>
            <returns><c>true</c> if token is the start of a substitution; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsInclude">
            <summary>
            Determines whether the current token is the start of an include directive.
            </summary>
            <exception cref="T:System.FormatException">This exception is thrown if an unknown escape code is encountered.</exception>
            <returns><c>true</c> if token is the start of an include directive; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullSubstitution">
            <summary>
            Retrieves a <see cref="F:Akka.Configuration.Hocon.TokenType.Substitute"/> token from the tokenizer's current position.
            </summary>
            <returns>A <see cref="F:Akka.Configuration.Hocon.TokenType.Substitute"/> token from the tokenizer's current position.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsSpaceOrTab">
            <summary>
            Determines whether the current token is a space or a tab.
            </summary>
            <returns><c>true</c> if token is the start of a space or a tab; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsStartSimpleValue">
            <summary>
            Determines whether the current token is the start of an unquoted string literal.
            </summary>
            <returns><c>true</c> if token is the start of an unquoted string literal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullSpaceOrTab">
            <summary>
            Retrieves the current token, including whitespace and tabs, as a string literal token.
            </summary>
            <returns>A token that contains the string literal value.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.PullSimpleValue">
            <summary>
            Retrieves the current token as a string literal token.
            </summary>
            <exception cref="T:System.FormatException">
            This exception is thrown if the tokenizer cannot find a string literal value from the current token.
            </exception>
            <returns>A token that contains the string literal value.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconTokenizer.IsValue">
            <summary>
            Determines whether the current token is a value.
            </summary>
            <returns><c>true</c> if the current token is a value; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.HoconValue">
            <summary>
            This class represents the root type for a HOCON (Human-Optimized Config Object Notation)
            configuration object.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconValue"/> class.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.#ctor(System.Collections.Generic.List{Akka.Configuration.Hocon.IHoconElement},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Configuration.Hocon.HoconValue"/> class.
            </summary>
            <param name="values">The list of elements inside this HOCON value.</param>
            <param name="adoptedFromFallback">Indicates whether this instance was constructed during association with fallback <see cref="T:Akka.Configuration.Config"/>.</param>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconValue.IsEmpty">
            <summary>
            Returns true if this HOCON value doesn't contain any elements
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconValue.Values">
            <summary>
            The list of elements inside this HOCON value
            </summary>
        </member>
        <member name="P:Akka.Configuration.Hocon.HoconValue.AdoptedFromFallback">
            <summary>
            Marker for values were merged during fallback attaching
            serving exclusively to skip rendering such values in <see cref="M:Akka.Configuration.Hocon.HoconObject.ToString"/>
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.AtKey(System.String)">
            <summary>
            Wraps this <see cref="T:Akka.Configuration.Hocon.HoconValue"/> into a new <see cref="T:Akka.Configuration.Config"/> object at the specified key.
            </summary>
            <param name="key">The key designated to be the new root element.</param>
            <returns>A <see cref="T:Akka.Configuration.Config"/> with the given key as the root element.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetObject">
            <summary>
            Retrieves the <see cref="T:Akka.Configuration.Hocon.HoconObject"/> from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The <see cref="T:Akka.Configuration.Hocon.HoconObject"/> that represents this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.IsObject">
            <summary>
            Determines if this <see cref="T:Akka.Configuration.Hocon.HoconValue"/> is a <see cref="T:Akka.Configuration.Hocon.HoconObject"/>.
            </summary>
            <returns><c>true</c> if this value is a <see cref="T:Akka.Configuration.Hocon.HoconObject"/>, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.AppendValue(Akka.Configuration.Hocon.IHoconElement)">
            <summary>
            Adds the given element to the list of elements inside this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <param name="value">The element to add to the list.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.Clear">
            <summary>
            Clears the list of elements inside this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.NewValue(Akka.Configuration.Hocon.IHoconElement)">
            <summary>
            Creates a fresh list of elements inside this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>
            and adds the given value to the list.
            </summary>
            <param name="value">The element to add to the list.</param>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.IsString">
            <summary>
            Determines whether all the elements inside this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>
            are a string.
            </summary>
            <returns>
              <c>true</c>if all elements inside this <see cref="T:Akka.Configuration.Hocon.HoconValue"/> are a string; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetChildObject(System.String)">
            <summary>
            Retrieves the child object located at the given key.
            </summary>
            <param name="key">The key used to retrieve the child object.</param>
            <returns>The element at the given key.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetBoolean">
            <summary>
            Retrieves the boolean value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The boolean value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
            <exception cref="T:System.NotSupportedException">
            This exception is thrown if the <see cref="T:Akka.Configuration.Hocon.HoconValue"/> doesn't
            conform to the standard boolean values: "on", "off", "true", or "false"
            </exception>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetString">
            <summary>
            Retrieves the string value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The string value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetDecimal">
            <summary>
            Retrieves the decimal value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The decimal value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetFloat">
            <summary>
            Retrieves the float value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The float value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetDouble">
            <summary>
            Retrieves the double value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The double value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetLong">
            <summary>
            Retrieves the long value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The long value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetInt">
            <summary>
            Retrieves the integer value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The integer value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetByte">
            <summary>
            Retrieves the byte value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The byte value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetByteList">
            <summary>
            Retrieves a list of byte values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of byte values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetIntList">
            <summary>
            Retrieves a list of integer values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of integer values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetLongList">
            <summary>
            Retrieves a list of long values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of long values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetBooleanList">
            <summary>
            Retrieves a list of boolean values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of boolean values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetFloatList">
            <summary>
            Retrieves a list of float values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of float values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetDoubleList">
            <summary>
            Retrieves a list of double values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of double values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetDecimalList">
            <summary>
            Retrieves a list of decimal values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of decimal values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetStringList">
            <summary>
            Retrieves a list of string values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of string values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetArray">
            <summary>
            Retrieves a list of values from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A list of values represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.IsArray">
            <summary>
            Determines whether this <see cref="T:Akka.Configuration.Hocon.HoconValue"/> is an array.
            </summary>
            <returns>
              <c>true</c> if this <see cref="T:Akka.Configuration.Hocon.HoconValue"/> is an array; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetTimeSpan(System.Boolean)">
            <summary>
            Retrieves the time span value from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <param name="allowInfinite">A flag used to set infinite durations.</param>
            <exception cref="T:System.FormatException">
            This exception is thrown if the timespan given in the <see cref="T:Akka.Configuration.Hocon.HoconValue"/> is negative.
            </exception>
            <returns>The time span value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.GetByteSize">
            <summary>
            Retrieves the long value, optionally suffixed with a 'b', from this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>The long value represented by this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.ToString">
            <summary>
            Returns a HOCON string representation of this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <returns>A HOCON string representation of this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.HoconValue.ToString(System.Int32)">
            <summary>
            Returns a HOCON string representation of this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.
            </summary>
            <param name="indent">The number of spaces to indent the string.</param>
            <returns>A HOCON string representation of this <see cref="T:Akka.Configuration.Hocon.HoconValue"/>.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.IMightBeAHoconObject">
            <summary>
            Marker interface to make it easier to retrieve HOCON
            (Human-Optimized Config Object Notation) objects for
            substitutions.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.IMightBeAHoconObject.IsObject">
            <summary>
            Determines whether this element is a HOCON object.
            </summary>
            <returns><c>true</c> if this element is a HOCON object; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.IMightBeAHoconObject.GetObject">
            <summary>
            Retrieves the HOCON object representation of this element.
            </summary>
            <returns>The HOCON object representation of this element.</returns>
        </member>
        <member name="T:Akka.Configuration.Hocon.IHoconElement">
            <summary>
            This interface defines the contract needed to implement
            a HOCON (Human-Optimized Config Object Notation) element.
            </summary>
        </member>
        <member name="M:Akka.Configuration.Hocon.IHoconElement.IsString">
            <summary>
            Determines whether this element is a string.
            </summary>
            <returns><c>true</c> if this element is a string; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.IHoconElement.GetString">
            <summary>
            Retrieves the string representation of this element.
            </summary>
            <returns>The string representation of this element.</returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.IHoconElement.IsArray">
            <summary>
            Determines whether this element is an array.
            </summary>
            <returns><c>true</c> if this element is aan array; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Configuration.Hocon.IHoconElement.GetArray">
            <summary>
            Retrieves a list of elements associated with this element.
            </summary>
            <returns>A list of elements associated with this element.</returns>
        </member>
        <member name="T:Akka.Dispatch.IDispatcherPrerequisites">
            <summary>
            Contextual information that's useful for dispatchers
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IDispatcherPrerequisites.EventStream">
            <summary>
            The <see cref="P:Akka.Dispatch.IDispatcherPrerequisites.EventStream"/> that belongs to the current <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IDispatcherPrerequisites.Scheduler">
            <summary>
            The <see cref="T:Akka.Actor.IScheduler"/> that belongs to the current <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IDispatcherPrerequisites.Settings">
            <summary>
            The <see cref="P:Akka.Dispatch.IDispatcherPrerequisites.Settings"/> for the current <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IDispatcherPrerequisites.Mailboxes">
            <summary>
            The list of registered <see cref="P:Akka.Dispatch.IDispatcherPrerequisites.Mailboxes"/> for the current <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.DefaultDispatcherPrerequisites">
            <summary>
            The default set of contextual data needed for <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/>s
            </summary>
        </member>
        <member name="M:Akka.Dispatch.DefaultDispatcherPrerequisites.#ctor(Akka.Event.EventStream,Akka.Actor.IScheduler,Akka.Actor.Settings,Akka.Dispatch.Mailboxes)">
            <summary>
            Default constructor...
            </summary>
            <param name="eventStream">TBD</param>
            <param name="scheduler">TBD</param>
            <param name="settings">TBD</param>
            <param name="mailboxes">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.DefaultDispatcherPrerequisites.EventStream">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.DefaultDispatcherPrerequisites.Scheduler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.DefaultDispatcherPrerequisites.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.DefaultDispatcherPrerequisites.Mailboxes">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ExecutorServiceConfigurator">
            <summary>
            INTERNAL API - used to configure the executor used by the <see cref="T:Akka.Dispatch.Dispatcher"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ExecutorServiceConfigurator.#ctor(Akka.Configuration.Config,Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>
            A configurable factory for producing <see cref="T:Akka.Dispatch.ExecutorService"/> instances.
            </summary>
            <param name="config">The configuration for this type of executor.</param>
            <param name="prerequisites">The prerequesites for this type of executor.</param>
        </member>
        <member name="P:Akka.Dispatch.ExecutorServiceConfigurator.Config">
            <summary>
            Executor-specific configuration
            </summary>
        </member>
        <member name="P:Akka.Dispatch.ExecutorServiceConfigurator.Prerequisites">
            <summary>
            The system prerequisites needed for this dispatcher to do its job
            </summary>
        </member>
        <member name="T:Akka.Dispatch.DefaultTaskSchedulerExecutorConfigurator">
            <summary>
            INTERNAL API
            
            Produces <see cref="T:Akka.Dispatch.ExecutorService"/> that dispatches messages using the default <see cref="T:System.Threading.Tasks.TaskScheduler"/>.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.DefaultTaskSchedulerExecutorConfigurator.Produce(System.String)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.DefaultTaskSchedulerExecutorConfigurator.#ctor(Akka.Configuration.Config,Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
            <param name="prerequisites">TBD</param>
        </member>
        <member name="T:Akka.Dispatch.ForkJoinExecutorServiceFactory">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Dispatch.ForkJoinExecutorServiceFactory.SingleThreadDefault">
            <summary>
            Used by <see cref="T:Akka.Dispatch.PinnedDispatcher"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ForkJoinExecutorServiceFactory.#ctor(Akka.Configuration.Config,Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Dispatch.ForkJoinExecutorServiceFactory"/> class.
            </summary>
            <param name="config">TBD</param>
            <param name="prerequisites">TBD</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown if either 'dedicated-thread-pool' OR 'fork-join-executor' is not defined in <paramref name="config"/>.
            </exception>
        </member>
        <member name="M:Akka.Dispatch.ForkJoinExecutorServiceFactory.Produce(System.String)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.ThreadPoolExecutorServiceFactory">
            <summary>
            Factory for producing <see cref="T:Akka.Dispatch.ThreadPoolExecutorService"/> types.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ThreadPoolExecutorServiceFactory.Produce(System.String)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.ThreadPoolExecutorServiceFactory.#ctor(Akka.Configuration.Config,Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
            <param name="prerequisites">TBD</param>
        </member>
        <member name="T:Akka.Dispatch.MessageDispatcherConfigurator">
            <summary>
            Base class used for hooking new <see cref="T:Akka.Dispatch.MessageDispatcher"/> types into <see cref="T:Akka.Dispatch.Dispatchers"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcherConfigurator.#ctor(Akka.Configuration.Config,Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>
            Takes a <see cref="P:Akka.Dispatch.MessageDispatcherConfigurator.Config"/> object, usually passed in via <see cref="P:Akka.Actor.Settings.Config"/>
            </summary>
            <param name="config">TBD</param>
            <param name="prerequisites">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcherConfigurator.Config">
            <summary>
            System-wide configuration
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcherConfigurator.Prerequisites">
            <summary>
            The system prerequisites needed for this dispatcher to do its job
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcherConfigurator.Dispatcher">
            <summary>
            Returns a <see cref="M:Akka.Dispatch.MessageDispatcherConfigurator.Dispatcher"/> instance.
            
            Whether or not this <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> returns a new instance 
            or returns a reference to an existing instance is an implementation detail of the
            underlying implementation.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcherConfigurator.ConfigureExecutor">
            <summary>
            Configures the <see cref="T:Akka.Dispatch.ExecutorServiceConfigurator"/> that will be used inside this dispatcher.
            </summary>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown if a custom ExecutorServiceConfiguration implementation cannot be loaded.
            </exception>
            <returns>The requested <see cref="T:Akka.Dispatch.ExecutorServiceConfigurator"/> instance.</returns>
        </member>
        <member name="T:Akka.Dispatch.MessageDispatcher">
            <summary>
            Class responsible for pushing messages from an actor's mailbox into its
            receive methods. Comes in many different flavors.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.MessageDispatcher.Actors">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.PrintActors">
            <summary>
            INTERNAL API - Debugging purposes only! Should be elided by compiler in release builds.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.MessageDispatcher.DefaultThroughput">
            <summary>
                The default throughput
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.Configurator">
            <summary>
            The configurator used to configure this message dispatcher.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.#ctor(Akka.Dispatch.MessageDispatcherConfigurator)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.MessageDispatcher" /> class.
            </summary>
            <param name="configurator">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.EventStream">
            <summary>
            The <see cref="P:Akka.Dispatch.MessageDispatcher.EventStream"/> for this dispatcher's actor system
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.Mailboxes">
            <summary>
            The list of available <see cref="P:Akka.Dispatch.MessageDispatcher.Mailboxes"/> for this dispatcher's actor system
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.Id">
            <summary>
            The ID for this dispatcher.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.ThroughputDeadlineTime">
            <summary>
                Gets or sets the throughput deadline time.
            </summary>
            <value>The throughput deadline time.</value>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.Throughput">
            <summary>
                Gets or sets the throughput.
            </summary>
            <value>The throughput.</value>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.ShutdownTimeout">
            <summary>
            INTERNAL API
            
            When the dispatcher no longer has any actors registered, the <see cref="P:Akka.Dispatch.MessageDispatcher.ShutdownTimeout"/> determines
            how long it will wait until it shuts itself down, defaulting to your Akka.NET config's 'akka.actor.default-dispatcher.shutdown-timeout'
            or the system default specified.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageDispatcher.Inhabitants">
            <summary>
            The number of actors attached to this <see cref="T:Akka.Dispatch.MessageDispatcher"/>
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageDispatcher.UnbatchedExecute">
            <summary>
            Used for executing arbitrary <see cref="T:Akka.Dispatch.IRunnable"/>s on this <see cref="T:Akka.Dispatch.MessageDispatcher"/>.
            
            Not used for mailbox runs.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Schedule(System.Action)">
            <summary>
                Schedules the specified delegate.
            </summary>
            <param name="run">The run.</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Schedule(Akka.Dispatch.IRunnable)">
            <summary>
            Schedules an arbitrary task to run.
            </summary>
            <param name="run">The run.</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.ExecuteTask(Akka.Dispatch.IRunnable)">
            <summary>
            Schedules the <see cref="T:Akka.Dispatch.IRunnable"/> to be executed.
            </summary>
            <param name="run">The asynchronous task we're going to run</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.ReportFailure(System.Exception)">
            <summary>
            Publish failure that occurred while inside the running <see cref="T:Akka.Dispatch.MessageDispatcher"/>
            to the <see cref="P:Akka.Dispatch.MessageDispatcher.EventStream"/>.
            </summary>
            <param name="ex">The failure to publish.</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Shutdown">
            <summary>
            INTERNAL API
            
            Called one time every time an actor is detached from this dispatcher and this dispatcher has no actors left attached
            </summary>
            <remarks>
            MUST BE IDEMPOTENT
            </remarks>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.CreateMailbox(Akka.Actor.ActorCell,Akka.Dispatch.MailboxType)">
            <summary>
            Creates and returns a <see cref="T:Akka.Dispatch.Mailbox"/> for the given actor.
            </summary>
            <param name="cell">Cell of the actor.</param>
            <param name="mailboxType">The mailbox configurator.</param>
            <returns>The configured <see cref="T:Akka.Dispatch.Mailbox"/> for this actor.</returns>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Dispatch(Akka.Actor.ActorCell,Akka.Actor.Envelope)">
            <summary>
            Dispatches a user-defined message from a mailbox to an <see cref="T:Akka.Actor.ActorCell"/>
            </summary>
            <param name="cell">TBD</param>
            <param name="envelope">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.SystemDispatch(Akka.Actor.ActorCell,Akka.Dispatch.SysMsg.SystemMessage)">
            <summary>
            Dispatches a <see cref="T:Akka.Dispatch.SysMsg.SystemMessage"/> from a mailbox to an <see cref="T:Akka.Actor.ActorCell"/>
            </summary>
            <param name="cell">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Attach(Akka.Actor.ActorCell)">
            <summary>
            Attaches the dispatcher to the <see cref="T:Akka.Actor.ActorCell"/>
            
            <remarks>
            Practically, doesn't do very much right now - dispatchers aren't responsible for creating
            mailboxes in Akka.NET
            </remarks>
            </summary>
            <param name="cell">The ActorCell belonging to the actor who's attaching to this dispatcher.</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Register(Akka.Actor.ActorCell)">
            <summary>
            INTERNAL API 
            
            If you override it, you must still call the base method. But only ever once. See <see cref="M:Akka.Dispatch.MessageDispatcher.Attach(Akka.Actor.ActorCell)"/> for only invocation.
            </summary>
            <param name="actor">The actor we're registering</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.RegisterForExecution(Akka.Dispatch.Mailbox,System.Boolean,System.Boolean)">
            <summary>
            INTERNAL API
            
            Suggest to register the provided mailbox for execution
            </summary>
            <param name="mbox">The mailbox</param>
            <param name="hasMessageHint">Do we have any messages?</param>
            <param name="hasSystemMessageHint">Do we have any system messages?</param>
            <returns><c>true</c> if the <see cref="T:Akka.Dispatch.Mailbox"/> was scheduled for execution, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Detach(Akka.Actor.ActorCell)">
            <summary>
            Detaches the dispatcher to the <see cref="T:Akka.Actor.ActorCell"/>
            
            <remarks>
            Only really used in dispatchers with 1:1 relationship with dispatcher.
            </remarks>
            </summary>
            <param name="cell">The ActorCell belonging to the actor who's detaching from this dispatcher.</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Unregister(Akka.Actor.ActorCell)">
            <summary>
            INTERNAL API
            
            If you override it, you must call it. But only ever once. See <see cref="M:Akka.Dispatch.MessageDispatcher.Detach(Akka.Actor.ActorCell)"/> for the only invocation
            </summary>
            <param name="actor">The actor who is unregistering</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Suspend(Akka.Actor.ActorCell)">
            <summary>
            After the call to this method, the dispatcher mustn't begin any new message processing for the specified reference 
            </summary>
            <param name="actorCell">The cell of the actor whose mailbox will be suspended.</param>
        </member>
        <member name="M:Akka.Dispatch.MessageDispatcher.Resume(Akka.Actor.ActorCell)">
            <summary>
            After the call to this method, the dispatcher must begin any new message processing for the specified reference
            </summary>
            <param name="actorCell">The cell of the actor whose mailbox will be resumed.</param>
        </member>
        <member name="T:Akka.Dispatch.ActorTaskScheduler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.ActorTaskScheduler.CurrentMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ActorTaskScheduler.#ctor(Akka.Actor.ActorCell)">
            <summary>
            TBD
            </summary>
            <param name="actorCell">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.ActorTaskScheduler.MaximumConcurrencyLevel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ActorTaskScheduler.GetScheduledTasks">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.ActorTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>
            TBD
            </summary>
            <param name="task">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.ActorTaskScheduler.ExecuteTask(System.Threading.Tasks.Task)">
            <summary>
            TBD
            </summary>
            <param name="task">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.ActorTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="task">TBD</param>
            <param name="taskWasPreviouslyQueued">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.ActorTaskScheduler.RunTask(System.Action)">
            <summary>
            TBD
            </summary>
            <param name="action">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.ActorTaskScheduler.RunTask(System.Func{System.Threading.Tasks.Task})">
            <summary>
            TBD
            </summary>
            <param name="asyncAction">TBD</param>
            <exception cref="T:System.InvalidOperationException">
            This exception is thrown if this method is called outside an actor context.
            </exception>
        </member>
        <member name="T:Akka.Dispatch.CachingConfig">
            <summary>
            INTERNAL API
            
            A <see cref="T:Akka.Dispatch.CachingConfig"/> is a <see cref="T:Akka.Configuration.Config"/> that wraps another <see cref="T:Akka.Configuration.Config"/> and is used to
            cache path lookup and string retrieval, which we happen to do in some critical paths of the actor creation
            and mailbox selection code.
            
            All other <see cref="T:Akka.Configuration.Config"/> operations are delegated to the wrapped <see cref="T:Akka.Configuration.Config"/>.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.CachingConfig.ValuePathEntry">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.ValuePathEntry.#ctor(System.Boolean,System.Boolean,Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="valid">TBD</param>
            <param name="exists">TBD</param>
            <param name="config">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.ValuePathEntry.#ctor(System.Boolean,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="valid">TBD</param>
            <param name="exists">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.CachingConfig.ValuePathEntry.Valid">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.CachingConfig.ValuePathEntry.Exists">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.CachingConfig.ValuePathEntry.Config">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Dispatch.CachingConfig.StringPathEntry">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.StringPathEntry.#ctor(System.Boolean,System.Boolean,Akka.Configuration.Config,System.String)">
            <summary>
            TBD
            </summary>
            <param name="valid">TBD</param>
            <param name="exists">TBD</param>
            <param name="config">TBD</param>
            <param name="value">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.CachingConfig.StringPathEntry.Valid">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.CachingConfig.StringPathEntry.Exists">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.CachingConfig.StringPathEntry.Config">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.CachingConfig.StringPathEntry.Value">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.#ctor(Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.CachingConfig.Root">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.WithFallback(Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="fallback">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.HasPath(System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.CachingConfig.IsEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.AsEnumerable">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetBoolean(System.String,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <param name="default">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetInt(System.String,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <param name="default">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetLong(System.String,System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <param name="default">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetDouble(System.String,System.Double)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <param name="default">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetString(System.String,System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <param name="default">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetDecimal(System.String,System.Decimal)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <param name="default">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetBooleanList(System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetByteList(System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetByteSize(System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetDecimalList(System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetDoubleList(System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetFloat(System.String,System.Single)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <param name="default">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetFloatList(System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetIntList(System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetLongList(System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetStringList(System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetTimeSpan(System.String,System.Nullable{System.TimeSpan},System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <param name="default">TBD</param>
            <param name="allowInfinite">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CachingConfig.GetConfig(System.String)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.CurrentSynchronizationContextExecutorServiceFactory">
            <summary>
            INTERNAL API
            
            Produces <see cref="T:Akka.Dispatch.ExecutorService"/> that dispatches messages on the current synchronization context,
             e.g. WinForms or WPF GUI thread
            </summary>
        </member>
        <member name="M:Akka.Dispatch.CurrentSynchronizationContextExecutorServiceFactory.Produce(System.String)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.CurrentSynchronizationContextExecutorServiceFactory.#ctor(Akka.Configuration.Config,Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
            <param name="prerequisites">TBD</param>
        </member>
        <member name="T:Akka.Dispatch.CurrentSynchronizationContextDispatcherConfigurator">
            <summary>
            Used to create instances of the <see cref="T:Akka.Dispatch.PinnedDispatcher"/>. 
            
            Each actor created using the pinned dispatcher gets its own unique thread.
            <remarks>
            Always returns a new instance.
            </remarks>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.CurrentSynchronizationContextDispatcherConfigurator.#ctor(Akka.Configuration.Config,Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
            <param name="prerequisites">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.CurrentSynchronizationContextDispatcherConfigurator.Dispatcher">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.CurrentSynchronizationContextDispatcher">
            <summary>
            Behaves like a <see cref="T:Akka.Dispatch.PinnedDispatcher"/> and always executes using <see cref="T:Akka.Dispatch.CurrentSynchronizationContextExecutorServiceFactory"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.CurrentSynchronizationContextDispatcher.#ctor(Akka.Dispatch.MessageDispatcherConfigurator,System.String,System.Int32,System.Nullable{System.Int64},Akka.Dispatch.ExecutorServiceFactory,System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="configurator">TBD</param>
            <param name="id">TBD</param>
            <param name="throughput">TBD</param>
            <param name="throughputDeadlineTime">TBD</param>
            <param name="executorServiceFactory">TBD</param>
            <param name="shutdownTimeout">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.CurrentSynchronizationContextDispatcher.Register(Akka.Actor.ActorCell)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <exception cref="T:System.InvalidOperationException">
            This exception is thrown if the registering <paramref name="actor"/> is not the <see cref="F:Akka.Dispatch.CurrentSynchronizationContextDispatcher._owner">owner</see>.
            </exception>
        </member>
        <member name="M:Akka.Dispatch.CurrentSynchronizationContextDispatcher.Unregister(Akka.Actor.ActorCell)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
        </member>
        <member name="T:Akka.Dispatch.Dispatcher">
            <summary>
            The event-based <see cref="T:Akka.Dispatch.Dispatcher"/> binds a set of actors to a thread pool backed up
            by a thread-safe queue.
            
            The preferred way of creating dispatchers is to define them in configuration and use the 
            <see cref="M:Akka.Dispatch.Dispatchers.Lookup(System.String)"/> method.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Dispatcher.#ctor(Akka.Dispatch.MessageDispatcherConfigurator,System.String,System.Int32,System.Nullable{System.Int64},Akka.Dispatch.ExecutorServiceFactory,System.TimeSpan)">
            <summary>
            Used to create a default <see cref="T:Akka.Dispatch.Dispatcher"/>
            </summary>
            <param name="configurator">The configurator used.</param>
            <param name="id">The id of this dispatcher.</param>
            <param name="throughput">The throughput of this dispatcher.</param>
            <param name="throughputDeadlineTime">The deadline for completing N (where N = throughput) operations on the mailbox..</param>
            <param name="executorServiceFactory">The factory for producing the executor who will do the work.</param>
            <param name="shutdownTimeout">The graceful stop timeout period.</param>
        </member>
        <member name="M:Akka.Dispatch.Dispatcher.ExecuteTask(Akka.Dispatch.IRunnable)">
            <summary>
            Schedules the <see cref="T:Akka.Dispatch.IRunnable"/> to be executed.
            </summary>
            <param name="run">The asynchronous task we're going to run</param>
        </member>
        <member name="M:Akka.Dispatch.Dispatcher.Shutdown">
            <summary>
            INTERNAL API
            
            Called one time every time an actor is detached from this dispatcher and this dispatcher has no actors left attached
            </summary>
            <remarks>
            MUST BE IDEMPOTENT
            </remarks>
        </member>
        <member name="T:Akka.Dispatch.ThreadPoolExecutorService">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Dispatch.ThreadPoolExecutorService.Executor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ThreadPoolExecutorService.Shutdown">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ThreadPoolExecutorService.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
        </member>
        <member name="T:Akka.Dispatch.FullThreadPoolExecutorServiceImpl">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Dispatch.FullThreadPoolExecutorServiceImpl.Execute(Akka.Dispatch.IRunnable)">
            <summary>
            TBD
            </summary>
            <param name="run">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.FullThreadPoolExecutorServiceImpl.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
        </member>
        <member name="T:Akka.Dispatch.PartialTrustThreadPoolExecutorService">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Dispatch.PartialTrustThreadPoolExecutorService.Execute(Akka.Dispatch.IRunnable)">
            <summary>
            TBD
            </summary>
            <param name="run">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.PartialTrustThreadPoolExecutorService.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
        </member>
        <member name="T:Akka.Dispatch.TaskSchedulerExecutor">
            <summary>
            INTERNAL API
            
            Executes its tasks using the <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
        </member>
        <member name="F:Akka.Dispatch.TaskSchedulerExecutor._scheduler">
            <summary>
                The scheduler
            </summary>
        </member>
        <member name="M:Akka.Dispatch.TaskSchedulerExecutor.#ctor(System.String,System.Threading.Tasks.TaskScheduler)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <param name="scheduler">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.TaskSchedulerExecutor.Execute(Akka.Dispatch.IRunnable)">
            <summary>
            TBD
            </summary>
            <param name="run">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.TaskSchedulerExecutor.Shutdown">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ForkJoinExecutor">
            <summary>
            ForkJoinExecutorService - custom multi-threaded dispatcher that runs on top of a 
            <see cref="T:Helios.Concurrency.DedicatedThreadPool"/>, designed to be used for mission-critical actors
            that can't afford <see cref="T:System.Threading.ThreadPool"/> starvation.
            
            Relevant configuration options:
            <code>
                my-forkjoin-dispatcher {
                    type = ForkJoinDispatcher
                    throughput = 100
                    dedicated-thread-pool { #settings for Helios.DedicatedThreadPool
                        thread-count = 3 #number of threads
                        #deadlock-timeout = 3s #optional timeout for deadlock detection
                        threadtype = background #values can be "background" or "foreground"
                    }
                }
            </code>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ForkJoinExecutor.#ctor(System.String,Helios.Concurrency.DedicatedThreadPoolSettings)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <param name="poolSettings">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.ForkJoinExecutor.Execute(Akka.Dispatch.IRunnable)">
            <summary>
            TBD
            </summary>
            <param name="run">TBD</param>
            <exception cref="T:Akka.Dispatch.RejectedExecutionException">
            This exception is thrown if this method is called during the shutdown of this executor.
            </exception>
        </member>
        <member name="M:Akka.Dispatch.ForkJoinExecutor.Shutdown">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Dispatch.Dispatchers">
            <summary>
            The registry of all <see cref="T:Akka.Dispatch.MessageDispatcher"/> instances available to this <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Dispatchers.DefaultDispatcherId">
            <summary>
                The default dispatcher identifier, also the full key of the configuration of the default dispatcher.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Dispatchers.SynchronizedDispatcherId">
            <summary>
                The identifier for synchronized dispatchers.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Dispatchers._dispatcherConfigurators">
            <summary>
            The list of all configurators used to create <see cref="T:Akka.Dispatch.MessageDispatcher"/> instances.
            
            Has to be thread-safe, as this collection can be accessed concurrently by many actors.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.#ctor(Akka.Actor.ActorSystem,Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>Initializes a new instance of the <see cref="T:Akka.Dispatch.Dispatchers" /> class.</summary>
            <param name="system">The system.</param>
            <param name="prerequisites">The prerequisites required for some <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> instances.</param>
        </member>
        <member name="P:Akka.Dispatch.Dispatchers.DefaultGlobalDispatcher">
            <summary>Gets the one and only default dispatcher.</summary>
        </member>
        <member name="P:Akka.Dispatch.Dispatchers.DefaultDispatcherConfig">
            <summary>
            The <see cref="T:Akka.Configuration.Config"/> for the default dispatcher.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.ReloadPrerequisites(Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>
            INTERNAL API
            
            Used when a plugin like Akka.Persistence needs to be able to load dispatcher configurations to the chain.
            </summary>
            <param name="prerequisites">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.Dispatchers.Prerequisites">
            <summary>
            The prerequisites required for some <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> instances.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.Lookup(System.String)">
            <summary>
            Returns a dispatcher as specified in configuration. Please note that this method _MAY_
            create and return a new dispatcher on _EVERY_ call.
            </summary>
            <param name="dispatcherName">TBD</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown if the specified dispatcher cannot be found in the configuration.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.HasDispatcher(System.String)">
            <summary>
            Checks that configuration provides a section for the given dispatcher.
            This does not guarantee that no <see cref="T:Akka.Configuration.ConfigurationException"/> will be thrown
            when using the dispatcher, because the details can only be checked by trying to
            instantiate it, which might be undesirable when just checking.
            </summary>
            <param name="id">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.From(Akka.Configuration.Config)">
            <summary>
            INTERNAL API
            
            Creates a dispatcher from a <see cref="T:Akka.Configuration.Config"/>. Internal test purpose only.
            <code>
            From(Config.GetConfig(id));
            </code>
            
            The Config must also contain an `id` property, which is the identifier of the dispatcher.
            </summary>
            <param name="cfg">The provided configuration section.</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown if the specified dispatcher cannot be found in <paramref name="cfg"/>.
            It can also be thrown if the dispatcher path or type cannot be resolved.
            </exception>
            <returns>An instance of the <see cref="T:Akka.Dispatch.MessageDispatcher"/>, if valid.</returns>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.RegisterConfigurator(System.String,Akka.Dispatch.MessageDispatcherConfigurator)">
            <summary>
            Register a <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> that will be used by <see cref="M:Akka.Dispatch.Dispatchers.Lookup(System.String)"/>
            and <see cref="M:Akka.Dispatch.Dispatchers.HasDispatcher(System.String)"/> instead of looking up the configurator from the system
            configuration.
            
            This enables dynamic addition of dispatchers.
            
            <remarks>
            A <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> for a certain id can only be registered once,
            i.e. it can not be replaced. It is safe to call this method multiple times, but only the
            first registration will be used.
            </remarks>
            </summary>
            <param name="id">TBD</param>
            <param name="configurator">TBD</param>
            <returns>This method returns <c>true</c> if the specified configurator was successfully registered.</returns>
        </member>
        <member name="M:Akka.Dispatch.Dispatchers.Config(System.String)">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="T:Akka.Dispatch.DispatcherConfigurator">
            <summary>
            The cached <see cref="T:Akka.Dispatch.MessageDispatcher"/> factory that gets looked up via configuration
            inside <see cref="T:Akka.Dispatch.Dispatchers"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.DispatcherConfigurator.#ctor(Akka.Configuration.Config,Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>
            Used to configure and produce <see cref="M:Akka.Dispatch.DispatcherConfigurator.Dispatcher"/> instances for use with actors.
            </summary>
            <param name="config">The configuration for this dispatcher.</param>
            <param name="prerequisites">System pre-reqs needed to run this dispatcher.</param>
        </member>
        <member name="M:Akka.Dispatch.DispatcherConfigurator.Dispatcher">
            <summary>
            Returns a <see cref="M:Akka.Dispatch.MessageDispatcherConfigurator.Dispatcher"/> instance.
            
            Whether or not this <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/> returns a new instance 
            or returns a reference to an existing instance is an implementation detail of the
            underlying implementation.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.ExecutorService">
            <summary>
            Used by the <see cref="T:Akka.Dispatch.Dispatcher"/> to execute asynchronous invocations
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ExecutorService.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.ExecutorService.Id">
            <summary>
            The Id of the <see cref="T:Akka.Dispatch.MessageDispatcher"/> this executor is bound to
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ExecutorService.Execute(Akka.Dispatch.IRunnable)">
            <summary>
            Queues or executes (depending on the implementation) the <see cref="T:Akka.Dispatch.IRunnable"/>
            </summary>
            <param name="run">The asynchronous task to be executed</param>
            <exception cref="T:Akka.Dispatch.RejectedExecutionException">Thrown when the service can't accept additional tasks.</exception>
        </member>
        <member name="M:Akka.Dispatch.ExecutorService.Shutdown">
            <summary>
            Terminates this <see cref="T:Akka.Dispatch.ExecutorService"/> instance.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ExecutorServiceFactory">
            <summary>
            INTERNAL API
            
            Used to produce <see cref="T:Akka.Dispatch.ExecutorServiceFactory"/> instances for use inside <see cref="T:Akka.Dispatch.Dispatcher"/>s
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ExecutorServiceFactory.Produce(System.String)">
            <summary>
            TBD
            </summary>
            <param name="id">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.RejectedExecutionException">
            <summary>
            Thrown when a <see cref="T:Akka.Dispatch.ExecutorService"/> implementation rejects
            </summary>
        </member>
        <member name="M:Akka.Dispatch.RejectedExecutionException.#ctor(System.String,System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="inner">TBD</param>
        </member>
        <member name="T:Akka.Dispatch.FutureActor">
            <summary>
                Class FutureActor.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.FutureActor.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.FutureActor" /> class.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.FutureActor.#ctor(System.Threading.Tasks.TaskCompletionSource{System.Object},Akka.Actor.IActorRef)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.FutureActor" /> class.
            </summary>
            <param name="completionSource">The completion source.</param>
            <param name="respondTo">The respond to.</param>
        </member>
        <member name="M:Akka.Dispatch.FutureActor.Receive(System.Object)">
            <summary>
                Processor for user defined messages.
            </summary>
            <param name="message">The message.</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.IRequiresMessageQueue`1">
            <summary>
            Used to help give hints to the <see cref="T:Akka.Actor.ActorSystem"/> as to what types of <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/> this
            actor requires. Used mostly for system actors.
            </summary>
            <typeparam name="T">The type of <see cref="T:Akka.Dispatch.ISemantics"/> required</typeparam>
        </member>
        <member name="T:Akka.Dispatch.IRunnable">
            <summary>
            An asynchronous opreation will be executed by a <see cref="T:Akka.Dispatch.MessageDispatcher"/>.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.IRunnable.Run">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ActionRunnable">
            <summary>
            <see cref="T:Akka.Dispatch.IRunnable"/> which executes an <see cref="T:System.Action"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ActionRunnable.#ctor(System.Action)">
            <summary>
            TBD
            </summary>
            <param name="action">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.ActionRunnable.Run">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ActionWithStateRunnable">
            <summary>
            <see cref="T:Akka.Dispatch.IRunnable"/> which executes an <see cref="T:System.Action`1"/> and an <see cref="T:System.Object"/> representing the state.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ActionWithStateRunnable.#ctor(System.Action{System.Object},System.Object)">
            <summary>
            TBD
            </summary>
            <param name="actionWithState">TBD</param>
            <param name="state">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.ActionWithStateRunnable.Run">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ISemantics">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IMultipleConsumerSemantics">
            <summary> 
            Semantics for message queues that support multiple consumers 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IUnboundedMessageQueueSemantics">
            <summary> 
            Semantics for message queues that have an unbounded size 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IBoundedMessageQueueSemantics">
            <summary> 
            Semantics for message queues that have a bounded size 
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IBoundedMessageQueueSemantics.PushTimeOut">
            <summary> 
            The enqueue time to wait until message is dropped to deadletters if the message queue is full 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IBlockingMessageQueueSemantics">
            <summary> 
            Semantics for message queues that are blocking 
            </summary>
        </member>
        <member name="P:Akka.Dispatch.IBlockingMessageQueueSemantics.BlockTimeOut">
            <summary> 
            The time to wait on a lock before throwing an timeout exception. 
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IDequeBasedMessageQueueSemantics">
            <summary>
            Semantics for message queues that are Double-Ended.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.IDequeBasedMessageQueueSemantics.EnqueueFirst(Akka.Actor.Envelope)">
            <summary>
            TBD
            </summary>
            <param name="envelope">TBD</param>
        </member>
        <member name="T:Akka.Dispatch.IUnboundedDequeBasedMessageQueueSemantics">
            <summary>
            Semantics for message queues that are Double-Ended and unbounded
            </summary>
        </member>
        <member name="T:Akka.Dispatch.IBoundedDequeBasedMessageQueueSemantics">
            <summary>
            Semantics for message queues that are Double-Ended and bounded
            </summary>
        </member>
        <member name="T:Akka.Dispatch.Mailbox">
            <summary>
            Mailbox base class
            </summary>
        </member>
        <member name="T:Akka.Dispatch.Mailbox.MailboxStatus">
            <summary>
             Status codes for the state of the mailbox
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.MailboxStatus.Open">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.MailboxStatus.Closed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.MailboxStatus.Scheduled">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.MailboxStatus.ShouldScheduleMask">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.MailboxStatus.ShouldNotProcessMask">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.MailboxStatus.SuspendMask">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.MailboxStatus.SuspendUnit">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailbox.MailboxStatus.SuspendAwaitTask">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.Mailbox.MessageQueue">
            <summary>
            The queue used for user-defined messages inside this mailbox
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.#ctor(Akka.Dispatch.MessageQueues.IMessageQueue)">
            <summary>
            Creates a new mailbox
            </summary>
            <param name="messageQueue">The <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/> used by this mailbox.</param>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.Enqueue(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <summary>
                Posts the specified envelope to the mailbox.
            </summary>
            <param name="receiver">TBD</param>
            <param name="envelope">The envelope.</param>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.TryDequeue(Akka.Actor.Envelope@)">
            <summary>
            TBD
            </summary>
            <param name="msg">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Dispatch.Mailbox.HasMessages">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.Mailbox.NumberOfMessages">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.Mailbox.SystemQueue">
            <summary>
            Atomic reader for the system message queue
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.SystemQueuePut(Akka.Dispatch.SysMsg.LatestFirstSystemMessageList,Akka.Dispatch.SysMsg.LatestFirstSystemMessageList)">
            <summary>
            TBD
            </summary>
            <param name="old">TBD</param>
            <param name="newQueue">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.CanBeScheduledForExecution(System.Boolean,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="hasMessageHint">TBD</param>
            <param name="hasSystemMessageHint">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Dispatch.Mailbox.Dispatcher">
            <summary>
            The <see cref="T:Akka.Dispatch.MessageDispatcher"/> for the underlying mailbox.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.Mailbox.Actor">
            <summary>
            INTERNAL API
            
            <see cref="P:Akka.Dispatch.Mailbox.Actor"/> must not be visible to user-defined implementations
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.SetActor(Akka.Actor.ActorCell)">
            <summary>
                Attaches an ActorCell to the Mailbox.
            </summary>
            <param name="actorCell">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.CurrentStatus">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.ShouldProcessMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.SuspendCount">
            <summary>
            Returns the number of times this mailbox is currently suspended.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.IsSuspended">
            <summary>
            Returns <c>true</c> if the mailbox is currently suspended from processing. <c>false</c> otherwise.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.IsClosed">
            <summary>
            Returns <c>true</c> if the mailbox is closed. <c>false</c> otherwise.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.IsScheduled">
            <summary>
            Returns <c>true</c> if the mailbox is scheduled for execution on a <see cref="P:Akka.Dispatch.Mailbox.Dispatcher"/>. <c>false</c> otherwise.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.UpdateStatus(System.Int32,System.Int32)">
            <summary>
            Updates the status of the current mailbox.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.SetStatus(System.Int32)">
            <summary>
            Forcefully sets the status of the current mailbox.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.Resume">
            <summary>
            Reduce the suspend count by one. Caller does not need to worry about whether
            status was <see cref="F:Akka.Dispatch.Mailbox.MailboxStatus.Scheduled"/> or not.
            </summary>
            <returns><c>true</c> if the suspend count reached zero.</returns>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.Suspend">
            <summary>
            Increment the suspend count by one. Caller does not need to worry about whether
            status was <see cref="F:Akka.Dispatch.Mailbox.MailboxStatus.Scheduled"/> or not.
            </summary>
            <returns><c>true</c> if the previous suspend count was zero.</returns>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.BecomeClosed">
            <summary>
             Set the new primary status to <see cref="F:Akka.Dispatch.Mailbox.MailboxStatus.Closed"/>.
            </summary>
            <returns><c>true</c> if we were able to successfully close the mailbox. <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.SetAsScheduled">
            <summary>
            Set scheduled status, keeping primary status as-is.
            </summary>
            <returns>Returns <c>true</c> if the set operation succeeded. <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.SetAsIdle">
            <summary>
            Reset Scheduled status, keeping primary status as-is
            </summary>
            <returns>Returns <c>true</c> if the set operation succeeded. <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.Run">
            <summary>
            Processes the contents of the mailbox
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.ProcessAllSystemMessages">
            <summary>
            Will at least try to process all queued system messages: in case of
            failure simply drop and go on to the next, because there is nothing to
            restart here (failure is in <see cref="T:Akka.Actor.ActorCell"/> somewhere ). In case the mailbox
            becomes closed (because of processing a <see cref="T:Akka.Dispatch.SysMsg.Terminate"/> message), dump all
            already dequeued message to deadLetters. 
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.CleanUp">
            <summary>
            Overrideable callback to clean up the mailbox, called
            when an actor is unregistered.
            
            By default it dequeues all system messages + messages and ships them to the owning actor's systems' <see cref="T:Akka.Actor.DeadLetterMailbox"/>.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.SystemEnqueue(Akka.Actor.IActorRef,Akka.Dispatch.SysMsg.SystemMessage)">
            <summary>
            Enqueues a new <see cref="T:Akka.Dispatch.SysMsg.ISystemMessage"/> into the <see cref="T:Akka.Dispatch.Mailbox"/> for a given actor.
            </summary>
            <param name="receiver">The actor who will receive the system message.</param>
            <param name="message">The system message.</param>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.SystemDrain(Akka.Dispatch.SysMsg.LatestFirstSystemMessageList)">
            <summary>
            Drains <see cref="T:Akka.Dispatch.SysMsg.ISystemMessage"/> from this mailbox.
            </summary>
            <param name="newContents">The replacement queue for the system messages inside this mailbox.</param>
        </member>
        <member name="P:Akka.Dispatch.Mailbox.HasSystemMessages">
            <summary>
            Returns <c>true</c> if there are <see cref="T:Akka.Dispatch.SysMsg.ISystemMessage"/> instances inside this mailbox.
            <c>false</c> otherwise.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailbox.DebugPrint(System.String,System.Object[])">
            <summary>
            Prints a message tosStandard out if the Compile symbol "MAILBOXDEBUG" has been set.
            If the symbol is not set all invocations to this method will be removed by the compiler.
            </summary>
            <param name="message">TBD</param>
            <param name="args">TBD</param>
        </member>
        <member name="T:Akka.Dispatch.MailboxType">
            <summary>
            A factory to create <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>s for an optionally provided <see cref="T:Akka.Actor.IActorContext"/>.
            </summary>
            <remarks>
            Possibily important notice.
            
            When implementing a custom MailboxType, be aware that there is special semantics attached to
            <see cref="M:Akka.Actor.ActorSystem.ActorOf(Akka.Actor.Props,System.String)"/> in that sending the returned <see cref="T:Akka.Actor.IActorRef"/> may, for a short
            period of time, enqueue the messages first in a dummy queue. Top-level actors are created in two steps, and only
            after the guardian actor ahs performed that second step will all previously sent messages be transferred from the
            dummy queue to the real mailbox.
            
            Implemented as an abstract class in order to enforce constructor requirements.
            </remarks>
        </member>
        <member name="F:Akka.Dispatch.MailboxType.Settings">
            <summary>
            The settings for the given <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.MailboxType.Config">
            <summary>
            The configuration for this mailbox.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MailboxType.#ctor(Akka.Actor.Settings,Akka.Configuration.Config)">
            <summary>
            Constructor used for creating a <see cref="T:Akka.Dispatch.MailboxType"/>
            </summary>
            <param name="settings">The <see cref="P:Akka.Actor.ActorSystem.Settings"/> for this system.</param>
            <param name="config">The <see cref="F:Akka.Dispatch.MailboxType.Config"/> for this mailbox.</param>
        </member>
        <member name="M:Akka.Dispatch.MailboxType.Create(Akka.Actor.IActorRef,Akka.Actor.ActorSystem)">
            <summary>
            Creates a new <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/> from the specified parameters.
            </summary>
            <param name="owner">Optional.</param>
            <param name="system">Optional.</param>
            <returns>The resulting <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/></returns>
        </member>
        <member name="T:Akka.Dispatch.IProducesMessageQueue`1">
            <summary>
            Compilment to <see cref="T:Akka.Dispatch.IRequiresMessageQueue`1"/>
            </summary>
            <typeparam name="TQueue">The type of <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/> produced by this class.</typeparam>
        </member>
        <member name="T:Akka.Dispatch.UnboundedMailbox">
            <summary>
            UnboundedMailbox is the default <see cref="T:Akka.Dispatch.MailboxType"/> used by Akka.NET Actors
            </summary>
        </member>
        <member name="M:Akka.Dispatch.UnboundedMailbox.Create(Akka.Actor.IActorRef,Akka.Actor.ActorSystem)">
            <inheritdoc cref="T:Akka.Dispatch.MailboxType"/>
        </member>
        <member name="M:Akka.Dispatch.UnboundedMailbox.#ctor">
            <summary>
            Default constructor for an unbounded mailbox.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.UnboundedMailbox.#ctor(Akka.Actor.Settings,Akka.Configuration.Config)">
            <inheritdoc cref="T:Akka.Dispatch.MailboxType"/>
        </member>
        <member name="T:Akka.Dispatch.BoundedMailbox">
            <summary>
            The default bounded mailbox implementation
            </summary>
        </member>
        <member name="P:Akka.Dispatch.BoundedMailbox.Capacity">
            <summary>
            The capacity of this mailbox.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.BoundedMailbox.PushTimeout">
            <summary>
            The push timeout value. Will throw a timeout error after this period of time
            </summary>
        </member>
        <member name="M:Akka.Dispatch.BoundedMailbox.#ctor(Akka.Actor.Settings,Akka.Configuration.Config)">
            <inheritdoc cref="T:Akka.Dispatch.MailboxType"/>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the 'mailbox-capacity' in <paramref name="config"/>
            or the 'mailbox-push-timeout-time' in <paramref name="config"/> is negative.
            </exception>
        </member>
        <member name="M:Akka.Dispatch.BoundedMailbox.Create(Akka.Actor.IActorRef,Akka.Actor.ActorSystem)">
            <inheritdoc cref="T:Akka.Dispatch.MailboxType"/>
        </member>
        <member name="T:Akka.Dispatch.UnboundedPriorityMailbox">
            <summary>
            Priority mailbox base class; unbounded mailbox that allows for prioritization of its contents.
            Extend this class and implement the <see cref="M:Akka.Dispatch.UnboundedPriorityMailbox.PriorityGenerator(System.Object)"/> method with your own prioritization.
            The value returned by the <see cref="M:Akka.Dispatch.UnboundedPriorityMailbox.PriorityGenerator(System.Object)"/> method will be used to order the message in the mailbox.
            Lower values will be delivered first. Messages ordered by the same number will remain in delivery order.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.UnboundedPriorityMailbox.PriorityGenerator(System.Object)">
            <summary>
            Function responsible for generating the priority value of a message based on its type and content.
            </summary>
            <param name="message">The message to inspect.</param>
            <returns>An integer. The lower the value, the higher the priority.</returns>
        </member>
        <member name="P:Akka.Dispatch.UnboundedPriorityMailbox.InitialCapacity">
            <summary>
            The initial capacity of the unbounded mailbox.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.UnboundedPriorityMailbox.DefaultCapacity">
            <summary>
            The default capacity of an unbounded priority mailbox.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.UnboundedPriorityMailbox.Create(Akka.Actor.IActorRef,Akka.Actor.ActorSystem)">
            <inheritdoc cref="T:Akka.Dispatch.MailboxType"/>
        </member>
        <member name="M:Akka.Dispatch.UnboundedPriorityMailbox.#ctor(Akka.Actor.Settings,Akka.Configuration.Config)">
            <inheritdoc cref="T:Akka.Dispatch.MailboxType"/>
        </member>
        <member name="T:Akka.Dispatch.UnboundedDequeBasedMailbox">
            <summary>
            UnboundedDequeBasedMailbox is an unbounded <see cref="T:Akka.Dispatch.MailboxType"/> backed by a double-ended queue. Used for stashing.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.UnboundedDequeBasedMailbox.#ctor(Akka.Actor.Settings,Akka.Configuration.Config)">
            <inheritdoc cref="T:Akka.Dispatch.MailboxType"/>
        </member>
        <member name="M:Akka.Dispatch.UnboundedDequeBasedMailbox.Create(Akka.Actor.IActorRef,Akka.Actor.ActorSystem)">
            <inheritdoc cref="T:Akka.Dispatch.MailboxType"/>
        </member>
        <member name="T:Akka.Dispatch.BoundedDequeBasedMailbox">
            <summary>
            BoundedDequeBasedMailbox is an bounded <see cref="T:Akka.Dispatch.MailboxType"/> backed by a double-ended queue. Used for stashing.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.BoundedDequeBasedMailbox.Capacity">
            <summary>
            The capacity of this mailbox.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.BoundedDequeBasedMailbox.PushTimeout">
            <summary>
            The push timeout. Fires a <see cref="T:System.TimeoutException"/> if it takes longer than this to add a message to
            a full bounded mailbox.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.BoundedDequeBasedMailbox.#ctor(Akka.Actor.Settings,Akka.Configuration.Config)">
            <inheritdoc cref="T:Akka.Dispatch.MailboxType"/>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the 'mailbox-capacity' in <paramref name="config"/>
            or the 'mailbox-push-timeout-time' in <paramref name="config"/> is negative.
            </exception>
        </member>
        <member name="M:Akka.Dispatch.BoundedDequeBasedMailbox.Create(Akka.Actor.IActorRef,Akka.Actor.ActorSystem)">
            <inheritdoc cref="T:Akka.Dispatch.MailboxType"/>
        </member>
        <member name="T:Akka.Dispatch.Mailboxes">
            <summary>
            Contains the directory of all <see cref="T:Akka.Dispatch.MailboxType"/>s registered and configured with a given <see cref="T:Akka.Actor.ActorSystem"/>.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailboxes._system">
            <summary>
                The system
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailboxes.DefaultMailboxId">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Dispatch.Mailboxes.NoMailboxRequirement">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailboxes.#ctor(Akka.Actor.ActorSystem)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.Mailboxes" /> class.
            </summary>
            <param name="system">The system.</param>
        </member>
        <member name="P:Akka.Dispatch.Mailboxes.DeadLetterMailbox">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.Mailboxes.HasRequiredType(System.Type)">
            <summary>
            Check if this actor class can have a required message queue type.
            </summary>
            <param name="actorType">The type to check.</param>
            <returns><c>true</c> if this actor has a message queue type requirement. <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Dispatch.Mailboxes.ProducesMessageQueue(System.Type)">
            <summary>
            Check if this <see cref="T:Akka.Dispatch.MailboxType"/> implements the <see cref="T:Akka.Dispatch.IProducesMessageQueue`1"/> interface.
            </summary>
            <param name="mailboxType">The type of the <see cref="T:Akka.Dispatch.MailboxType"/> to check.</param>
            <returns><c>true</c> if this mailboxtype produces queues. <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Dispatch.Mailboxes.LookupByQueueType(System.Type)">
            <summary>
            Returns a <see cref="T:Akka.Dispatch.MailboxType"/> as specified in configuration, based on the type, or if not defined null.
            </summary>
            <param name="queueType">The mailbox we need given the queue requirements.</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">This exception is thrown if a mapping is not configured for the given <paramref name="queueType"/>.</exception>
            <returns>A <see cref="T:Akka.Dispatch.MailboxType"/> as specified in configuration, based on the type, or if not defined null.</returns>
        </member>
        <member name="M:Akka.Dispatch.Mailboxes.Lookup(System.String)">
            <summary>
            Returns a <see cref="T:Akka.Dispatch.MailboxType"/> as specified in configuration, based on the id, or if not defined null.
            </summary>
            <param name="id">The ID of the mailbox to lookup</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown if the mailbox type is not configured or the system could not load or find the type specified.
            </exception>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the mailbox type could not be instantiated.
            </exception>
            <returns>The <see cref="T:Akka.Dispatch.MailboxType"/> specified in configuration or if not defined null.</returns>
        </member>
        <member name="M:Akka.Dispatch.Mailboxes.Config(System.String)">
            <summary>
            INTERNAL API
            </summary>
            <param name="id">The id of the mailbox whose config we're going to generate.</param>
            <returns>A <see cref="M:Akka.Dispatch.Mailboxes.Config(System.String)"/> object for the mailbox with <paramref name="id"/></returns>
        </member>
        <member name="M:Akka.Dispatch.Mailboxes.GetRequiredType(System.Type)">
            <summary>
            TBD
            </summary>
            <param name="actorType">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.Mailboxes.GetMailboxType(Akka.Actor.Props,Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="props">TBD</param>
            <param name="dispatcherConfig">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the 'mailbox-requirement' in the given <paramref name="dispatcherConfig"/> isn't met.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.Mailboxes.FromConfig(System.String)">
            <summary>
            Creates a mailbox from a configuration path.
            </summary>
            <param name="path">The path.</param>
            <returns>Mailbox.</returns>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.BlockingMessageQueue">
            <summary> 
            Base class for blocking message queues. Allows non thread safe data structures to be used as message queues. 
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.BlockingMessageQueue.LockedCount">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.BlockingMessageQueue.BlockTimeOut">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.BlockingMessageQueue.HasMessages">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.BlockingMessageQueue.Count">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.BlockingMessageQueue.Enqueue(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <summary>
            TBD
            </summary>
            <param name="receiver">TBD</param>
            <param name="envelope">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.BlockingMessageQueue.TryDequeue(Akka.Actor.Envelope@)">
            <summary>
            TBD
            </summary>
            <param name="envelope">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.BlockingMessageQueue.CleanUp(Akka.Actor.IActorRef,Akka.Dispatch.MessageQueues.IMessageQueue)">
            <summary>
            TBD
            </summary>
            <param name="owner">TBD</param>
            <param name="deadletters">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.BlockingMessageQueue.LockedEnqueue(Akka.Actor.Envelope)">
            <summary>
            TBD
            </summary>
            <param name="envelope">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.BlockingMessageQueue.LockedTryDequeue(Akka.Actor.Envelope@)">
            <summary>
            TBD
            </summary>
            <param name="envelope">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.BoundedMessageQueue">
            <summary>An Bounded mailbox message queue.</summary>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.BoundedMessageQueue.#ctor(Akka.Configuration.Config)">
            <summary>
            Creates a new bounded message queue.
            </summary>
            <param name="config">The configuration for this mailbox.</param>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.BoundedMessageQueue.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Dispatch.MessageQueues.BoundedMessageQueue"/> class.
            </summary>
            <param name="boundedCapacity">TBD</param>
            <param name="pushTimeOut">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the given <paramref name="boundedCapacity"/> is negative.
            </exception>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.BoundedMessageQueue.HasMessages">
            <inheritdoc cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.BoundedMessageQueue.Count">
            <inheritdoc cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.BoundedMessageQueue.Enqueue(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <inheritdoc cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.BoundedMessageQueue.TryDequeue(Akka.Actor.Envelope@)">
            <inheritdoc cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.BoundedMessageQueue.CleanUp(Akka.Actor.IActorRef,Akka.Dispatch.MessageQueues.IMessageQueue)">
            <inheritdoc cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.BoundedMessageQueue.PushTimeOut">
            <summary>
            The push timeout for this bounded queue.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue">
            <summary>
            Message queue for supporting <see cref="T:Akka.Dispatch.IDequeBasedMessageQueueSemantics"/> within <see cref="T:Akka.Dispatch.Mailbox"/> instances.
            
            Uses a <see cref="T:System.Collections.Generic.Stack`1"/> internally - each individual <see cref="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.EnqueueFirst(Akka.Actor.Envelope)"/>
            </summary>
        </member>
        <member name="F:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.MessageQueue">
            <summary>
            The underlying <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.#ctor(Akka.Dispatch.MessageQueues.IMessageQueue)">
            <summary>
            Takes another <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/> as an argument - wraps <paramref name="messageQueue"/>
            in order to provide it with prepend (<see cref="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.EnqueueFirst(Akka.Actor.Envelope)"/>) semantics.
            </summary>
            <param name="messageQueue">The underlying message queue wrapped by this one.</param>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.HasMessages">
            <summary>
            Returns true if there are any messages inside the queue.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.Count">
            <summary>
            Returns the number of messages in both the internal message queue
            and the prepend buffer.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.Enqueue(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <inheritdoc cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.TryDequeue(Akka.Actor.Envelope@)">
            <summary>
            Attempt to dequeue a message from the front of the prepend buffer.
            
            If the prepend buffer is empty, dequeue a message from the normal
            <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/> wrapped but this wrapper.
            </summary>
            <param name="envelope">The message to return, if any</param>
            <returns><c>true</c> if a message was available, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.CleanUp(Akka.Actor.IActorRef,Akka.Dispatch.MessageQueues.IMessageQueue)">
            <inheritdoc cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.DequeWrapperMessageQueue.EnqueueFirst(Akka.Actor.Envelope)">
            <summary>
            Add a message to the front of the queue via the prepend buffer.
            </summary>
            <param name="envelope">The message we wish to append to the front of the queue.</param>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.IMessageQueue">
            <summary> 
            Interface to be implemented by all mailbox message queues 
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.IMessageQueue.HasMessages">
            <summary> 
            Tests if the message queue contains any messages 
            </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.IMessageQueue.Count">
            <summary> 
            Returns the count of messages currently in the message queue 
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.IMessageQueue.Enqueue(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <summary> 
            Enqueues an mailbox envelope onto the message queue 
            </summary>
            <param name="receiver">
            The receiver of the messages.
            
            This field is only used in a couple of places, but it should not be removed.
            </param>
            <param name="envelope"> The envelope to enqueue </param>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.IMessageQueue.TryDequeue(Akka.Actor.Envelope@)">
            <summary> 
            Tries to pull an envelope of the message queue 
            </summary>
            <param name="envelope"> The envelope that was dequeued </param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.IMessageQueue.CleanUp(Akka.Actor.IActorRef,Akka.Dispatch.MessageQueues.IMessageQueue)">
            <summary>
            Called when the <see cref="T:Akka.Dispatch.Mailbox"/> this queue belongs to is disposed of. Normally
            it is expected to transfer all remaining messages into the deadletter queue which is passed in. The owner
            of this <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/> is passed in if available (e.g. for creating <see cref="T:Akka.Event.DeadLetter"/>s),
            "/deadletters" otherwise.
            </summary>
            <param name="owner">The owner of this message queue if available, "/deadletters" otherwise.</param>
            <param name="deadletters">The dead letters message queue.</param>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.UnboundedDequeMessageQueue">
            <summary>
            An unbounded double-ended queue. Used in combination with <see cref="T:Akka.Actor.IStash"/>.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.UnboundedDequeMessageQueue.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.BoundedDequeMessageQueue">
            <summary>
            A bounded double-ended queue. Used in combination with <see cref="T:Akka.Actor.IStash"/>.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.BoundedDequeMessageQueue.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="boundedCapacity">TBD</param>
            <param name="pushTimeOut">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.BoundedDequeMessageQueue.PushTimeOut">
            <summary>
            Gets the underlying <see cref="P:Akka.Dispatch.MessageQueues.BoundedMessageQueue.PushTimeOut"/> 
            </summary>
            <remarks>
            This method is never called, but had to be implemented to support the <see cref="T:Akka.Dispatch.IBoundedDequeBasedMessageQueueSemantics"/> interface.
            </remarks>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.UnboundedMessageQueue">
            <summary> An unbounded mailbox message queue. </summary>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.UnboundedMessageQueue.HasMessages">
            <inheritdoc cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.UnboundedMessageQueue.Count">
            <inheritdoc cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.UnboundedMessageQueue.Enqueue(Akka.Actor.IActorRef,Akka.Actor.Envelope)">
            <inheritdoc cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.UnboundedMessageQueue.TryDequeue(Akka.Actor.Envelope@)">
            <inheritdoc cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.UnboundedMessageQueue.CleanUp(Akka.Actor.IActorRef,Akka.Dispatch.MessageQueues.IMessageQueue)">
            <inheritdoc cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>
        </member>
        <member name="T:Akka.Dispatch.MessageQueues.UnboundedPriorityMessageQueue">
            <summary> 
            Base class for a message queue that uses a priority generator for messages 
            </summary>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.UnboundedPriorityMessageQueue.#ctor(System.Int32)">
            <summary>
            DEPRECATED. Use UnboundedPriorityMessageQueue(Func{object, int} priorityGenerator, int initialCapacity) instead.        
            </summary>
            <param name="initialCapacity">The initial capacity of the priority queue.</param>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.UnboundedPriorityMessageQueue.#ctor(System.Func{System.Object,System.Int32},System.Int32)">
            <summary>
            Creates a new unbounded priority message queue.
            </summary>
            <param name="priorityGenerator">The calculator function for determining the priority of inbound messages.</param>
            <param name="initialCapacity">The initial capacity of the queue.</param>
        </member>
        <member name="P:Akka.Dispatch.MessageQueues.UnboundedPriorityMessageQueue.LockedCount">
            <summary>
            Unsafe method for computing the underlying message count. 
            </summary>
            <remarks>
            Called from within a synchronization mechanism.
            </remarks>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.UnboundedPriorityMessageQueue.LockedEnqueue(Akka.Actor.Envelope)">
            <summary>
            Unsafe method for enquing a new message to the queue.
            </summary>
            <param name="envelope">The message to enqueue.</param>
            <remarks>
            Called from within a synchronization mechanism.
            </remarks>
        </member>
        <member name="M:Akka.Dispatch.MessageQueues.UnboundedPriorityMessageQueue.LockedTryDequeue(Akka.Actor.Envelope@)">
            <summary>
            Unsafe method for attempting to dequeue a message.
            </summary>
            <param name="envelope">The message that might be dequed.</param>
            <returns><c>true</c> if a message was available to be dequeued, <c>false</c> otherwise.</returns>
            <remarks>
            Called from within a synchronization mechanism.
            </remarks>
        </member>
        <member name="T:Akka.Dispatch.PinnedDispatcherConfigurator">
            <summary>
            Used to create instances of the <see cref="T:Akka.Dispatch.PinnedDispatcher"/>. 
            
            Each actor created using the pinned dispatcher gets its own unique thread.
            <remarks>
            Always returns a new instance.
            </remarks>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.PinnedDispatcherConfigurator.#ctor(Akka.Configuration.Config,Akka.Dispatch.IDispatcherPrerequisites)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
            <param name="prerequisites">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.PinnedDispatcherConfigurator.Dispatcher">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.PinnedDispatcher">
            <summary>
            Dedicates a unique thread for each actor passed in as reference. Served through its <see cref="T:Akka.Dispatch.MessageQueues.IMessageQueue"/>.
            
            The preferred way of creating dispatcher is to define them in configuration and then use the <see cref="M:Akka.Dispatch.Dispatchers.Lookup(System.String)"/>
            method.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.PinnedDispatcher.#ctor(Akka.Dispatch.MessageDispatcherConfigurator,System.String,System.Int32,System.Nullable{System.Int64},Akka.Dispatch.ExecutorServiceFactory,System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="configurator">TBD</param>
            <param name="id">TBD</param>
            <param name="throughput">TBD</param>
            <param name="throughputDeadlineTime">TBD</param>
            <param name="executorServiceFactory">TBD</param>
            <param name="shutdownTimeout">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.PinnedDispatcher.Register(Akka.Actor.ActorCell)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <exception cref="T:System.InvalidOperationException">
            This exception is thrown if the registering <paramref name="actor"/> is not the <see cref="F:Akka.Dispatch.PinnedDispatcher._owner">owner</see>.
            </exception>
        </member>
        <member name="M:Akka.Dispatch.PinnedDispatcher.Unregister(Akka.Actor.ActorCell)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.SystemMessageList">
            <summary>
            INTERNAL API
            
            Value class supporting list operations on <see cref="T:Akka.Dispatch.SysMsg.ISystemMessage"/> instances. The 
            </summary>
        </member>
        <member name="F:Akka.Dispatch.SysMsg.SystemMessageList.LNil">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Dispatch.SysMsg.SystemMessageList.ENil">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.SystemMessageList.SizeInner(Akka.Dispatch.SysMsg.SystemMessage,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="head">TBD</param>
            <param name="acc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.SystemMessageList.ReverseInner(Akka.Dispatch.SysMsg.SystemMessage,Akka.Dispatch.SysMsg.SystemMessage)">
            <summary>
            TBD
            </summary>
            <param name="head">TBD</param>
            <param name="acc">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.LatestFirstSystemMessageList">
             <summary>
             INTERNAL API
            
             Value type supporting list operations on system messages. The `next` field of <see cref="T:Akka.Dispatch.SysMsg.SystemMessage"/>
             is hidden, and can only accessed through the value classes <see cref="T:Akka.Dispatch.SysMsg.LatestFirstSystemMessageList"/> and
             <see cref="T:Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList"/>, abstracting over the fact that system messages are the
             list nodes themselves. If used properly, this stays a compile time construct without any allocation overhead.
            
             This list is mutable.
            
             The type of the list also encodes that the messages contained are in reverse order, i.e. the head of the list is the
             latest appended element.
             </summary>
        </member>
        <member name="F:Akka.Dispatch.SysMsg.LatestFirstSystemMessageList.Head">
            <summary>
            The front of the list.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.LatestFirstSystemMessageList.#ctor(Akka.Dispatch.SysMsg.SystemMessage)">
            <summary>
            TBD
            </summary>
            <param name="head">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.LatestFirstSystemMessageList.IsEmpty">
            <summary>
            Indicates if the list is empty or not. This operation has constant cost.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.LatestFirstSystemMessageList.NonEmpty">
            <summary>
            Indicates if the list has at least one element. This operation has a constant cost.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.LatestFirstSystemMessageList.Size">
            <summary>
            Indicates the number of elements contained within this list. O(N) operation time.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.LatestFirstSystemMessageList.Tail">
             <summary>
             Gives back the list containing all the elements except the first. This operation has constant cost.
            
             ***Warning:*** as the underlying list nodes (the <see cref="T:Akka.Dispatch.SysMsg.SystemMessage"/> instances) are mutable, care
             should be taken when passing the tail to other methods. <see cref="M:Akka.Dispatch.SysMsg.SystemMessage.Unlink"/> should be
             called on the head if one wants to detach the tail permanently.
             </summary>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.LatestFirstSystemMessageList.Reverse">
            <summary>
            Reverses the list. This operation mutates the underlying list. The cost of the call is O(N), where N is the number of elements.
            
            The type of the returned list ios the opposite order: <see cref="T:Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList"/>.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.LatestFirstSystemMessageList.op_Addition(Akka.Dispatch.SysMsg.LatestFirstSystemMessageList,Akka.Dispatch.SysMsg.SystemMessage)">
            <summary>
            Attaches a message to the current head of the list. This operation has constant cost.
            </summary>
            <param name="list">The list being modified.</param>
            <param name="msg">The new item to add to the head of the list.</param>
            <returns>A new <see cref="T:Akka.Dispatch.SysMsg.LatestFirstSystemMessageList"/> with <paramref name="msg"/> appended to the front.</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList">
             <summary>
             INTERNAL API
            
             Value type supporting list operations on system messages. The `next` field of <see cref="T:Akka.Dispatch.SysMsg.SystemMessage"/>
             is hidden, and can only accessed through the value classes <see cref="T:Akka.Dispatch.SysMsg.LatestFirstSystemMessageList"/> and
             <see cref="T:Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList"/>, abstracting over the fact that system messages are the
             list nodes themselves. If used properly, this stays a compile time construct without any allocation overhead.
            
             This list is mutable.
            
             The type of the list also encodes that the messages contained are in reverse order, i.e. the head of the list is the
             latest appended element.
             </summary>
        </member>
        <member name="F:Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList.Head">
            <summary>
            The front of the list.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList.#ctor(Akka.Dispatch.SysMsg.SystemMessage)">
            <summary>
            TBD
            </summary>
            <param name="head">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList.IsEmpty">
            <summary>
            Indicates if the list is empty or not. This operation has constant cost.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList.NonEmpty">
            <summary>
            Indicates if the list has at least one element. This operation has a constant cost.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList.Size">
            <summary>
            Indicates the number of elements contained within this list. O(N) operation time.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList.Tail">
             <summary>
             Gives back the list containing all the elements except the first. This operation has constant cost.
            
             ***Warning:*** as the underlying list nodes (the <see cref="T:Akka.Dispatch.SysMsg.SystemMessage"/> instances) are mutable, care
             should be taken when passing the tail to other methods. <see cref="M:Akka.Dispatch.SysMsg.SystemMessage.Unlink"/> should be
             called on the head if one wants to detach the tail permanently.
             </summary>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList.Reverse">
            <summary>
            Reverses the list. This operation mutates the underlying list. The cost of the call is O(N), where N is the number of elements.
            
            The type of the returned list ios the opposite order: <see cref="T:Akka.Dispatch.SysMsg.LatestFirstSystemMessageList"/>.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList.op_Addition(Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList,Akka.Dispatch.SysMsg.SystemMessage)">
            <summary>
            Attaches a message to the current head of the list. This operation has constant cost.
            </summary>
            <param name="list">The list being modified.</param>
            <param name="msg">The new item to add to the head of the list.</param>
            <returns>A new <see cref="T:Akka.Dispatch.SysMsg.LatestFirstSystemMessageList"/> with <paramref name="msg"/> appended to the front.</returns>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList.op_Addition(Akka.Dispatch.SysMsg.EarliestFirstSystemMessageList,Akka.Dispatch.SysMsg.LatestFirstSystemMessageList)">
            <summary>
            Prepends a list in a reversed order to the head of this list. The prepended list will be reversed during the process.
            </summary>
            <param name="list">The original list.</param>
            <param name="other">The list to be reversed and prepended.</param>
            <returns>A new list with <paramref name="other"/> reversed and prepended to the front of <paramref name="list"/>.</returns>
            <example>
            Example: (3, 4, 5) reversePrepend (2, 1, 0) == (0, 1, 2, 3, 4, 5)
            </example>
            <remarks>
            The cost of this operation is O(N) in the size of the list that is to be prepended.
            </remarks>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.IStashWhenWaitingForChildren">
            <summary>
            INTERNAL API
            
            Signals to Akka.NET actors that we need to wait until children
            have completed some operation (usually, shutting down) before we
            can process this stashed <see cref="T:Akka.Dispatch.SysMsg.ISystemMessage"/>.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.IStashWhenFailed">
            <summary>
            INTERNAL API
            
            Stash this <see cref="T:Akka.Dispatch.SysMsg.ISystemMessage"/> when the actor is in a failed state.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.ISystemMessage">
            <summary>
                Class ISystemMessage.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.SystemMessage">
            <summary>
            INTERNAL API
            
            <see cref="T:Akka.Dispatch.SysMsg.ISystemMessage"/> is an interface and too basic to express
            all of the capabilities needed to express a full-fledged system message.
            </summary>
        </member>
        <member name="F:Akka.Dispatch.SysMsg.SystemMessage.Next">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.SystemMessage.Unlink">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.SystemMessage.Unlinked">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.NoMessage">
            <summary>
             Switched into the mailbox to signal termination
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.NoMessage.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.DeathWatchNotification">
            <summary>
                Class DeathWatchNotification.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.DeathWatchNotification.#ctor(Akka.Actor.IActorRef,System.Boolean,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.DeathWatchNotification" /> class.
            </summary>
            <param name="actor">The actor.</param>
            <param name="existenceConfirmed">if set to <c>true</c> [existence confirmed].</param>
            <param name="addressTerminated">if set to <c>true</c> [address terminated].</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.DeathWatchNotification.Actor">
            <summary>
                Gets the actor.
            </summary>
            <value>The actor.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.DeathWatchNotification.ExistenceConfirmed">
            <summary>
                Gets a value indicating whether [existence confirmed].
            </summary>
            <value><c>true</c> if [existence confirmed]; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.DeathWatchNotification.AddressTerminated">
            <summary>
                Gets a value indicating whether [address terminated].
            </summary>
            <value><c>true</c> if [address terminated]; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.DeathWatchNotification.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Failed">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Failed.#ctor(Akka.Actor.IActorRef,System.Exception,System.Int64)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Failed" /> class.
            </summary>
            <param name="child">The child.</param>
            <param name="cause">The cause.</param>
            <param name="uid">The uid</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Failed.Child">
            <summary>
                Gets the child.
            </summary>
            <value>The child.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Failed.Cause">
            <summary>
                Gets the cause.
            </summary>
            <value>The cause.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Failed.Uid">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Failed.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Supervise">
            <summary>
                Class Supervise.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Supervise.#ctor(Akka.Actor.IActorRef,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Supervise" /> class.
            </summary>
            <param name="child">The child.</param>
            <param name="async">if set to <c>true</c> [asynchronous].</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Supervise.Async">
            <summary>
                Gets a value indicating whether this <see cref="T:Akka.Dispatch.SysMsg.Supervise" /> is asynchronous.
            </summary>
            <value><c>true</c> if asynchronous; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Supervise.Child">
            <summary>
                Gets the child.
            </summary>
            <value>The child.</value>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Supervise.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Watch">
            <summary>
            Creates a deathwatch subscription  between <see cref="P:Akka.Dispatch.SysMsg.Watch.Watchee"/> and <see cref="P:Akka.Dispatch.SysMsg.Watch.Watcher"/>.
            
            <see cref="P:Akka.Dispatch.SysMsg.Watch.Watcher"/> will be notified via a <see cref="T:Akka.Actor.Terminated"/> message when <see cref="P:Akka.Dispatch.SysMsg.Watch.Watchee"/>
            is stopped. In the case of a remote actor references, a <see cref="T:Akka.Actor.Terminated"/> may also be produced in
            the event that the association between the two remote actor systems fails.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Watch.#ctor(Akka.Actor.IInternalActorRef,Akka.Actor.IInternalActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Watch" /> class.
            </summary>
            <param name="watchee">The watchee.</param>
            <param name="watcher">The watcher.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Watch.Watchee">
            <summary>
            Gets the watchee.
            </summary>
            <value>The watchee.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Watch.Watcher">
            <summary>
            Gets the watcher.
            </summary>
            <value>The watcher.</value>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Watch.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Unwatch">
            <summary>
            Unsubscribes <see cref="P:Akka.Dispatch.SysMsg.Unwatch.Watcher"/> from any death watch notifications for <see cref="P:Akka.Dispatch.SysMsg.Unwatch.Watchee"/>.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Unwatch.#ctor(Akka.Actor.IInternalActorRef,Akka.Actor.IInternalActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Unwatch" /> class.
            </summary>
            <param name="watchee">The watchee.</param>
            <param name="watcher">The watcher.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Unwatch.Watchee">
            <summary>
            Gets the watchee.
            </summary>
            <value>The watchee.</value>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Unwatch.Watcher">
            <summary>
            Gets the watcher.
            </summary>
            <value>The watcher.</value>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Unwatch.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.ActorTask">
            <summary>
                Class ActorTask.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.ActorTask.#ctor(System.Threading.Tasks.Task)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.ActorTask" /> class.
            </summary>
            <param name="task">The task.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.ActorTask.Task">
            <summary>
                Gets the task.
            </summary>
            <value>The task.</value>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.ActorTaskSchedulerMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.ActorTaskSchedulerMessage.#ctor(Akka.Dispatch.ActorTaskScheduler,System.Threading.Tasks.Task,System.Object)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.ActorTaskSchedulerMessage" /> class.
            </summary>
            <param name="scheduler">TBD</param>
            <param name="task">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.ActorTaskSchedulerMessage.#ctor(System.Exception,System.Object)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.ActorTaskSchedulerMessage" /> class.
            </summary>
            <param name="exception">The exception.</param>
            <param name="message">The message causing the exception</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.ActorTaskSchedulerMessage.Exception">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.ActorTaskSchedulerMessage.Message">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.ActorTaskSchedulerMessage.ExecuteTask">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.ActorTaskSchedulerMessage.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Recreate">
            <summary>
            Sent to self from <see cref="M:Akka.Actor.ActorCell.Restart(System.Exception)"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Recreate.#ctor(System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Recreate" /> class.
            </summary>
            <param name="cause">The cause.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Recreate.Cause">
            <summary>
                Gets the cause.
            </summary>
            <value>The cause.</value>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Recreate.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Resume">
            <summary>
             Sent to self from <see cref="M:Akka.Actor.ActorCell.Resume(System.Exception)"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Resume.#ctor(System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Resume" /> class.
            </summary>
            <param name="causedByFailure">The caused by failure.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Resume.CausedByFailure">
            <summary>
                Gets or sets the caused by failure.
            </summary>
            <value>The caused by failure.</value>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Resume.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Suspend">
            <summary>
             Sent to self from <see cref="M:Akka.Actor.ActorCell.Suspend"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Suspend.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Stop">
            <summary>
                Class Stop.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Stop.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.StopChild">
            <summary>
                INTERNAL
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.StopChild.#ctor(Akka.Actor.IActorRef)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.StopChild" /> class.
            </summary>
            <param name="child">The child.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.StopChild.Child">
            <summary>
                Gets the child.
            </summary>
            <value>The child.</value>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.StopChild.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Escalate">
            <summary>
                Class Escalate.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Escalate.#ctor(System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Escalate" /> class.
            </summary>
            <param name="reason">The reason.</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Escalate.Reason">
            <summary>
                Gets the reason.
            </summary>
            <value>The reason.</value>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Escalate.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Terminate">
            <summary>
                Class Terminate.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Terminate.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.Create">
            <summary>
            Sent to self from <see cref="M:Akka.Dispatch.MessageDispatcher.Register(Akka.Actor.ActorCell)"/>
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Create.#ctor(Akka.Actor.ActorInitializationException)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Dispatch.SysMsg.Create" /> class.
            </summary>
            <param name="failure">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.Create.Failure">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.Create.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.RegisterTerminationHook">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.RegisterTerminationHook.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.RegisterTerminationHook.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.TerminationHook">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.TerminationHook.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.TerminationHook.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.SysMsg.TerminationHookDone">
            <summary>
                Class Terminate.
            </summary>
        </member>
        <member name="P:Akka.Dispatch.SysMsg.TerminationHookDone.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.SysMsg.TerminationHookDone.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Dispatch.DedicatedThreadPoolConfigHelpers">
            <summary>
            <see cref="T:Akka.Configuration.Config"/> helper class for configuring <see cref="T:Akka.Dispatch.MessageDispatcherConfigurator"/>
            instances who depend on the Helios <see cref="T:Helios.Concurrency.DedicatedThreadPool"/>.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.DedicatedThreadPoolConfigHelpers.GetSafeDeadlockTimeout(Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="cfg">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.DedicatedThreadPoolConfigHelpers.ConfigureThreadType(System.String)">
            <summary>
            TBD
            </summary>
            <param name="threadType">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Dispatch.DedicatedThreadPoolConfigHelpers.GetApartmentState(Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="cfg">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Dispatch.DedicatedThreadPoolConfigHelpers.DefaultSingleThreadPoolSettings">
            <summary>
            Default settings for <see cref="!:SingleThreadDispatcher"/> instances.
            </summary>
        </member>
        <member name="T:Akka.Dispatch.ThreadPoolConfig">
            <summary>
            Used inside Akka.Remote for constructing the low-level Helios threadpool, but inside
            vanilla Akka it's also used for constructing custom fixed-size-threadpool dispatchers.
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ThreadPoolConfig.#ctor(Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
        </member>
        <member name="P:Akka.Dispatch.ThreadPoolConfig.PoolSizeMin">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.ThreadPoolConfig.PoolSizeFactor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Dispatch.ThreadPoolConfig.PoolSizeMax">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Dispatch.ThreadPoolConfig.ScaledPoolSize(System.Int32,System.Double,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="floor">TBD</param>
            <param name="scalar">TBD</param>
            <param name="ceiling">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Done">
            <summary>
            Used with <see cref="T:System.Threading.Tasks.Task"/> instances to signal completion,
            but there is no actual value completed. 
            </summary>
        </member>
        <member name="F:Akka.Done.Instance">
            <summary>
            The singleton instance of <see cref="T:Akka.Done"/>
            </summary>
        </member>
        <member name="T:Akka.Event.ActorEventBus`2">
            <summary>
            This class represents an <see cref="T:Akka.Event.EventBus`3"/> where the subscriber type is an <see cref="T:Akka.Actor.IActorRef"/>.
            </summary>
            <typeparam name="TEvent">The type of event published to the bus.</typeparam>
            <typeparam name="TClassifier">The type of classifier used to classify events.</typeparam>
        </member>
        <member name="T:Akka.Event.AddressTerminatedTopicProvider">
            <summary>
            This class represents an <see cref="T:Akka.Actor.ActorSystem"/> provider used to create the <see cref="T:Akka.Event.AddressTerminatedTopic"/> extension.
            </summary>
        </member>
        <member name="M:Akka.Event.AddressTerminatedTopicProvider.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Creates the <see cref="T:Akka.Event.AddressTerminatedTopic"/> extension using a given actor system.
            </summary>
            <param name="system">The actor system to use when creating the extension.</param>
            <returns>The extension created using the given actor system.</returns>
        </member>
        <member name="T:Akka.Event.AddressTerminatedTopic">
            <summary>
            This class represents an <see cref="T:Akka.Actor.ActorSystem"/> extension used by remote and cluster death watchers
            to publish <see cref="T:Akka.Actor.AddressTerminated"/> notifications when a remote system is deemed dead.
            
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Event.AddressTerminatedTopic.Get(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the extension from the specified actor system.
            </summary>
            <param name="system">The actor system from which to retrieve the extension.</param>
            <returns>The extension retrieved from the given actor system.</returns>
        </member>
        <member name="M:Akka.Event.AddressTerminatedTopic.Subscribe(Akka.Actor.IActorRef)">
            <summary>
            Registers the specified actor to receive <see cref="T:Akka.Actor.AddressTerminated"/> notifications.
            </summary>
            <param name="subscriber">The actor that is registering for notifications.</param>
        </member>
        <member name="M:Akka.Event.AddressTerminatedTopic.Unsubscribe(Akka.Actor.IActorRef)">
            <summary>
            Unregisters the specified actor from receiving <see cref="T:Akka.Actor.AddressTerminated"/> notifications.
            </summary>
            <param name="subscriber">The actor that is unregistering for notifications.</param>
        </member>
        <member name="M:Akka.Event.AddressTerminatedTopic.Publish(Akka.Actor.AddressTerminated)">
            <summary>
            Sends alls registered subscribers an <see cref="T:Akka.Actor.AddressTerminated"/> notification.
            </summary>
            <param name="msg">The message that is sent to all subscribers.</param>
        </member>
        <member name="T:Akka.Event.BusLogging">
            <summary>
            A logging adapter implementation publishing log events to the event stream.
            </summary>
        </member>
        <member name="M:Akka.Event.BusLogging.#ctor(Akka.Event.LoggingBus,System.String,System.Type,Akka.Event.ILogMessageFormatter)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.BusLogging" /> class.
            </summary>
            <param name="bus">The logging bus instance that messages will be published to.</param>
            <param name="logSource">The log source.</param>
            <param name="logClass">The log class.</param>
            <param name="logMessageFormatter">The log message formatter.</param>
        </member>
        <member name="P:Akka.Event.BusLogging.IsDebugEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.DebugLevel" /> is enabled.
            </summary>
        </member>
        <member name="P:Akka.Event.BusLogging.IsErrorEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.ErrorLevel" /> is enabled.
            </summary>
        </member>
        <member name="P:Akka.Event.BusLogging.IsInfoEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.InfoLevel" /> is enabled.
            </summary>
        </member>
        <member name="P:Akka.Event.BusLogging.IsWarningEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.WarningLevel" /> is enabled.
            </summary>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyError(System.Object)">
            <summary>
            Publishes the error message onto the LoggingBus.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyError(System.Exception,System.Object)">
            <summary>
            Publishes the error message and exception onto the LoggingBus.
            </summary>
            <param name="cause">The exception that caused this error.</param>
            <param name="message">The error message.</param>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyWarning(System.Object)">
            <summary>
            Publishes the warning message onto the LoggingBus.
            </summary>
            <param name="message">The warning message.</param>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyInfo(System.Object)">
            <summary>
            Publishes the info message onto the LoggingBus.
            </summary>
            <param name="message">The info message.</param>
        </member>
        <member name="M:Akka.Event.BusLogging.NotifyDebug(System.Object)">
            <summary>
            Publishes the debug message onto the LoggingBus.
            </summary>
            <param name="message">The debug message.</param>
        </member>
        <member name="T:Akka.Event.IDeadLetterSuppression">
            <summary>
             Use with caution: Messages extending this trait will not be logged by the default dead-letters listener.
            Instead they will be wrapped as <see cref="T:Akka.Event.SuppressedDeadLetter"/> and may be subscribed for explicitly.
            </summary>
        </member>
        <member name="T:Akka.Event.AllDeadLetters">
            <summary>
            Represents a message that could not be delivered to it's recipient. 
            This message wraps the original message, the sender and the intended recipient of the message.
            </summary>
        </member>
        <member name="M:Akka.Event.AllDeadLetters.#ctor(System.Object,Akka.Actor.IActorRef,Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.DeadLetter"/> class.
            </summary>
            <param name="message">The original message that could not be delivered.</param>
            <param name="sender">The actor that sent the message.</param>
            <param name="recipient">The actor that was to receive the message.</param>
        </member>
        <member name="P:Akka.Event.AllDeadLetters.Message">
            <summary>
            The original message that could not be delivered.
            </summary>
        </member>
        <member name="P:Akka.Event.AllDeadLetters.Recipient">
            <summary>
            The actor that was to receive the message.
            </summary>
        </member>
        <member name="P:Akka.Event.AllDeadLetters.Sender">
            <summary>
            The actor that sent the message.
            </summary>
        </member>
        <member name="M:Akka.Event.AllDeadLetters.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Event.DeadLetter">
            <summary>
            When a message is sent to an Actor that is terminated before receiving the message, it will be sent as a DeadLetter
            to the ActorSystem's EventStream
            </summary>
        </member>
        <member name="M:Akka.Event.DeadLetter.#ctor(System.Object,Akka.Actor.IActorRef,Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.DeadLetter"/> class.
            </summary>
            <param name="message">The original message that could not be delivered.</param>
            <param name="sender">The actor that sent the message.</param>
            <param name="recipient">The actor that was to receive the message.</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when either the sender or the recipient is undefined.
            </exception>
        </member>
        <member name="T:Akka.Event.SuppressedDeadLetter">
            <summary>
            Similar to <see cref="T:Akka.Event.DeadLetter"/> with the slight twist of NOT being logged by the default dead letters listener.
            Messages which end up being suppressed dead letters are internal messages for which ending up as dead-letter is both expected and harmless.
            </summary>
        </member>
        <member name="M:Akka.Event.SuppressedDeadLetter.#ctor(Akka.Event.IDeadLetterSuppression,Akka.Actor.IActorRef,Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.SuppressedDeadLetter"/> class.
            </summary>
            <param name="message">The original message that could not be delivered.</param>
            <param name="sender">The actor that sent the message.</param>
            <param name="recipient">The actor that was to receive the message.</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown when either the sender or the recipient is undefined.
            </exception>
        </member>
        <member name="T:Akka.Event.DeadLetterListener">
            <summary>
            This class represents an actor responsible for listening to <see cref="T:Akka.Event.DeadLetter"/> messages and logging them using the <see cref="T:Akka.Event.EventStream"/>.
            </summary>
        </member>
        <member name="M:Akka.Event.DeadLetterListener.PostRestart(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
        </member>
        <member name="M:Akka.Event.DeadLetterListener.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Event.DeadLetterListener.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Event.DeadLetterListener.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Event.Debug">
            <summary>
            This class represents a Debug log event.
            </summary>
        </member>
        <member name="M:Akka.Event.Debug.#ctor(System.String,System.Type,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.Debug" /> class.
            </summary>
            <param name="logSource">The source that generated the log event.</param>
            <param name="logClass">The type of logger used to log the event.</param>
            <param name="message">The message that is being logged.</param>
        </member>
        <member name="M:Akka.Event.Debug.LogLevel">
            <summary>
            Retrieves the <see cref="T:Akka.Event.LogLevel" /> used to classify this event.
            </summary>
            <returns>
            The <see cref="T:Akka.Event.LogLevel" /> used to classify this event.
            </returns>
        </member>
        <member name="T:Akka.Event.DefaultLogger">
            <summary>
            Default logger implementation that outputs logs to the Console.
            </summary>
        </member>
        <member name="M:Akka.Event.DefaultLogger.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Event.DefaultLogger.Print(Akka.Event.LogEvent)">
            <summary>
            Print the specified log event.
            </summary>
            <param name="logEvent">The log event that is to be output.</param>
        </member>
        <member name="T:Akka.Event.DefaultLogMessageFormatter">
            <summary>
            This class represents an <see cref="T:Akka.Event.ILoggingAdapter"/> implementation that uses <see cref="M:System.String.Format(System.String,System.Object[])"/> to format log messages.
            </summary>
        </member>
        <member name="M:Akka.Event.DefaultLogMessageFormatter.Format(System.String,System.Object[])">
            <summary>
            Formats a specified composite string using an optional list of item substitutions.
            </summary>
            <param name="format">The string that is being formatted.</param>
            <param name="args">An optional list of items used to format the string.</param>
            <returns>The given string that has been correctly formatted.</returns>
        </member>
        <member name="T:Akka.Event.Error">
            <summary>
            This class represents a Error log event.
            </summary>
        </member>
        <member name="M:Akka.Event.Error.#ctor(System.Exception,System.String,System.Type,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.Error" /> class.
            </summary>
            <param name="cause">The exception that caused the log event.</param>
            <param name="logSource">The source that generated the log event.</param>
            <param name="logClass">The type of logger used to log the event.</param>
            <param name="message">The message that is being logged.</param>
        </member>
        <member name="P:Akka.Event.Error.Cause">
            <summary>
            The exception that caused the log event.
            </summary>
        </member>
        <member name="M:Akka.Event.Error.LogLevel">
            <summary>
            Retrieves the <see cref="T:Akka.Event.LogLevel" /> used to classify this event.
            </summary>
            <returns>The <see cref="T:Akka.Event.LogLevel" /> used to classify this event.</returns>
        </member>
        <member name="M:Akka.Event.Error.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this instance.</returns>
        </member>
        <member name="T:Akka.Event.EventBus`3">
            <summary>
            This class provides base publish/subscribe functionality for working with events inside the system.
            </summary>
            <typeparam name="TEvent">The type of event published to the bus.</typeparam>
            <typeparam name="TClassifier">The type of classifier used to classify events.</typeparam>
            <typeparam name="TSubscriber">The type of the subscriber that listens for events.</typeparam>
        </member>
        <member name="M:Akka.Event.EventBus`3.SimpleName(System.Object)">
            <summary>
            Retrieves the simplified type name (the class name without the namespace) of a given object.
            </summary>
            <param name="source">The object that is being queried.</param>
            <returns>The simplified type name of the given object.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.SimpleName(System.Type)">
            <summary>
            Retrieves the simplified type name (the class name without the namespace) of a given type.
            </summary>
            <param name="source">The object that is being queried.</param>
            <returns>The simplified type name of the given type.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Subscribe(`2,`1)">
            <summary>
            Adds the specified subscriber to the list of subscribers that listen for particular events on the bus.
            </summary>
            <param name="subscriber">The subscriber that is being added.</param>
            <param name="classifier">The classifier of the event that the subscriber wants.</param>
            <returns><c>true</c> if the subscription succeeds; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Unsubscribe(`2)">
            <summary>
            Removes the specified subscriber from the list of subscribers that listen for particular events on the bus.
            </summary>
            <param name="subscriber">The subscriber that is being removed.</param>
            <returns><c>true</c> if the subscription cancellation succeeds; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Unsubscribe(`2,`1)">
            <summary>
            Removes the specified subscriber from the list of subscribers that listen for particular events on the bus.
            </summary>
            <param name="subscriber">The subscriber that is being removed.</param>
            <param name="classifier">The classifier of the event that the subscriber wants.</param>
            <returns><c>true</c> if the subscription cancellation succeeds; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.IsSubClassification(`1,`1)">
            <summary>
            Determines whether a specified classifier, <paramref name="child"/>, is a subclass of another classifier, <paramref name="parent"/>.
            </summary>
            <param name="parent">The potential parent of the classifier that is being checked.</param>
            <param name="child">The classifier that is being checked.</param>
            <returns><c>true</c> if the <paramref name="child"/> classifier is a subclass of <paramref name="parent"/>; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Publish(`0,`2)">
            <summary>
            Publishes the specified event directly to the specified subscriber.
            </summary>
            <param name="event">The event that is being published.</param>
            <param name="subscriber">The subscriber that receives the event.</param>
        </member>
        <member name="M:Akka.Event.EventBus`3.Classify(`0,`1)">
            <summary>
            Classifies the specified event using the specified classifier.
            </summary>
            <param name="event">The event that is being classified.</param>
            <param name="classifier">The classifier used to classify the event.</param>
            <returns><c>true</c> if the classification succeeds; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.GetClassifier(`0)">
            <summary>
            Retrieves the classifier used to classify the specified event.
            </summary>
            <param name="event">The event for which to retrieve the classifier.</param>
            <returns>The classifier used to classify the event.</returns>
        </member>
        <member name="M:Akka.Event.EventBus`3.Publish(`0)">
            <summary>
            Publishes the specified event to the bus.
            </summary>
            <param name="event">The event that is being published.</param>
        </member>
        <member name="T:Akka.Event.EventStreamUnsubscriber">
            <summary>
            INTERNAL API
            
            Watches all actors which subscribe on the given eventStream, and unsubscribes them from it when they are Terminated.
            
            Assumptions note:
             We do not guarantee happens-before in the EventStream when 2 threads subscribe(a) / unsubscribe(a) on the same actor,
            thus the messages sent to this actor may appear to be reordered - this is fine, because the worst-case is starting to
            needlessly watch the actor which will not cause trouble for the stream. This is a trade-off between slowing down
            subscribe calls * because of the need of linearizing the history message sequence and the possibility of sometimes
            watching a few actors too much - we opt for the 2nd choice here.
            </summary>
        </member>
        <member name="M:Akka.Event.EventStreamUnsubscriber.#ctor(Akka.Event.EventStream,Akka.Actor.ActorSystem,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="eventStream">TBD</param>
            <param name="system">TBD</param>
            <param name="debug">TBD</param>
        </member>
        <member name="M:Akka.Event.EventStreamUnsubscriber.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Event.EventStreamUnsubscriber.PreStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Event.EventStreamUnsubscriber.Register">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Event.EventStreamUnsubscriber.Register.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
        </member>
        <member name="P:Akka.Event.EventStreamUnsubscriber.Register.Actor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Event.EventStreamUnsubscriber.Terminated">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Event.EventStreamUnsubscriber.Terminated.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
        </member>
        <member name="P:Akka.Event.EventStreamUnsubscriber.Terminated.Actor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Event.EventStreamUnsubscriber.UnregisterIfNoMoreSubscribedChannels">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Event.EventStreamUnsubscriber.UnregisterIfNoMoreSubscribedChannels.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
        </member>
        <member name="P:Akka.Event.EventStreamUnsubscriber.UnregisterIfNoMoreSubscribedChannels.Actor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Event.EventStreamUnsubscribersProvider">
            <summary>
            Provides factory for Akka.Event.EventStreamUnsubscriber actors with unique names.
            This is needed if someone spins up more EventStreams using the same ActorSystem,
            each stream gets it's own unsubscriber.
            </summary>
        </member>
        <member name="P:Akka.Event.EventStreamUnsubscribersProvider.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Event.EventStreamUnsubscribersProvider.Start(Akka.Actor.Internal.ActorSystemImpl,Akka.Event.EventStream,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <param name="eventStream">TBD</param>
            <param name="debug">TBD</param>
        </member>
        <member name="T:Akka.Event.EventStream">
            <summary>
            The EventStream is a pub-sub stream of events that can be both system and user generated. 
            
            The subscribers are IActorRef instances and events can be any object. Subscriptions are hierarchical meaning that if you listen to
            an event for a particular type you will receive events for that type and any sub types.
            
            If the debug flag is activated any operations on the event stream will be published as debug level events.
            </summary>
        </member>
        <member name="M:Akka.Event.EventStream.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.EventStream"/> class.
            </summary>
            <param name="debug">if set to <c>true</c> [debug].</param>
        </member>
        <member name="M:Akka.Event.EventStream.Subscribe(Akka.Actor.IActorRef,System.Type)">
            <summary>
            Subscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <param name="channel">The channel.</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if the given <paramref name="subscriber"/> is undefined.
            </exception>
            <returns><c>true</c> if subscription was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Event.EventStream.Unsubscribe(Akka.Actor.IActorRef,System.Type)">
            <summary>
            Unsubscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <param name="channel">The channel.</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if the given <paramref name="subscriber"/> is undefined.
            </exception>
            <returns><c>true</c> if unsubscription was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Event.EventStream.Unsubscribe(Akka.Actor.IActorRef)">
            <summary>
            Unsubscribes the specified subscriber.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if the given <paramref name="subscriber"/> is undefined.
            </exception>
            <returns><c>true</c> if unsubscription was successful, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Event.EventStream.StartUnsubscriber(Akka.Actor.Internal.ActorSystemImpl)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
        </member>
        <member name="M:Akka.Event.EventStream.InitUnsubscriber(Akka.Actor.IActorRef,Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="unsubscriber">TBD</param>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Event.EventStreamExtensions">
            <summary>
            Extension methods for the EventStream class.
            </summary>
        </member>
        <member name="M:Akka.Event.EventStreamExtensions.Subscribe``1(Akka.Event.EventStream,Akka.Actor.IActorRef)">
            <summary>
            Subscribes the specified subscriber.
            </summary>
            <typeparam name="TChannel">The channel.</typeparam>
            <param name="eventStream">The event stream.</param>
            <param name="subscriber">The subscriber.</param>
            <returns><c>true</c> if subscription was successful, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">subscriber</exception>
        </member>
        <member name="M:Akka.Event.EventStreamExtensions.Unsubscribe``1(Akka.Event.EventStream,Akka.Actor.IActorRef)">
            <summary>
            Unsubscribes the specified subscriber.
            </summary>
            <typeparam name="TChannel">The channel.</typeparam>
            <param name="eventStream">The event stream.</param>
            <param name="subscriber">The subscriber.</param>
            <returns><c>true</c> if unsubscription was successful, <c>false</c> otherwise.</returns>
            <exception cref="T:System.ArgumentNullException">subscriber</exception>
        </member>
        <member name="T:Akka.Event.ILoggerMessageQueueSemantics">
            <summary>
            Semantics needed for loggers
            </summary>
        </member>
        <member name="T:Akka.Event.ILoggingAdapter">
            <summary>
            This interface describes the methods used to log events within the system.
            </summary>
        </member>
        <member name="P:Akka.Event.ILoggingAdapter.IsDebugEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.DebugLevel"/> is enabled.
            </summary>
        </member>
        <member name="P:Akka.Event.ILoggingAdapter.IsInfoEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.InfoLevel"/> is enabled.
            </summary>
        </member>
        <member name="P:Akka.Event.ILoggingAdapter.IsWarningEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.WarningLevel"/> is enabled.
            </summary>
        </member>
        <member name="P:Akka.Event.ILoggingAdapter.IsErrorEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.ErrorLevel"/> is enabled.
            </summary>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.IsEnabled(Akka.Event.LogLevel)">
            <summary>
            Determines whether a specific log level is enabled.
            </summary>
            <param name="logLevel">The log level that is being checked.</param>
            <returns><c>true</c> if the specified level is enabled; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Debug(System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.DebugLevel"/> message.
            </summary>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Info(System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.InfoLevel"/> message.
            </summary>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Warning(System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.WarningLevel"/> message.
            </summary>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Error(System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.ErrorLevel"/> message.
            </summary>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Error(System.Exception,System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.ErrorLevel"/> message and associated exception.
            </summary>
            <param name="cause">The exception associated with this message.</param>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.ILoggingAdapter.Log(Akka.Event.LogLevel,System.String,System.Object[])">
            <summary>
            Logs a message with a specified level.
            </summary>
            <param name="logLevel">The level used to log the message.</param>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="T:Akka.Event.NoLogger">
            <summary>
            This class represents an <see cref="T:Akka.Event.ILoggingAdapter"/> implementation used when messages are to be dropped instead of logged.
            </summary>
        </member>
        <member name="F:Akka.Event.NoLogger.Instance">
            <summary>
            Retrieves a singleton instance of the <see cref="T:Akka.Event.NoLogger"/> class.
            </summary>
        </member>
        <member name="P:Akka.Event.NoLogger.IsDebugEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.DebugLevel" /> is enabled.
            </summary>
        </member>
        <member name="P:Akka.Event.NoLogger.IsInfoEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.InfoLevel" /> is enabled.
            </summary>
        </member>
        <member name="P:Akka.Event.NoLogger.IsWarningEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.WarningLevel" /> is enabled.
            </summary>
        </member>
        <member name="P:Akka.Event.NoLogger.IsErrorEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.ErrorLevel" /> is enabled.
            </summary>
        </member>
        <member name="M:Akka.Event.NoLogger.IsEnabled(Akka.Event.LogLevel)">
            <summary>
            Determines whether a specific log level is enabled.
            </summary>
            <param name="logLevel">The log level that is being checked.</param>
            <returns>
              <c>true</c> if the specified level is enabled; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Event.NoLogger.Debug(System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.DebugLevel" /> message.
            </summary>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.NoLogger.Info(System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.InfoLevel" /> message.
            </summary>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.NoLogger.Warn(System.String,System.Object[])">
            <summary>
            Obsolete. Use <see cref="M:Akka.Event.NoLogger.Warning(System.String,System.Object[])" /> instead!
            </summary>
            <param name="format">N/A</param>
            <param name="args">N/A</param>
        </member>
        <member name="M:Akka.Event.NoLogger.Warning(System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.WarningLevel" /> message.
            </summary>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.NoLogger.Error(System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.ErrorLevel" /> message.
            </summary>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.NoLogger.Error(System.Exception,System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.ErrorLevel" /> message and associated exception.
            </summary>
            <param name="cause">The exception associated with this message.</param>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.NoLogger.Log(Akka.Event.LogLevel,System.String,System.Object[])">
            <summary>
            Logs a message with a specified level.
            </summary>
            <param name="logLevel">The level used to log the message.</param>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="T:Akka.Event.ILogMessageFormatter">
            <summary>
            This interface describes the methods used to format log messages.
            </summary>
        </member>
        <member name="M:Akka.Event.ILogMessageFormatter.Format(System.String,System.Object[])">
            <summary>
            Formats a specified composite string using an optional list of item substitutions.
            </summary>
            <param name="format">The string that is being formatted.</param>
            <param name="args">An optional list of items used to format the string.</param>
            <returns>The given string that has been correctly formatted.</returns>
        </member>
        <member name="T:Akka.Event.Info">
            <summary>
            This class represents an Info log event.
            </summary>
        </member>
        <member name="M:Akka.Event.Info.#ctor(System.String,System.Type,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.Info" /> class.
            </summary>
            <param name="logSource">The source that generated the log event.</param>
            <param name="logClass">The type of logger used to log the event.</param>
            <param name="message">The message that is being logged.</param>
        </member>
        <member name="M:Akka.Event.Info.LogLevel">
            <summary>
            Retrieves the <see cref="T:Akka.Event.LogLevel" /> used to classify this event.
            </summary>
            <returns>
            The <see cref="T:Akka.Event.LogLevel" /> used to classify this event.
            </returns>
        </member>
        <member name="T:Akka.Event.InitializeLogger">
            <summary>
            This class represents a message used to initialize a logger.
            </summary> 
        </member>
        <member name="M:Akka.Event.InitializeLogger.#ctor(Akka.Event.LoggingBus)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.InitializeLogger" /> message.
            </summary>
            <param name="loggingBus">The bus used by the logger to log events.</param>
        </member>
        <member name="P:Akka.Event.InitializeLogger.LoggingBus">
            <summary>
            The bus used by the logger to log events.
            </summary>
        </member>
        <member name="T:Akka.Event.LogEvent">
            <summary>
            This class represents a logging event in the system.
            </summary>
        </member>
        <member name="M:Akka.Event.LogEvent.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.LogEvent" /> class.
            </summary>
        </member>
        <member name="P:Akka.Event.LogEvent.Timestamp">
            <summary>
            The timestamp that this event occurred.
            </summary>
        </member>
        <member name="P:Akka.Event.LogEvent.Thread">
            <summary>
            The thread where this event occurred.
            </summary>
        </member>
        <member name="P:Akka.Event.LogEvent.LogSource">
            <summary>
            The source that generated this event.
            </summary>
        </member>
        <member name="P:Akka.Event.LogEvent.LogClass">
            <summary>
            The type that generated this event.
            </summary>
        </member>
        <member name="P:Akka.Event.LogEvent.Message">
            <summary>
            The message associated with this event.
            </summary>
        </member>
        <member name="M:Akka.Event.LogEvent.LogLevel">
            <summary>
            Retrieves the <see cref="T:Akka.Event.LogLevel" /> used to classify this event.
            </summary>
            <returns>The <see cref="T:Akka.Event.LogLevel" /> used to classify this event.</returns>
        </member>
        <member name="M:Akka.Event.LogEvent.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this LogEvent.
            </summary>
            <returns>A <see cref="T:System.String" /> that represents this LogEvent.</returns>
        </member>
        <member name="T:Akka.Event.LoggerInitialized">
            <summary>
            This class represents a message used to notify subscribers that a logger has been initialized.
            </summary>
        </member>
        <member name="T:Akka.Event.LoggerMailboxType">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Event.LoggerMailboxType.#ctor(Akka.Actor.Settings,Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="settings">TBD</param>
            <param name="config">TBD</param>
        </member>
        <member name="M:Akka.Event.LoggerMailboxType.Create(Akka.Actor.IActorRef,Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="owner">TBD</param>
            <param name="system">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if the given <paramref name="owner"/> or <paramref name="system"/> is undefined.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Event.LoggerMailbox">
            <summary>
            Mailbox type used by loggers
            </summary>
        </member>
        <member name="M:Akka.Event.LoggerMailbox.#ctor(Akka.Actor.IActorRef,Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="owner">TBD</param>
            <param name="system">TBD</param>
        </member>
        <member name="T:Akka.Event.DummyClassForStringSources">
            <summary>
            This class represents a marker which is inserted as originator class into
            <see cref="T:Akka.Event.LogEvent"/> when the string representation was supplied directly.
            </summary>
        </member>
        <member name="T:Akka.Event.Logging">
            <summary>
            This class provides the functionality for creating logger instances and helpers for converting to/from <see cref="T:Akka.Event.LogLevel"/> values.
            </summary>
        </member>
        <member name="F:Akka.Event.Logging.StandardOutLogger">
            <summary>
            Returns a singleton instance of the standard out logger.
            </summary>
        </member>
        <member name="M:Akka.Event.Logging.ClassFor(Akka.Event.LogLevel)">
            <summary>
            Retrieves the log event class associated with the specified log level.
            </summary>
            <param name="logLevel">The log level used to lookup the associated class.</param>
            <exception cref="T:System.ArgumentException">The exception is thrown if the given <paramref name="logLevel"/> is unknown.</exception>
            <returns>The log event class associated with the specified log level.</returns>
        </member>
        <member name="M:Akka.Event.Logging.StringFor(Akka.Event.LogLevel)">
            <summary>
            Retrieves the log event class name associated with the specified log level.
            </summary>
            <param name="logLevel">The log level used to lookup the associated class.</param>
            <exception cref="T:System.ArgumentException">The exception is thrown if the given <paramref name="logLevel"/> is unknown.</exception>
            <returns>The log event class name associated with the specified log level.</returns>
        </member>
        <member name="M:Akka.Event.Logging.GetLogger(Akka.Actor.IActorContext,Akka.Event.ILogMessageFormatter)">
            <summary>
            Creates a new logging adapter using the specified context's event stream.
            </summary>
            <param name="context">The context used to configure the logging adapter.</param>
            <param name="logMessageFormatter">The formatter used to format log messages.</param>
            <returns>The newly created logging adapter.</returns>
        </member>
        <member name="M:Akka.Event.Logging.GetLogger(Akka.Actor.ActorSystem,System.Object,Akka.Event.ILogMessageFormatter)">
            <summary>
            Creates a new logging adapter using the specified system's event stream.
            </summary>
            <param name="system">The system used to configure the logging adapter.</param>
            <param name="logSourceObj">The source that produces the log events.</param>
            <param name="logMessageFormatter">The formatter used to format log messages.</param>
            <returns>The newly created logging adapter.</returns>
        </member>
        <member name="M:Akka.Event.Logging.GetLogger(Akka.Event.LoggingBus,System.Object,Akka.Event.ILogMessageFormatter)">
            <summary>
            Creates a new logging adapter that writes to the specified logging bus.
            </summary>
            <param name="loggingBus">The bus on which this logger writes.</param>
            <param name="logSourceObj">The source that produces the log events.</param>
            <param name="logMessageFormatter">The formatter used to format log messages.</param>
            <returns>The newly created logging adapter.</returns>
        </member>
        <member name="M:Akka.Event.Logging.LogLevelFor(System.String)">
            <summary>
            Retrieves the log level from the specified string.
            </summary>
            <param name="logLevel">The string representation of the log level to lookup.</param>
            <exception cref="T:System.ArgumentException">The exception is thrown if the given <paramref name="logLevel"/> is unknown.</exception>
            <returns>The log level that matches the specified string.</returns>
        </member>
        <member name="M:Akka.Event.Logging.LogLevelFor``1">
            <summary>
            Retrieves the log level associated with the specified <typeparamref name="T">log event</typeparamref>.
            </summary>
            <typeparam name="T">The type of the log event.</typeparam>
            <exception cref="T:System.ArgumentException">The exception is thrown if the given <paramref name="logLevel"/> is unknown.</exception>
            <returns>The log level associated with the specified type.</returns>
        </member>
        <member name="T:Akka.Event.LoggingAdapterBase">
            <summary>
            This class represents the base logging adapter implementation used to log events within the system.
            </summary>
        </member>
        <member name="P:Akka.Event.LoggingAdapterBase.IsDebugEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.DebugLevel" /> is enabled.
            </summary>
        </member>
        <member name="P:Akka.Event.LoggingAdapterBase.IsErrorEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.ErrorLevel" /> is enabled.
            </summary>
        </member>
        <member name="P:Akka.Event.LoggingAdapterBase.IsInfoEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.InfoLevel" /> is enabled.
            </summary>
        </member>
        <member name="P:Akka.Event.LoggingAdapterBase.IsWarningEnabled">
            <summary>
            Check to determine whether the <see cref="F:Akka.Event.LogLevel.WarningLevel" /> is enabled.
            </summary>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.NotifyError(System.Object)">
            <summary>
            Notifies all subscribers that an <see cref="F:Akka.Event.LogLevel.ErrorLevel" /> log event occurred.
            </summary>
            <param name="message">The message related to the log event.</param>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.NotifyError(System.Exception,System.Object)">
            <summary>
            Notifies all subscribers that an <see cref="F:Akka.Event.LogLevel.ErrorLevel" /> log event occurred.
            </summary>
            <param name="cause">The exception that caused the log event.</param>
            <param name="message">The message related to the log event.</param>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.NotifyWarning(System.Object)">
            <summary>
            Notifies all subscribers that an <see cref="F:Akka.Event.LogLevel.WarningLevel" /> log event occurred.
            </summary>
            <param name="message">The message related to the log event.</param>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.NotifyInfo(System.Object)">
            <summary>
            Notifies all subscribers that an <see cref="F:Akka.Event.LogLevel.InfoLevel" /> log event occurred.
            </summary>
            <param name="message">The message related to the log event.</param>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.NotifyDebug(System.Object)">
            <summary>
            Notifies all subscribers that an <see cref="F:Akka.Event.LogLevel.DebugLevel" /> log event occurred.
            </summary>
            <param name="message">The message related to the log event.</param>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.#ctor(Akka.Event.ILogMessageFormatter)">
            <summary>
            Creates an instance of the LoggingAdapterBase.
            </summary>
            <param name="logMessageFormatter">The log message formatter used by this logging adapter.</param>
            <exception cref="T:System.ArgumentNullException">This exception is thrown when the given <paramref name="logMessageFormatter"/> is undefined.</exception>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.IsEnabled(Akka.Event.LogLevel)">
            <summary>
            Checks the logging adapter to see if the supplied <paramref name="logLevel"/> is enabled.
            </summary>
            <param name="logLevel">The log level to check if it is enabled in this logging adapter.</param>
            <exception cref="T:System.NotSupportedException">This exception is thrown when the given <paramref name="logLevel"/> is unknown.</exception>
            <returns><c>true</c> if the supplied log level is enabled; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.NotifyLog(Akka.Event.LogLevel,System.Object)">
            <summary>
            Notifies all subscribers that a log event occurred for a particular level.
            </summary>
            <param name="logLevel">The log level associated with the log event.</param>
            <param name="message">The message related to the log event.</param>
            <exception cref="T:System.NotSupportedException">This exception is thrown when the given <paramref name="logLevel"/> is unknown.</exception>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.Debug(System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.DebugLevel" /> message.
            </summary>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.Warn(System.String,System.Object[])">
            <summary>
            Obsolete. Use <see cref="M:Akka.Event.LoggingAdapterBase.Warning(System.String,System.Object[])" /> instead!
            </summary>
            <param name="format">N/A</param>
            <param name="args">N/A</param>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.Warning(System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.WarningLevel" /> message.
            </summary>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.Error(System.Exception,System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.ErrorLevel" /> message and associated exception.
            </summary>
            <param name="cause">The exception associated with this message.</param>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.Error(System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.ErrorLevel" /> message.
            </summary>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.Info(System.String,System.Object[])">
            <summary>
            Logs a <see cref="F:Akka.Event.LogLevel.InfoLevel" /> message.
            </summary>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="M:Akka.Event.LoggingAdapterBase.Log(Akka.Event.LogLevel,System.String,System.Object[])">
            <summary>
            Logs a message with a specified level.
            </summary>
            <param name="logLevel">The level used to log the message.</param>
            <param name="format">The message that is being logged.</param>
            <param name="args">An optional list of items used to format the message.</param>
        </member>
        <member name="T:Akka.Event.LoggingBus">
            <summary>
            This class represents an event bus which subscribes loggers to system <see cref="T:Akka.Event.LogEvent">LogEvents</see>.
            </summary>
        </member>
        <member name="P:Akka.Event.LoggingBus.LogLevel">
            <summary>
            The minimum log level that this bus will subscribe to, any <see cref="T:Akka.Event.LogEvent">LogEvents</see> with a log level below will not be subscribed to.
            </summary>
        </member>
        <member name="M:Akka.Event.LoggingBus.IsSubClassification(System.Type,System.Type)">
            <summary>
            Determines whether a specified classifier, <paramref name="child" />, is a subclass of another classifier, <paramref name="parent" />.
            </summary>
            <param name="parent">The potential parent of the classifier that is being checked.</param>
            <param name="child">The classifier that is being checked.</param>
            <returns><c>true</c> if the <paramref name="child" /> classifier is a subclass of <paramref name="parent" />; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Event.LoggingBus.Publish(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Publishes the specified event directly to the specified subscriber.
            </summary>
            <param name="event">The event that is being published.</param>
            <param name="subscriber">The subscriber that receives the event.</param>
        </member>
        <member name="M:Akka.Event.LoggingBus.Classify(System.Object,System.Type)">
            <summary>
            Classifies the specified event using the specified classifier.
            </summary>
            <param name="event">The event that is being classified.</param>
            <param name="classifier">The classifier used to classify the event.</param>
            <returns><c>true</c> if the classification succeeds; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Event.LoggingBus.GetClassifier(System.Object)">
            <summary>
            Retrieves the classifier used to classify the specified event.
            </summary>
            <param name="event">The event for which to retrieve the classifier.</param>
            <returns>The classifier used to classify the event.</returns>
        </member>
        <member name="M:Akka.Event.LoggingBus.StartDefaultLoggers(Akka.Actor.Internal.ActorSystemImpl)">
            <summary>
            Starts the loggers defined in the system configuration.
            </summary>
            <param name="system">The system that the loggers need to start monitoring.</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is thrown if the logger specified in the <paramref name="system"/> configuration could not be found or loaded.
            </exception>
            <exception cref="T:Akka.Actor.LoggerInitializationException">
            This exception is thrown if the logger doesn't respond with a <see cref="T:Akka.Event.LoggerInitialized"/> message when initialized.
            </exception>
        </member>
        <member name="M:Akka.Event.LoggingBus.StopDefaultLoggers(Akka.Actor.ActorSystem)">
            <summary>
            Stops the loggers defined in the system configuration.
            </summary>
            <param name="system">The system that the loggers need to stop monitoring.</param>
        </member>
        <member name="M:Akka.Event.LoggingBus.StartStdoutLogger(Akka.Actor.Settings)">
            <summary>
            Starts the <see cref="T:Akka.Event.StandardOutLogger"/> logger.
            </summary>
            <param name="config">The configuration used to configure the <see cref="T:Akka.Event.StandardOutLogger"/>.</param>
        </member>
        <member name="M:Akka.Event.LoggingBus.SetLogLevel(Akka.Event.LogLevel)">
            <summary>
            Sets the minimum log level for this bus, any <see cref="T:Akka.Event.LogEvent">LogEvents</see> below this level are ignored.
            </summary>
            <param name="logLevel">The new log level in which to listen.</param>
        </member>
        <member name="T:Akka.Event.LogLevel">
            <summary>
            Enumeration representing the various log levels in the system.
            </summary>
        </member>
        <member name="F:Akka.Event.LogLevel.DebugLevel">
            <summary>
            The debug log level.
            </summary>
        </member>
        <member name="F:Akka.Event.LogLevel.InfoLevel">
            <summary>
            The information log level.
            </summary>
        </member>
        <member name="F:Akka.Event.LogLevel.WarningLevel">
            <summary>
            The warning log level.
            </summary>
        </member>
        <member name="F:Akka.Event.LogLevel.ErrorLevel">
            <summary>
            The error log level.
            </summary>
        </member>
        <member name="T:Akka.Event.LogMessage">
            <summary>
            Represents a log message which is composed of a format string and format args.
            </summary>
        </member>
        <member name="P:Akka.Event.LogMessage.Format">
            <summary>
            Gets the format string of this log message.
            </summary>
        </member>
        <member name="P:Akka.Event.LogMessage.Args">
            <summary>
            Gets the format args of this log message.
            </summary>
        </member>
        <member name="M:Akka.Event.LogMessage.#ctor(Akka.Event.ILogMessageFormatter,System.String,System.Object[])">
            <summary>
            Initializes an instance of the LogMessage with the specified formatter, format and args.
            </summary>
            <param name="formatter">The formatter for the LogMessage.</param>
            <param name="format">The string format of the LogMessage.</param>
            <param name="args">The format args of the LogMessage.</param>
        </member>
        <member name="M:Akka.Event.LogMessage.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Event.StandardOutLogger">
            <summary>
            This class represents an event logger that logs its messages to standard output (e.g. the console).
            
            <remarks>
            This logger is always attached first in order to be able to log failures during application start-up,
            even before normal logging is started.
            </remarks>
            </summary>
        </member>
        <member name="M:Akka.Event.StandardOutLogger.#cctor">
            <summary>
            Initializes the <see cref="T:Akka.Event.StandardOutLogger"/> class.
            </summary>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.Provider">
            <summary>
            N/A
            </summary>
            <exception cref="T:System.NotImplementedException">This exception is automatically thrown since <see cref="T:Akka.Event.StandardOutLogger"/> does not support this property.</exception>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.Path">
            <summary>
            The path where this logger currently resides.
            </summary>
        </member>
        <member name="M:Akka.Event.StandardOutLogger.TellInternal(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Handles incoming log events by printing them to the console.
            </summary>
            <param name="message">The message to print</param>
            <param name="sender">The actor that sent the message.</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if the given <paramref name="message"/> is undefined.
            </exception>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.DebugColor">
            <summary>
            The foreground color to use when printing Debug events to the console.
            </summary>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.InfoColor">
            <summary>
            The foreground color to use when printing Info events to the console.
            </summary>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.WarningColor">
            <summary>
            The foreground color to use when printing Warning events to the console.
            </summary>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.ErrorColor">
            <summary>
            The foreground color to use when printing Error events to the console.
            </summary>
        </member>
        <member name="P:Akka.Event.StandardOutLogger.UseColors">
            <summary>
            Determines whether colors are used when printing events to the console. 
            </summary>
        </member>
        <member name="M:Akka.Event.StandardOutLogger.PrintLogEvent(Akka.Event.LogEvent)">
            <summary>
            Prints a specified event to the console.
            </summary>
            <param name="logEvent">The event to print</param>
        </member>
        <member name="T:Akka.Event.Subscription`2">
            <summary>
            Represents a Subscription to the EventBus.
            </summary>
            <typeparam name="TSubscriber">The type of the subscriber.</typeparam>
            <typeparam name="TClassifier">The type of the classifier.</typeparam>
        </member>
        <member name="M:Akka.Event.Subscription`2.#ctor(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.Subscription`2"/> class.
            </summary>
            <param name="subscriber">The subscriber.</param>
            <param name="unsubscriptions">The unsubscriptions.</param>
        </member>
        <member name="M:Akka.Event.Subscription`2.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.Subscription`2"/> class.
            </summary>
            <param name="subscriber">The subscriber.</param>
        </member>
        <member name="P:Akka.Event.Subscription`2.Subscriber">
            <summary>
            Gets the subscriber attached to this subscription.
            </summary>
            <value>The subscriber.</value>
        </member>
        <member name="P:Akka.Event.Subscription`2.Unsubscriptions">
            <summary>
            Gets the unsubscriptions of this particular subscription.
            </summary>
            <value>The unsubscriptions.</value>
        </member>
        <member name="T:Akka.Event.TraceLogger">
            <summary>
            This class represents an event logger that logs its messages using a configured trace listener.
            
            <remarks>
            To use activate this logger, modify the loggers section in your Akka.NET configuration like so,
            
            <code>
            akka {
              ...
              loggers = [""Akka.Event.TraceLogger, Akka""]
              ...
            }
            </code>
            
            Further configuration may be required in your main configuration (e.g. app.config or web.config)
            to properly set up the trace. See <see href="https://msdn.microsoft.com/en-us/library/zs6s4h68.aspx">here</see>
            for more information regarding .NET tracing.
            </remarks>
            </summary>
        </member>
        <member name="M:Akka.Event.TraceLogger.OnReceive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="T:Akka.Event.UnhandledMessage">
            <summary>
            This class represents a message that was not handled by the recipient.
            </summary>
        </member>
        <member name="M:Akka.Event.UnhandledMessage.#ctor(System.Object,Akka.Actor.IActorRef,Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.UnhandledMessage" /> class.
            </summary>
            <param name="message">The original message that could not be handled.</param>
            <param name="sender">The actor that sent the message.</param>
            <param name="recipient">The actor that was to receive the message.</param>
        </member>
        <member name="P:Akka.Event.UnhandledMessage.Message">
            <summary>
            The original message that could not be handled.
            </summary>
        </member>
        <member name="P:Akka.Event.UnhandledMessage.Sender">
            <summary>
            The actor that sent the message.
            </summary>
        </member>
        <member name="P:Akka.Event.UnhandledMessage.Recipient">
            <summary>
            The actor that was to receive the message.
            </summary>
        </member>
        <member name="T:Akka.Event.Warning">
            <summary>
            This class represents a Warning log event.
            </summary>
        </member>
        <member name="M:Akka.Event.Warning.#ctor(System.String,System.Type,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Event.Warning" /> class.
            </summary>
            <param name="logSource">The source that generated the log event.</param>
            <param name="logClass">The type of logger used to log the event.</param>
            <param name="message">The message that is being logged.</param>
        </member>
        <member name="M:Akka.Event.Warning.LogLevel">
            <summary>
            Retrieves the <see cref="T:Akka.Event.LogLevel" /> used to classify this event.
            </summary>
            <returns>
            The <see cref="T:Akka.Event.LogLevel" /> used to classify this event.
            </returns>
        </member>
        <member name="T:Akka.IO.ByteBuffer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteBuffer.#ctor(System.Byte[])">
            <summary>
            TBD
            </summary>
            <param name="array">TBD</param>
        </member>
        <member name="M:Akka.IO.ByteBuffer.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="array">TBD</param>
            <param name="offset">TBD</param>
            <param name="length">TBD</param>
        </member>
        <member name="M:Akka.IO.ByteBuffer.Clear">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteBuffer.Limit(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="maxBufferSize">TBD</param>
        </member>
        <member name="M:Akka.IO.ByteBuffer.Flip">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.ByteBuffer.HasRemaining">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.ByteBuffer.Remaining">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteBuffer.Array">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteBuffer.Put(System.Byte[])">
            <summary>
            TBD
            </summary>
            <param name="src">TBD</param>
        </member>
        <member name="M:Akka.IO.ByteBuffer.Wrap(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="array">TBD</param>
            <param name="start">TBD</param>
            <param name="len">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteBuffer.Wrap(System.Byte[])">
            <summary>
            TBD
            </summary>
            <param name="array">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteBuffer.Allocate(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="capacity">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteBuffer.Order(Akka.IO.ByteOrder)">
            <summary>
            TBD
            </summary>
            <param name="byteOrder">TBD</param>
        </member>
        <member name="M:Akka.IO.ByteBuffer.Put(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="array">TBD</param>
            <param name="from">TBD</param>
            <param name="copyLength">TBD</param>
        </member>
        <member name="M:Akka.IO.ByteBuffer.Get(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="ar">TBD</param>
            <param name="offset">TBD</param>
            <param name="length">TBD</param>
        </member>
        <member name="M:Akka.IO.ByteBuffer.Get(System.Byte[])">
            <summary>
            TBD
            </summary>
            <param name="ar">TBD</param>
        </member>
        <member name="M:Akka.IO.ByteBuffer.Put(Akka.IO.ByteBuffer,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="src">TBD</param>
            <param name="length">TBD</param>
        </member>
        <member name="T:Akka.IO.DatagramChannel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.DatagramChannel.Open">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.DatagramChannel.IsOpen">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.DatagramChannel.Send(Akka.IO.ByteBuffer,System.Net.EndPoint)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <param name="target">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.DatagramChannel.Receive(Akka.IO.ByteBuffer)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.IBufferPool">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.IBufferPool.Acquire">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.IBufferPool.Release(Akka.IO.ByteBuffer)">
            <summary>
            TBD
            </summary>
            <param name="buf">TBD</param>
        </member>
        <member name="T:Akka.IO.DirectByteBufferPool">
             <summary>
             INTERNAL API
             
             A buffer pool which keeps a free list of direct buffers of a specified default
             size in a simple fixed size stack.
            
             If the stack is full the buffer is de-referenced and available to be
             freed by normal garbage collection.
             </summary>
        </member>
        <member name="M:Akka.IO.DirectByteBufferPool.#ctor(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="defaultBufferSize">TBD</param>
            <param name="maxPoolEntries">TBD</param>
        </member>
        <member name="M:Akka.IO.DirectByteBufferPool.Acquire">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.DirectByteBufferPool.Release(Akka.IO.ByteBuffer)">
            <summary>
            TBD
            </summary>
            <param name="buf">TBD</param>
        </member>
        <member name="T:Akka.IO.DnsBase">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.DnsBase.Cached(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.DnsBase.Resolve(System.String,Akka.Actor.ActorSystem,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="system">TBD</param>
            <param name="sender">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.Dns">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.IO.Dns.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Dns.Command">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Dns.Resolve">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Dns.Resolve.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
        </member>
        <member name="P:Akka.IO.Dns.Resolve.ConsistentHashKey">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Dns.Resolve.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Dns.Resolved">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Dns.Resolved.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Net.IPAddress},System.Collections.Generic.IEnumerable{System.Net.IPAddress})">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="ipv4">TBD</param>
            <param name="ipv6">TBD</param>
        </member>
        <member name="P:Akka.IO.Dns.Resolved.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Dns.Resolved.Ipv4">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Dns.Resolved.Ipv6">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Dns.Resolved.Addr">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Dns.Resolved.Create(System.String,System.Collections.Generic.IEnumerable{System.Net.IPAddress})">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="addresses">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.Dns.Cached(System.String,Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.Dns.ResolveName(System.String,Akka.Actor.ActorSystem,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <param name="system">TBD</param>
            <param name="sender">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.Dns.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.DnsExt">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.DnsExt.DnsSettings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.DnsExt.DnsSettings.#ctor(Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
        </member>
        <member name="P:Akka.IO.DnsExt.DnsSettings.Dispatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.DnsExt.DnsSettings.Resolver">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.DnsExt.DnsSettings.ResolverConfig">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.DnsExt.DnsSettings.ProviderObjectName">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.DnsExt.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
        </member>
        <member name="P:Akka.IO.DnsExt.Manager">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.DnsExt.GetResolver">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.IO.DnsExt.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.DnsExt.Cache">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.DnsExt.Provider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.IDnsProvider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.IDnsProvider.Cache">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.IDnsProvider.ActorClass">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.IDnsProvider.ManagerClass">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Inet">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Inet.SocketOption">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Inet.SocketOption.BeforeDatagramBind(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="ds">TBD</param>
        </member>
        <member name="M:Akka.IO.Inet.SocketOption.BeforeServerSocketBind(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="ss">TBD</param>
        </member>
        <member name="M:Akka.IO.Inet.SocketOption.BeforeConnect(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="s">TBD</param>
        </member>
        <member name="M:Akka.IO.Inet.SocketOption.AfterConnect(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="s">TBD</param>
        </member>
        <member name="T:Akka.IO.Inet.AbstractSocketOption">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Inet.SocketOptionV2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Inet.SocketOptionV2.AfterBind(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="s">TBD</param>
        </member>
        <member name="T:Akka.IO.Inet.AbstractSocketOptionV2">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Inet.DatagramChannelCreator">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Inet.DatagramChannelCreator.Create">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.Inet.SO">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Inet.SO.ReceiveBufferSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Inet.SO.ReceiveBufferSize.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="size">TBD</param>
        </member>
        <member name="M:Akka.IO.Inet.SO.ReceiveBufferSize.BeforeServerSocketBind(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="ss">TBD</param>
        </member>
        <member name="M:Akka.IO.Inet.SO.ReceiveBufferSize.BeforeDatagramBind(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="ds">TBD</param>
        </member>
        <member name="M:Akka.IO.Inet.SO.ReceiveBufferSize.BeforeConnect(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="s">TBD</param>
        </member>
        <member name="T:Akka.IO.Inet.SO.ReuseAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Inet.SO.ReuseAddress.#ctor(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="on">TBD</param>
        </member>
        <member name="M:Akka.IO.Inet.SO.ReuseAddress.BeforeServerSocketBind(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="ss">TBD</param>
        </member>
        <member name="M:Akka.IO.Inet.SO.ReuseAddress.BeforeDatagramBind(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="ds">TBD</param>
        </member>
        <member name="M:Akka.IO.Inet.SO.ReuseAddress.BeforeConnect(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="s">TBD</param>
        </member>
        <member name="T:Akka.IO.Inet.SO.SendBufferSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Inet.SO.SendBufferSize.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="size">TBD</param>
        </member>
        <member name="M:Akka.IO.Inet.SO.SendBufferSize.AfterConnect(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="s">TBD</param>
        </member>
        <member name="T:Akka.IO.Inet.SO.TrafficClass">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Inet.SO.TrafficClass.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="tc">TBD</param>
        </member>
        <member name="M:Akka.IO.Inet.SO.TrafficClass.AfterConnect(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="s">TBD</param>
        </member>
        <member name="T:Akka.IO.Inet.SoForwarders">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.InetAddressDnsProvider">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.InetAddressDnsProvider.Cache">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.InetAddressDnsProvider.ActorClass">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.InetAddressDnsProvider.ManagerClass">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.InetAddressDnsResolver">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.InetAddressDnsResolver.#ctor(Akka.IO.SimpleDnsCache,Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="cache">TBD</param>
            <param name="config">TBD</param>
        </member>
        <member name="M:Akka.IO.InetAddressDnsResolver.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.IOExtension">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.IOExtension.Manager">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.SelectionHandlerSettings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SelectionHandlerSettings.#ctor(Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
        </member>
        <member name="P:Akka.IO.SelectionHandlerSettings.MaxChannels">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.SelectionHandlerSettings.SelectorAssociationRetries">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.SelectionHandlerSettings.SelectorDispatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.SelectionHandlerSettings.WorkerDispatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.SelectionHandlerSettings.TraceLogging">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.SelectionHandlerSettings.MaxChannelsPerSelector">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.IChannelRegistry">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.IChannelRegistry.Register(Akka.IO.SocketChannel,System.Nullable{System.Net.Sockets.SocketAsyncOperation},Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="channel">TBD</param>
            <param name="initialOps">TBD</param>
            <param name="channelActor">TBD</param>
        </member>
        <member name="T:Akka.IO.ChannelRegistration">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ChannelRegistration.#ctor(System.Action{System.Net.Sockets.SocketAsyncOperation},System.Action{System.Net.Sockets.SocketAsyncOperation})">
            <summary>
            TBD
            </summary>
            <param name="enableInterest">TBD</param>
            <param name="disableInterest">TBD</param>
        </member>
        <member name="P:Akka.IO.ChannelRegistration.EnableInterest">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.ChannelRegistration.DisableInterest">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.SelectionHandler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.SelectionHandler.IHasFailureMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.SelectionHandler.WorkerForCommand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SelectionHandler.WorkerForCommand.#ctor(Akka.IO.SelectionHandler.IHasFailureMessage,Akka.Actor.IActorRef,System.Func{Akka.IO.IChannelRegistry,Akka.Actor.Props})">
            <summary>
            TBD
            </summary>
            <param name="apiCommand">TBD</param>
            <param name="commander">TBD</param>
            <param name="childProps">TBD</param>
        </member>
        <member name="P:Akka.IO.SelectionHandler.WorkerForCommand.ApiCommand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.SelectionHandler.WorkerForCommand.Commander">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.SelectionHandler.WorkerForCommand.ChildProps">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.SelectionHandler.Retry">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SelectionHandler.Retry.#ctor(Akka.IO.SelectionHandler.WorkerForCommand,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="command">TBD</param>
            <param name="retriesLeft">TBD</param>
        </member>
        <member name="P:Akka.IO.SelectionHandler.Retry.Command">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.SelectionHandler.Retry.RetriesLeft">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.SelectionHandler.ChannelConnectable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.IO.SelectionHandler.ChannelConnectable.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.SelectionHandler.ChannelAcceptable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.IO.SelectionHandler.ChannelAcceptable.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.SelectionHandler.ChannelReadable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.IO.SelectionHandler.ChannelReadable.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.SelectionHandler.ChannelWritable">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.IO.SelectionHandler.ChannelWritable.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.SelectionHandler.SelectorBasedManager">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.IO.SelectionHandler.SelectorBasedManager.SelectorPool">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SelectionHandler.SelectorBasedManager.#ctor(Akka.IO.SelectionHandlerSettings,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="selectorSettings">TBD</param>
            <param name="nrOfSelectors">TBD</param>
        </member>
        <member name="M:Akka.IO.SelectionHandler.SelectorBasedManager.SupervisorStrategy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.SelectionHandler.SelectorBasedManager.WorkerForCommandHandler(System.Func{Akka.IO.SelectionHandler.IHasFailureMessage,System.Func{Akka.IO.IChannelRegistry,Akka.Actor.Props}})">
            <summary>
            TBD
            </summary>
            <param name="pf">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.IO.SelectionHandler.ConnectionSupervisorStrategy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SelectionHandler.#ctor(Akka.IO.SelectionHandlerSettings)">
            <summary>
            TBD
            </summary>
            <param name="settings">TBD</param>
        </member>
        <member name="M:Akka.IO.SelectionHandler.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.SelectionHandler.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SelectionHandler.SupervisorStrategy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.SingleThreadExecutionContext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SingleThreadExecutionContext.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SingleThreadExecutionContext.Execute(System.Action)">
            <summary>
            TBD
            </summary>
            <param name="action">TBD</param>
        </member>
        <member name="M:Akka.IO.SingleThreadExecutionContext.Stop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.IPeriodicCacheCleanup">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.IPeriodicCacheCleanup.CleanUp">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.SimpleDnsCache">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SimpleDnsCache.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SimpleDnsCache.Cached(System.String)">
            <summary>
            TBD
            </summary>
            <param name="name">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.SimpleDnsCache.Clock">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.SimpleDnsCache.Put(Akka.IO.Dns.Resolved,System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="r">TBD</param>
            <param name="ttl">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.SimpleDnsCache.CleanUp">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.SimpleDnsManager">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SimpleDnsManager.#ctor(Akka.IO.DnsExt)">
            <summary>
            TBD
            </summary>
            <param name="ext">TBD</param>
        </member>
        <member name="M:Akka.IO.SimpleDnsManager.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.SimpleDnsManager.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.SimpleDnsManager.CacheCleanup">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.IO.SimpleDnsManager.CacheCleanup.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.SocketAsyncEventArgsPool">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SocketAsyncEventArgsPool.#ctor(System.Int32,System.Action{System.Net.Sockets.SocketAsyncEventArgs})">
            <summary>
            TBD
            </summary>
            <param name="capacity">TBD</param>
            <param name="select">TBD</param>
        </member>
        <member name="P:Akka.IO.SocketAsyncEventArgsPool.BufferSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SocketAsyncEventArgsPool.Request(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="token">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.SocketAsyncEventArgsPool.Return(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            TBD
            </summary>
            <param name="saea">TBD</param>
        </member>
        <member name="T:Akka.IO.SocketChannel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SocketChannel.#ctor(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="socket">TBD</param>
        </member>
        <member name="M:Akka.IO.SocketChannel.Open">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.SocketChannel.ConfigureBlocking(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="block">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.IO.SocketChannel.Socket">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.SocketChannel.Register(Akka.Actor.IActorRef,System.Nullable{System.Net.Sockets.SocketAsyncOperation})">
            <summary>
            TBD
            </summary>
            <param name="connection">TBD</param>
            <param name="initialOps">TBD</param>
        </member>
        <member name="M:Akka.IO.SocketChannel.IsOpen">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.SocketChannel.Connect(System.Net.EndPoint)">
            <summary>
            TBD
            </summary>
            <param name="address">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.SocketChannel.FinishConnect">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.SocketChannel.Accept">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.SocketChannel.Read(Akka.IO.ByteBuffer)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.SocketChannel.Write(Akka.IO.ByteBuffer)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.SocketChannel.Close">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.IO.SocketChannel.Connection">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.Manager(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.Tcp.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.Tcp.Message">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Command">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.Command.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Command.FailureMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Connect">
            <summary>
            The Connect message is sent to the TCP manager actor, which is obtained via
            <see cref="P:Akka.IO.TcpExt.Manager" />. Either the manager replies with a <see cref="T:Akka.IO.Tcp.CommandFailed" />
            or the actor handling the new connection replies with a <see cref="T:Akka.IO.Tcp.Connected" />
            message.
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.Connect.#ctor(System.Net.EndPoint,System.Net.EndPoint,System.Collections.Generic.IEnumerable{Akka.IO.Inet.SocketOption},System.Nullable{System.TimeSpan},System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="remoteAddress">TBD</param>
            <param name="localAddress">TBD</param>
            <param name="options">TBD</param>
            <param name="timeout">TBD</param>
            <param name="pullMode">TBD</param>
        </member>
        <member name="P:Akka.IO.Tcp.Connect.RemoteAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Connect.LocalAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Connect.Options">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Connect.Timeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Connect.PullMode">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Bind">
            <summary>
            The Bind message is send to the TCP manager actor, which is obtained via
            <see cref="P:Akka.IO.TcpExt.Manager" /> in order to bind to a listening socket. The manager
            replies either with a <see cref="T:Akka.IO.Tcp.CommandFailed" /> or the actor handling the listen
            socket replies with a <see cref="T:Akka.IO.Tcp.Bound" /> message. If the local port is set to 0 in
            the Bind message, then the <see cref="T:Akka.IO.Tcp.Bound" /> message should be inspected to find
            the actual port which was bound to.
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.Bind.#ctor(Akka.Actor.IActorRef,System.Net.EndPoint,System.Int32,System.Collections.Generic.IEnumerable{Akka.IO.Inet.SocketOption},System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="localAddress">TBD</param>
            <param name="backlog">TBD</param>
            <param name="options">TBD</param>
            <param name="pullMode">TBD</param>
        </member>
        <member name="P:Akka.IO.Tcp.Bind.Handler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Bind.LocalAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Bind.Backlog">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Bind.Options">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Bind.PullMode">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Register">
            <summary>
            This message must be sent to a TCP connection actor after receiving the
            <see cref="T:Akka.IO.Tcp.Connected" /> message. The connection will not read any data from the
            socket until this message is received, because this message defines the
            actor which will receive all inbound data.
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.Register.#ctor(Akka.Actor.IActorRef,System.Boolean,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="keepOpenonPeerClosed">TBD</param>
            <param name="useResumeWriting">TBD</param>
        </member>
        <member name="P:Akka.IO.Tcp.Register.Handler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Register.KeepOpenonPeerClosed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Register.UseResumeWriting">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Unbind">
            <summary>
            In order to close down a listening socket, send this message to that sockets
            actor (that is the actor which previously had sent the <see cref="T:Akka.IO.Tcp.Bound" /> message). The
            listener socket actor will reply with a <see cref="T:Akka.IO.Tcp.Unbound" /> message.
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.Unbind.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.CloseCommand">
            <summary>
            Common interface for all commands which aim to close down an open connection.
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.CloseCommand.Event">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Close">
            <summary>
            A normal close operation will first flush pending writes and then close the
            socket. The sender of this command and the registered handler for incoming
            data will both be notified once the socket is closed using a <see cref="T:Akka.IO.Tcp.Closed" />
            message.
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.Close.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Close.Event">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.ConfirmedClose">
            <summary>
            A confirmed close operation will flush pending writes and half-close the
            connection, waiting for the peer to close the other half. The sender of this
            command and the registered handler for incoming data will both be notified
            once the socket is closed using a <see cref="T:Akka.IO.Tcp.ConfirmedClosed" /> message.
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.ConfirmedClose.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.ConfirmedClose.Event">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Abort">
            <summary>
            An abort operation will not flush pending writes and will issue a TCP ABORT
            command to the O/S kernel which should result in a TCP_RST packet being sent
            to the peer. The sender of this command and the registered handler for
            incoming data will both be notified once the socket is closed using a
            <see cref="T:Akka.IO.Tcp.Aborted" /> message.
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.Abort.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Abort.Event">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.NoAck">
            <summary>
            Each <see cref="T:Akka.IO.Tcp.WriteCommand" /> can optionally request a positive acknowledgment to be sent
            to the commanding actor. If such notification is not desired the <see cref="!:WriteCommand#ack" />
            must be set to an instance of this class. The token contained within can be used
            to recognize which write failed when receiving a <see cref="T:Akka.IO.Tcp.CommandFailed" /> message.
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.NoAck.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.NoAck.#ctor(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="token">TBD</param>
        </member>
        <member name="P:Akka.IO.Tcp.NoAck.Token">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.WriteCommand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.WriteCommand.Prepend(Akka.IO.Tcp.SimpleWriteCommand)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.Tcp.WriteCommand.Prepend(System.Collections.Generic.IEnumerable{Akka.IO.Tcp.WriteCommand})">
            <summary>
            TBD
            </summary>
            <param name="writes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.Tcp.WriteCommand.Create(System.Collections.Generic.IEnumerable{Akka.IO.Tcp.WriteCommand})">
            <summary>
            TBD
            </summary>
            <param name="writes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.Tcp.WriteCommand.Create(Akka.IO.Tcp.WriteCommand[])">
            <summary>
            TBD
            </summary>
            <param name="writes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.Tcp.SimpleWriteCommand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.SimpleWriteCommand.Ack">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.SimpleWriteCommand.WantsAck">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.SimpleWriteCommand.Append(Akka.IO.Tcp.WriteCommand)">
            <summary>
            TBD
            </summary>
            <param name="that">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.Tcp.Write">
            <summary>
            Write data to the TCP connection. If no ack is needed use the special
            `NoAck` object. The connection actor will reply with a <see cref="T:Akka.IO.Tcp.CommandFailed" />
            message if the write could not be enqueued. If <see cref="!:WriteCommand#wantsAck" />
            returns true, the connection actor will reply with the supplied <see cref="!:WriteCommand#ack" />
            token once the write has been successfully enqueued to the O/S kernel.
            <b>Note that this does not in any way guarantee that the data will be
            or have been sent!</b> Unfortunately there is no way to determine whether
            a particular write has been sent by the O/S.
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Write.Data">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Write.Ack">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.Write.Create(Akka.IO.ByteString)">
            <summary>
            TBD
            </summary>
            <param name="data">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.Tcp.Write.Create(Akka.IO.ByteString,Akka.IO.Tcp.Event)">
            <summary>
            TBD
            </summary>
            <param name="data">TBD</param>
            <param name="ack">TbD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.IO.Tcp.Write.Empty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.WriteFile">
            <summary>
            Write `count` bytes starting at `position` from file at `filePath` to the connection.
            The count must be &gt; 0. The connection actor will reply with a <see cref="T:Akka.IO.Tcp.CommandFailed"/>
            message if the write could not be enqueued. If <see cref="P:Akka.IO.Tcp.SimpleWriteCommand.WantsAck"/>
            returns true, the connection actor will reply with the supplied <see cref="P:Akka.IO.Tcp.SimpleWriteCommand.Ack"/>
            token once the write has been successfully enqueued to the O/S kernel.
            <b>Note that this does not in any way guarantee that the data will be
            or have been sent!</b> Unfortunately there is no way to determine whether
            a particular write has been sent by the O/S.
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.WriteFile.#ctor(System.String,System.Int64,System.Int64,Akka.IO.Tcp.Event)">
            <summary>
            TBD
            </summary>
            <param name="filePath">TBD</param>
            <param name="position">TBD</param>
            <param name="count">TBD</param>
            <param name="ack">TBD</param>
            <exception cref="T:System.ArgumentException">TBD</exception>
        </member>
        <member name="P:Akka.IO.Tcp.WriteFile.FilePath">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.WriteFile.Position">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.WriteFile.Count">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.WriteFile.Ack">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.CompoundWrite">
            <summary>
            A write command which aggregates two other write commands. Using this construct
            you can chain a number of <see cref="T:Akka.IO.Tcp.Write" /> and/or <see cref="T:Akka.IO.Tcp.WriteFile" /> commands together in a way
            that allows them to be handled as a single write which gets written out to the
            network as quickly as possible.
            If the sub commands contain `ack` requests they will be honored as soon as the
            respective write has been written completely.
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.CompoundWrite.#ctor(Akka.IO.Tcp.SimpleWriteCommand,Akka.IO.Tcp.WriteCommand)">
            <summary>
            TBD
            </summary>
            <param name="head">TBD</param>
            <param name="tailCommand">TBD</param>
        </member>
        <member name="M:Akka.IO.Tcp.CompoundWrite.GetEnumerator">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.IO.Tcp.CompoundWrite.Head">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.CompoundWrite.TailCommand">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.ResumeWriting">
            <summary>
            When `useResumeWriting` is in effect as was indicated in the <see cref="T:Akka.IO.Tcp.Register" /> message
            then this command needs to be sent to the connection actor in order to re-enable
            writing after a <see cref="T:Akka.IO.Tcp.CommandFailed" /> event. All <see cref="T:Akka.IO.Tcp.WriteCommand" /> processed by the
            connection actor between the first <see cref="T:Akka.IO.Tcp.CommandFailed" /> and subsequent reception of
            this message will also be rejected with <see cref="T:Akka.IO.Tcp.CommandFailed" />.
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.ResumeWriting.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.SuspendReading">
            <summary>
            Sending this command to the connection actor will disable reading from the TCP
            socket. TCP flow-control will then propagate backpressure to the sender side
            as buffers fill up on either end. To re-enable reading send <see cref="T:Akka.IO.Tcp.ResumeReading" />.
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.SuspendReading.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.ResumeReading">
            <summary>
            This command needs to be sent to the connection actor after a <see cref="T:Akka.IO.Tcp.SuspendReading" />
            command in order to resume reading from the socket.
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.ResumeReading.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.ResumeAccepting">
            <summary>
            This message enables the accepting of the next connection if read throttling is enabled
            for connection actors.
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.ResumeAccepting.BatchSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.ResumeAccepting.#ctor(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="batchSize">TBD</param>
        </member>
        <member name="T:Akka.IO.Tcp.Event">
            <summary>
            Common interface for all events generated by the TCP layer actors.
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Received">
            <summary>
            Whenever data are read from a socket they will be transferred within this
            class to the handler actor which was designated in the <see cref="T:Akka.IO.Tcp.Register" /> message.
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.Received.#ctor(Akka.IO.ByteString)">
            <summary>
            TBD
            </summary>
            <param name="data">TBD</param>
        </member>
        <member name="P:Akka.IO.Tcp.Received.Data">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Connected">
            <summary>
            The connection actor sends this message either to the sender of a <see cref="T:Akka.IO.Tcp.Connect" />
            command (for outbound) or to the handler for incoming connections designated
            in the <see cref="T:Akka.IO.Tcp.Bind" /> message. The connection is characterized by the `remoteAddress`
            and `localAddress` TCP endpoints.
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.Connected.#ctor(System.Net.EndPoint,System.Net.EndPoint)">
            <summary>
            TBD
            </summary>
            <param name="remoteAddress">TBD</param>
            <param name="localAddress">TBD</param>
        </member>
        <member name="P:Akka.IO.Tcp.Connected.RemoteAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Connected.LocalAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.CommandFailed">
            <summary>
            Whenever a command cannot be completed, the queried actor will reply with
            this message, wrapping the original command which failed.
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.CommandFailed.#ctor(Akka.IO.Tcp.Command)">
            <summary>
            TBD
            </summary>
            <param name="cmd">TBD</param>
        </member>
        <member name="P:Akka.IO.Tcp.CommandFailed.Cmd">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.WritingResumed">
            <summary>
            When `useResumeWriting` is in effect as indicated in the <see cref="T:Akka.IO.Tcp.Register" /> message,
            the <see cref="T:Akka.IO.Tcp.ResumeWriting" /> command will be acknowledged by this message type, upon
            which it is safe to send at least one write. This means that all writes preceding
            the first <see cref="T:Akka.IO.Tcp.CommandFailed" /> message have been enqueued to the O/S kernel at this
            point.
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.WritingResumed.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Bound">
            <summary>
            The sender of a <see cref="T:Akka.IO.Tcp.Bind" /> command willin case of successreceive confirmation
            in this form. If the bind address indicated a 0 port number, then the contained
            `localAddress` can be used to find out which port was automatically assigned.
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Bound.LocalAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.Bound.#ctor(System.Net.EndPoint)">
            <summary>
            TBD
            </summary>
            <param name="localAddress">TBD</param>
        </member>
        <member name="T:Akka.IO.Tcp.Unbound">
            <summary>
            The sender of an <see cref="T:Akka.IO.Tcp.Unbind" /> command will receive confirmation through this
            message once the listening socket has been closed.
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.Unbound.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.ConnectionClosed">
            <summary>
            This is the common interface for all events which indicate that a connection
            has been closed or half-closed.
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.ConnectionClosed.IsAborted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.ConnectionClosed.IsConfirmed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.ConnectionClosed.IsPeerClosed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.ConnectionClosed.IsErrorClosed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.ConnectionClosed.GetErrorCause">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Closed">
            <summary>
            The connection has been closed normally in response to a <see cref="T:Akka.IO.Tcp.Close" /> command.
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.Closed.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.Aborted">
            <summary>
            The connection has been aborted in response to an <see cref="T:Akka.IO.Tcp.Abort" /> command.
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.Aborted.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.Aborted.IsAborted">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.ConfirmedClosed">
            <summary>
            The connection has been half-closed by us and then half-close by the peer
            in response to a <see cref="T:Akka.IO.Tcp.ConfirmedClose" /> command.
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.ConfirmedClosed.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.ConfirmedClosed.IsConfirmed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.PeerClosed">
            <summary>
            The peer has closed its writing half of the connection.
            </summary>
        </member>
        <member name="F:Akka.IO.Tcp.PeerClosed.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Tcp.PeerClosed.IsPeerClosed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Tcp.ErrorClosed">
            <summary>
            The connection has been closed due to an IO error.
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.ErrorClosed.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
        </member>
        <member name="P:Akka.IO.Tcp.ErrorClosed.IsErrorClosed">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Tcp.ErrorClosed.GetErrorCause">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.TcpExt">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.TcpExt.TcpSettings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpExt.TcpSettings.#ctor(Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
        </member>
        <member name="P:Akka.IO.TcpExt.TcpSettings.NrOfSelectors">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpExt.TcpSettings.BatchAcceptLimit">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpExt.TcpSettings.DirectBufferSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpExt.TcpSettings.MaxDirectBufferPoolSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpExt.TcpSettings.RegisterTimeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpExt.TcpSettings.ReceivedMessageSizeLimit">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpExt.TcpSettings.ManagementDispatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpExt.TcpSettings.FileIODispatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpExt.TcpSettings.TransferToLimit">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpExt.TcpSettings.FinishConnectRetries">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpExt.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
        </member>
        <member name="P:Akka.IO.TcpExt.Manager">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpExt.GetManager">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.IO.TcpExt.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpExt.BufferPool">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpExt.FileIoDispatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.TcpMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpMessage.Connect(System.Net.EndPoint,System.Net.EndPoint,System.Collections.Generic.IEnumerable{Akka.IO.Inet.SocketOption},System.Nullable{System.TimeSpan},System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="remoteAddress">TBD</param>
            <param name="localAddress">TBD</param>
            <param name="options">TBD</param>
            <param name="timeout">TBD</param>
            <param name="pullMode">TDB</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpMessage.Connect(System.Net.EndPoint)">
            <summary>
            TBD
            </summary>
            <param name="remoteAddress">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpMessage.Bind(Akka.Actor.IActorRef,System.Net.EndPoint,System.Int32,System.Collections.Generic.IEnumerable{Akka.IO.Inet.SocketOption},System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="endpoint">TBD</param>
            <param name="backlog">TBD</param>
            <param name="options">TBD</param>
            <param name="pullMode">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpMessage.Bind(Akka.Actor.IActorRef,System.Net.EndPoint,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="endpoint">TBD</param>
            <param name="backlog">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpMessage.Register(Akka.Actor.IActorRef,System.Boolean,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="keepOpenOnPeerClosed">TBD</param>
            <param name="useResumeWriting">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpMessage.Unbind">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpMessage.Close">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpMessage.ConfirmedClose">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpMessage.Abort">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpMessage.NoAck(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="token">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpMessage.Write(Akka.IO.ByteString,Akka.IO.Tcp.Event)">
            <summary>
            TBD
            </summary>
            <param name="data">TBD</param>
            <param name="ack">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpMessage.ResumeWriting">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpMessage.SuspendReading">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpMessage.ResumeReading">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpMessage.ResumeAccepting(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="batchSize">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.TcpExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpExtensions.Tcp(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.TcpConnection">
              Base class for TcpIncomingConnection and TcpOutgoingConnection.
            
              INTERNAL API
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpConnection.Tcp">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpConnection.Log">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpConnection.Channel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpConnection.#ctor(Akka.IO.TcpExt,Akka.IO.SocketChannel,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="tcp">TBD</param>
            <param name="channel">TBD</param>
            <param name="pullMode">TBD</param>
        </member>
        <member name="M:Akka.IO.TcpConnection.WaitingForRegistration(Akka.IO.ChannelRegistration,Akka.Actor.IActorRef)">
            connection established, waiting for registration from user handler 
        </member>
        <member name="M:Akka.IO.TcpConnection.Connected(Akka.IO.TcpConnection.ConnectionInfo)">
            normal connected state 
        </member>
        <member name="M:Akka.IO.TcpConnection.PeerSentEOF(Akka.IO.TcpConnection.ConnectionInfo)">
            the peer sent EOF first, but we may still want to send 
        </member>
        <member name="M:Akka.IO.TcpConnection.ClosingWithPendingWrite(Akka.IO.TcpConnection.ConnectionInfo,Akka.Actor.IActorRef,Akka.IO.Tcp.ConnectionClosed)">
            connection is closing but a write has to be finished first 
        </member>
        <member name="M:Akka.IO.TcpConnection.Closing(Akka.IO.TcpConnection.ConnectionInfo,Akka.Actor.IActorRef)">
            connection is closed on our side and we're waiting from confirmation from the other side 
        </member>
        <member name="M:Akka.IO.TcpConnection.CompleteConnect(Akka.IO.ChannelRegistration,Akka.Actor.IActorRef,System.Collections.Generic.IEnumerable{Akka.IO.Inet.SocketOption})">
            used in subclasses to start the common machinery above once a channel is connected 
            <summary>
            TBD
            </summary>
            <param name="registration">TBD</param>
            <param name="commander">TBD</param>
            <param name="options">TBD</param>
        </member>
        <member name="M:Akka.IO.TcpConnection.StopWith(Akka.IO.TcpConnection.CloseInformation)">
            <summary>
            TBD
            </summary>
            <param name="closeInfo">TBD</param>
        </member>
        <member name="M:Akka.IO.TcpConnection.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpConnection.PostRestart(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="reason">TBD</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">TBD</exception>
        </member>
        <member name="T:Akka.IO.TcpConnection.CloseInformation">
            Used to transport information to the postStop method to notify
            interested party about a connection close.
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpConnection.CloseInformation.NotificationsTo">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpConnection.CloseInformation.ClosedEvent">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpConnection.CloseInformation.#ctor(System.Collections.Generic.ISet{Akka.Actor.IActorRef},Akka.IO.Tcp.Event)">
            <summary>
            TBD
            </summary>
            <param name="notificationsTo">TBD</param>
            <param name="closedEvent">TBD</param>
        </member>
        <member name="T:Akka.IO.TcpConnection.ConnectionInfo">
            Groups required connection-related data that are only available once the connection has been fully established.
        </member>
        <member name="T:Akka.IO.TcpIncomingConnection">
             An actor handling the connection state machine for an incoming, already connected
             SocketChannel.
            
             INTERNAL API
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpIncomingConnection.#ctor(Akka.IO.TcpExt,Akka.IO.SocketChannel,Akka.IO.IChannelRegistry,Akka.Actor.IActorRef,System.Collections.Generic.IEnumerable{Akka.IO.Inet.SocketOption},System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="tcp">TBD</param>
            <param name="channel">TBD</param>
            <param name="registry">TBD</param>
            <param name="bindHandler">TBD</param>
            <param name="options">TBD</param>
            <param name="readThrottling">TBD</param>
        </member>
        <member name="M:Akka.IO.TcpIncomingConnection.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.TcpListener">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.TcpListener.RegisterIncoming">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpListener.RegisterIncoming.#ctor(Akka.IO.SocketChannel)">
            <summary>
            TBD
            </summary>
            <param name="channel">TBD</param>
        </member>
        <member name="P:Akka.IO.TcpListener.RegisterIncoming.Channel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.TcpListener.RegisterIncoming.FailureMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.TcpListener.FailedRegisterIncoming">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpListener.FailedRegisterIncoming.#ctor(Akka.IO.SocketChannel)">
            <summary>
            TBD
            </summary>
            <param name="channel">TBD</param>
        </member>
        <member name="P:Akka.IO.TcpListener.FailedRegisterIncoming.Channel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpListener.#ctor(Akka.Actor.IActorRef,Akka.IO.TcpExt,Akka.IO.IChannelRegistry,Akka.Actor.IActorRef,Akka.IO.Tcp.Bind)">
            <summary>
            TBD
            </summary>
            <param name="selectorRouter">TBD</param>
            <param name="tcp">TBD</param>
            <param name="channelRegistry">TBD</param>
            <param name="bindCommander">TBD</param>
            <param name="bind">TBD</param>
        </member>
        <member name="M:Akka.IO.TcpListener.SupervisorStrategy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpListener.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.TcpListener.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.TcpManager">
             TODO: CLRify comment
             
             INTERNAL API
            
             TcpManager is a facade for accepting commands (<see cref="T:Akka.IO.Tcp.Command"/>) to open client or server TCP connections.
            
             TcpManager is obtainable by calling {{{ IO(Tcp) }}} (see [[akka.io.IO]] and [[akka.io.Tcp]])
            
             == Bind ==
            
             To bind and listen to a local address, a <see cref="T:Akka.IO.Tcp.Bind"/> command must be sent to this actor. If the binding
             was successful, the sender of the <see cref="T:Akka.IO.Tcp.Bind"/> will be notified with a <see cref="T:Akka.IO.Tcp.Bound"/>
             message. The sender() of the <see cref="T:Akka.IO.Tcp.Bound"/> message is the Listener actor (an internal actor responsible for
             listening to server events). To unbind the port an <see cref="T:Akka.IO.Tcp.Unbind"/> message must be sent to the Listener actor.
            
             If the bind request is rejected because the Tcp system is not able to register more channels (see the nr-of-selectors
             and max-channels configuration options in the akka.io.tcp section of the configuration) the sender will be notified
             with a <see cref="T:Akka.IO.Tcp.CommandFailed"/> message. This message contains the original command for reference.
            
             When an inbound TCP connection is established, the handler will be notified by a <see cref="T:Akka.IO.Tcp.Connected"/> message.
             The sender of this message is the Connection actor (an internal actor representing the TCP connection). At this point
             the procedure is the same as for outbound connections (see section below).
            
             == Connect ==
            
             To initiate a connection to a remote server, a <see cref="T:Akka.IO.Tcp.Connect"/> message must be sent to this actor. If the
             connection succeeds, the sender() will be notified with a <see cref="T:Akka.IO.Tcp.Connected"/> message. The sender of the
             <see cref="T:Akka.IO.Tcp.Connected"/> message is the Connection actor (an internal actor representing the TCP connection). Before
             starting to use the connection, a handler must be registered to the Connection actor by sending a <see cref="T:Akka.IO.Tcp.Register"/>
             command message. After a handler has been registered, all incoming data will be sent to the handler in the form of
             <see cref="T:Akka.IO.Tcp.Received"/> messages. To write data to the connection, a <see cref="T:Akka.IO.Tcp.Write"/> message must be sent
             to the Connection actor.
            
             If the connect request is rejected because the Tcp system is not able to register more channels (see the nr-of-selectors
             and max-channels configuration options in the akka.io.tcp section of the configuration) the sender will be notified
             with a <see cref="T:Akka.IO.Tcp.CommandFailed"/> message. This message contains the original command for reference.
            
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpManager.#ctor(Akka.IO.TcpExt)">
            <summary>
            TBD
            </summary>
            <param name="tcp">TBD</param>
        </member>
        <member name="M:Akka.IO.TcpManager.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="m">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.TcpOutgoingConnection">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.TcpOutgoingConnection.#ctor(Akka.IO.TcpExt,Akka.IO.IChannelRegistry,Akka.Actor.IActorRef,Akka.IO.Tcp.Connect)">
            <summary>
            TBD
            </summary>
            <param name="tcp">TBD</param>
            <param name="channelRegistry">TBD</param>
            <param name="commander">TBD</param>
            <param name="connect">TBD</param>
        </member>
        <member name="M:Akka.IO.TcpOutgoingConnection.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.Udp">
             <summary>
             UDP Extension for Akkas IO layer.
            
             This extension implements the connectionless UDP protocol without
             calling `connect` on the underlying sockets, i.e. without restricting
             from whom data can be received. For "connected" UDP mode see <see cref="T:Akka.IO.UdpConnected"/>.
            
             For a full description of the design and philosophy behind this IO
             implementation please refer to <see href="http://doc.akka.io/">the Akka online documentation</see>.
             </summary>
        </member>
        <member name="F:Akka.IO.Udp.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Udp.Manager(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.Udp.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.Udp.Message">
            <summary>The common interface for <see cref="T:Akka.IO.Udp.Command"/> and <see cref="T:Akka.IO.Udp.Event"/>.</summary>
        </member>
        <member name="T:Akka.IO.Udp.Command">
            <summary>The common type of all commands supported by the UDP implementation.</summary>
        </member>
        <member name="P:Akka.IO.Udp.Command.FailureMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.NoAck">
            <summary>
            Each <see cref="T:Akka.IO.Udp.Send"/> can optionally request a positive acknowledgment to be sent
            to the commanding actor. If such notification is not desired the <see cref="P:Akka.IO.Udp.Send.Ack"/>
            must be set to an instance of this class. The token contained within can be used
            to recognize which write failed when receiving a <see cref="T:Akka.IO.Udp.CommandFailed"/> message.
            </summary>
        </member>
        <member name="F:Akka.IO.Udp.NoAck.Instance">
            <summary>
            Default <see cref="T:Akka.IO.Udp.NoAck"/> instance which is used when no acknowledgment information is
            explicitly provided. Its "token" is <see langword="null"/>.
            </summary>
        </member>
        <member name="M:Akka.IO.Udp.NoAck.#ctor(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="token">TBD</param>
        </member>
        <member name="P:Akka.IO.Udp.NoAck.Token">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.Send">
             <summary>
             This message is understood by the "simple sender" which can be obtained by
             sending the <see cref="T:Akka.IO.Udp.SimpleSender"/> query to the <see cref="P:Akka.IO.UdpExt.Manager"/> as well as by
             the listener actors which are created in response to <see cref="T:Akka.IO.Udp.Bind"/>. It will send
             the given payload data as one UDP datagram to the given target address. The
             UDP actor will respond with <see cref="T:Akka.IO.Udp.CommandFailed"/> if the send could not be
             enqueued to the O/S kernel because the send buffer was full. If the given
             `ack` is not of type <see cref="T:Akka.IO.Udp.NoAck"/> the UDP actor will reply with the given
             object as soon as the datagram has been successfully enqueued to the O/S
             kernel.
            
             The sending UDP sockets address belongs to the "simple sender" which does
             not handle inbound datagrams and sends from an ephemeral port; therefore
             sending using this mechanism is not suitable if replies are expected, use
             <see cref="T:Akka.IO.Udp.Bind"/> in that case.
             </summary>
        </member>
        <member name="M:Akka.IO.Udp.Send.#ctor(Akka.IO.ByteString,System.Net.EndPoint,Akka.IO.Udp.Event)">
            <summary>
            TBD
            </summary>
            <param name="payload">TBD</param>
            <param name="target">TBD</param>
            <param name="ack">TBD</param>
            <exception cref="T:System.ArgumentNullException">TBD</exception>
        </member>
        <member name="P:Akka.IO.Udp.Send.Payload">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Udp.Send.Target">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Udp.Send.Ack">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Udp.Send.WantsAck">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Udp.Send.Create(Akka.IO.ByteString,System.Net.EndPoint)">
            <summary>
            TBD
            </summary>
            <param name="data">TBD</param>
            <param name="target">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.Udp.Bind">
            <summary>
             Send this message to the <see cref="P:Akka.IO.UdpExt.Manager"/> in order to bind to the given
             local port (or an automatically assigned one if the port number is zero).
             The listener actor for the newly bound port will reply with a <see cref="T:Akka.IO.Udp.Bound"/>
             message, or the manager will reply with a <see cref="T:Akka.IO.Udp.CommandFailed"/> message.
            </summary>
        </member>
        <member name="M:Akka.IO.Udp.Bind.#ctor(Akka.Actor.IActorRef,System.Net.EndPoint,System.Collections.Generic.IEnumerable{Akka.IO.Inet.SocketOption})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="localAddress">TBD</param>
            <param name="options">TBD</param>
        </member>
        <member name="P:Akka.IO.Udp.Bind.Handler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Udp.Bind.LocalAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Udp.Bind.Options">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.Unbind">
            <summary>
            Send this message to the listener actor that previously sent a <see cref="T:Akka.IO.Udp.Bound"/>
            message in order to close the listening socket. The recipient will reply
            with an <see cref="T:Akka.IO.Udp.Unbound"/> message.
            </summary>
        </member>
        <member name="F:Akka.IO.Udp.Unbind.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.SimpleSender">
             <summary>
             Retrieve a reference to a "simple sender" actor of the UDP extension.
             The newly created "simple sender" will reply with the <see cref="T:Akka.IO.Udp.SimpleSenderReady" /> notification.
            
             The "simple sender" is a convenient service for being able to send datagrams
             when the originating address is meaningless, i.e. when no reply is expected.
            
             The "simple sender" will not stop itself, you will have to send it a <see cref="T:Akka.Actor.PoisonPill"/>
             when you want to close the socket.
             </summary>
        </member>
        <member name="F:Akka.IO.Udp.SimpleSender.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Udp.SimpleSender.#ctor(System.Collections.Generic.IEnumerable{Akka.IO.Inet.SocketOption})">
            <summary>
            TBD
            </summary>
            <param name="options">TBD</param>
        </member>
        <member name="P:Akka.IO.Udp.SimpleSender.Options">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.SuspendReading">
            <summary>
            Send this message to a listener actor (which sent a <see cref="T:Akka.IO.Udp.Bound"/> message) to
            have it stop reading datagrams from the network. If the O/S kernels receive
            buffer runs full then subsequent datagrams will be silently discarded.
            Re-enable reading from the socket using the `ResumeReading` command.
            </summary>
        </member>
        <member name="F:Akka.IO.Udp.SuspendReading.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.ResumeReading">
            <summary>
             This message must be sent to the listener actor to re-enable reading from
             the socket after a `SuspendReading` command.
            </summary>
        </member>
        <member name="F:Akka.IO.Udp.ResumeReading.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.Event">
            <summary>The common type of all events emitted by the UDP implementation.</summary>
        </member>
        <member name="T:Akka.IO.Udp.Received">
            <summary>
             When a listener actor receives a datagram from its socket it will send
             it to the handler designated in the <see cref="T:Akka.IO.Udp.Bind"/> message using this message type.
            </summary>
        </member>
        <member name="M:Akka.IO.Udp.Received.#ctor(Akka.IO.ByteString,System.Net.EndPoint)">
            <summary>
            TBD
            </summary>
            <param name="data">TBD</param>
            <param name="sender">TBD</param>
        </member>
        <member name="P:Akka.IO.Udp.Received.Data">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Udp.Received.Sender">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.CommandFailed">
            <summary>
            When a command fails it will be replied to with this message type,
            wrapping the failing command object.
            </summary>
        </member>
        <member name="M:Akka.IO.Udp.CommandFailed.#ctor(Akka.IO.Udp.Command)">
            <summary>
            TBD
            </summary>
            <param name="cmd">TBD</param>
        </member>
        <member name="P:Akka.IO.Udp.CommandFailed.Cmd">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.Bound">
            <summary>
            This message is sent by the listener actor in response to a <see cref="T:Akka.IO.Udp.Bind"/> command.
            If the address to bind to specified a port number of zero, then this message
            can be inspected to find out which port was automatically assigned.
            </summary>
        </member>
        <member name="M:Akka.IO.Udp.Bound.#ctor(System.Net.EndPoint)">
            <summary>
            TBD
            </summary>
            <param name="localAddress">TBD</param>
        </member>
        <member name="P:Akka.IO.Udp.Bound.LocalAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.SimpleSenderReady">
            <summary> The "simple sender" sends this message type in response to a <see cref="T:Akka.IO.Udp.SimpleSender"/> query. </summary>
        </member>
        <member name="F:Akka.IO.Udp.SimpleSenderReady.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.Unbound">
            <summary>
            This message is sent by the listener actor in response to an `Unbind` command
            after the socket has been closed.
            </summary>
        </member>
        <member name="F:Akka.IO.Udp.Unbound.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.SO">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.Udp.SO.Broadcast">
             <summary>
             <see cref="T:Akka.IO.Inet.SocketOption"/> to set the SO_BROADCAST option
            
             For more information see cref="System.Net.Sockets.Socket.EnableBroadcast"/>
             </summary>
        </member>
        <member name="M:Akka.IO.Udp.SO.Broadcast.#ctor(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="on">TBD</param>
        </member>
        <member name="P:Akka.IO.Udp.SO.Broadcast.On">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Udp.SO.Broadcast.BeforeDatagramBind(System.Net.Sockets.Socket)">
            <summary>
            TBD
            </summary>
            <param name="s">TBD</param>
        </member>
        <member name="T:Akka.IO.Udp.UdpSettings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.Udp.UdpSettings.#ctor(Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="config">TBD</param>
        </member>
        <member name="P:Akka.IO.Udp.UdpSettings.NrOfSelectors">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Udp.UdpSettings.DirectBufferSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Udp.UdpSettings.MaxDirectBufferPoolSize">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Udp.UdpSettings.BatchReceiveLimit">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.Udp.UdpSettings.ManagementDispatcher">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpExt">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.UdpExt.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
        </member>
        <member name="P:Akka.IO.UdpExt.Manager">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.UdpExt.Setting">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.UdpExt.BufferPool">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.UdpExtensions.Udp(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.UdpConnected">
             <summary>
             UDP Extension for Akkas IO layer.
            
             This extension implements the connectionless UDP protocol with
             calling `connect` on the underlying sockets, i.e. with restricting
             from whom data can be received. For "unconnected" UDP mode see <see cref="T:Akka.IO.Udp"/>.
            
             For a full description of the design and philosophy behind this IO
             implementation please refer to <see href="http://doc.akka.io/">the Akka online documentation</see>.
             </summary>
        </member>
        <member name="F:Akka.IO.UdpConnected.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.UdpConnected.CreateExtension(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.UdpConnected.Message">
            <summary>
            The common interface for <see cref="T:Akka.IO.UdpConnected.Command"/> and <see cref="T:Akka.IO.UdpConnected.Event"/>.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Command">
            <summary>
            The common type of all commands supported by the UDP implementation.
            </summary>
        </member>
        <member name="M:Akka.IO.UdpConnected.Command.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.UdpConnected.Command.FailureMessage">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.NoAck">
            <summary>
            Each <see cref="T:Akka.IO.UdpConnected.Send"/> can optionally request a positive acknowledgment to be sent
            to the commanding actor. If such notification is not desired the <see cref="P:Akka.IO.UdpConnected.Send.Ack"/>
            must be set to an instance of this class. The token contained within can be used
            to recognize which write failed when receiving a <see cref="T:Akka.IO.UdpConnected.CommandFailed"/> message.
            </summary>
        </member>
        <member name="F:Akka.IO.UdpConnected.NoAck.Instance">
            <summary>
            Default <see cref="T:Akka.IO.UdpConnected.NoAck"/> instance which is used when no acknowledgment information is
            explicitly provided. Its "token" is <see langword="null"/>.
            </summary>
        </member>
        <member name="M:Akka.IO.UdpConnected.NoAck.#ctor(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="token">TBD</param>
        </member>
        <member name="P:Akka.IO.UdpConnected.NoAck.Token">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Send">
            <summary>
            This message is understood by the connection actors to send data to their
            designated destination. The connection actor will respond with
            <see cref="T:Akka.IO.UdpConnected.CommandFailed"/> if the send could not be enqueued to the O/S kernel
            because the send buffer was full. If the given `ack` is not of type <see cref="T:Akka.IO.UdpConnected.NoAck"/>
            the connection actor will reply with the given object as soon as the datagram
            has been successfully enqueued to the O/S kernel.
            </summary>
        </member>
        <member name="M:Akka.IO.UdpConnected.Send.#ctor(Akka.IO.ByteString,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="payload">TBD</param>
            <param name="ack">TBD</param>
            <exception cref="T:System.ArgumentNullException">TBD</exception>
        </member>
        <member name="P:Akka.IO.UdpConnected.Send.Payload">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.UdpConnected.Send.Ack">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.UdpConnected.Send.WantsAck">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.UdpConnected.Send.Create(Akka.IO.ByteString)">
            <summary>
            TBD
            </summary>
            <param name="data">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.UdpConnected.Connect">
            <summary>
            Send this message to the <see cref="P:Akka.IO.UdpExt.Manager"/> in order to bind to a local
            port (optionally with the chosen `localAddress`) and create a UDP socket
            which is restricted to sending to and receiving from the given `remoteAddress`.
            All received datagrams will be sent to the designated `handler` actor.
            </summary>
        </member>
        <member name="M:Akka.IO.UdpConnected.Connect.#ctor(Akka.Actor.IActorRef,System.Net.EndPoint,System.Net.EndPoint,System.Collections.Generic.IEnumerable{Akka.IO.Inet.SocketOption})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="remoteAddress">TBD</param>
            <param name="localAddress">TBD</param>
            <param name="options">TBD</param>
        </member>
        <member name="P:Akka.IO.UdpConnected.Connect.Handler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.UdpConnected.Connect.RemoteAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.UdpConnected.Connect.LocalAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.UdpConnected.Connect.Options">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Disconnect">
            <summary>
            Send this message to a connection actor (which had previously sent the
            <see cref="T:Akka.IO.UdpConnected.Connected"/> message) in order to close the socket. The connection actor
            will reply with a <see cref="T:Akka.IO.UdpConnected.Disconnected"/> message.
            </summary>
        </member>
        <member name="F:Akka.IO.UdpConnected.Disconnect.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.SuspendReading">
            <summary>
            Send this message to a listener actor (which sent a <see cref="T:Akka.IO.Udp.Bound"/> message) to
            have it stop reading datagrams from the network. If the O/S kernels receive
            buffer runs full then subsequent datagrams will be silently discarded.
            Re-enable reading from the socket using the `ResumeReading` command.
            </summary>
        </member>
        <member name="F:Akka.IO.UdpConnected.SuspendReading.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.ResumeReading">
            <summary>
            This message must be sent to the listener actor to re-enable reading from
            the socket after a `SuspendReading` command.
            </summary>
        </member>
        <member name="F:Akka.IO.UdpConnected.ResumeReading.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Event">
            <summary>
            The common type of all events emitted by the UDP implementation.
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Received">
            <summary>
            When a connection actor receives a datagram from its socket it will send
            it to the handler designated in the <see cref="T:Akka.IO.Udp.Bind"/> message using this message type.
            </summary>
        </member>
        <member name="M:Akka.IO.UdpConnected.Received.#ctor(Akka.IO.ByteString)">
            <summary>
            TBD
            </summary>
            <param name="data">TBD</param>
        </member>
        <member name="P:Akka.IO.UdpConnected.Received.Data">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.CommandFailed">
            <summary>
            When a command fails it will be replied to with this message type,
            wrapping the failing command object.
            </summary>
        </member>
        <member name="M:Akka.IO.UdpConnected.CommandFailed.#ctor(Akka.IO.UdpConnected.Command)">
            <summary>
            TBD
            </summary>
            <param name="cmd">TBD</param>
        </member>
        <member name="P:Akka.IO.UdpConnected.CommandFailed.Cmd">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Connected">
            <summary>
            This message is sent by the connection actor to the actor which sent the
            <see cref="T:Akka.IO.UdpConnected.Connect"/> message when the UDP socket has been bound to the local and
            remote addresses given.
            </summary>
        </member>
        <member name="F:Akka.IO.UdpConnected.Connected.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnected.Disconnected">
            <summary>
            This message is sent by the connection actor to the actor which sent the
            `Disconnect` message when the UDP socket has been closed.
            </summary>
        </member>
        <member name="F:Akka.IO.UdpConnected.Disconnected.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnectedExt">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.UdpConnectedExt.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
        </member>
        <member name="P:Akka.IO.UdpConnectedExt.Manager">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.UdpConnectedExt.BufferPool">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.UdpConnectedExt.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpConnectedManager">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.UdpConnectedManager.#ctor(Akka.IO.UdpConnectedExt)">
            <summary>
            TBD
            </summary>
            <param name="udpConn">TBD</param>
        </member>
        <member name="M:Akka.IO.UdpConnectedManager.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="m">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.UdpConnection">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.UdpConnection.#ctor(Akka.IO.UdpConnectedExt,Akka.IO.IChannelRegistry,Akka.Actor.IActorRef,Akka.IO.UdpConnected.Connect)">
            <summary>
            TBD
            </summary>
            <param name="udpConn">TBD</param>
            <param name="channelRegistry">TBD</param>
            <param name="commander">TBD</param>
            <param name="connect">TBD</param>
        </member>
        <member name="M:Akka.IO.UdpConnection.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.UdpConnection.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpListener">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.UdpListener.#ctor(Akka.IO.UdpExt,Akka.IO.IChannelRegistry,Akka.Actor.IActorRef,Akka.IO.Udp.Bind)">
            <summary>
            TBD
            </summary>
            <param name="udp">TBD</param>
            <param name="channelRegistry">TBD</param>
            <param name="bindCommander">TBD</param>
            <param name="bind">TBD</param>
        </member>
        <member name="P:Akka.IO.UdpListener.Channel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.UdpListener.Udp">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.UdpListener.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.UdpListener.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.UdpManager">
             TODO: CLRify comment
             
             INTERNAL API
            
             UdpManager is a facade for simple fire-and-forget style UDP operations
            
             UdpManager is obtainable by calling {{{ IO(Udp) }}} (see [[akka.io.IO]] and [[akka.io.Udp]])
            
             *Warning!* Udp uses [[java.nio.channels.DatagramChannel#send]] to deliver datagrams, and as a consequence if a
             security manager  has been installed then for each datagram it will verify if the target address and port number are
             permitted. If this performance overhead is undesirable use the connection style Udp extension.
            
             == Bind and send ==
            
             To bind and listen to a local address, a <see cref="T:Akka.IO.Udp.Bind"/> command must be sent to this actor. If the binding
             was successful, the sender of the <see cref="T:Akka.IO.Udp.Bind"/> will be notified with a <see cref="T:Akka.IO.Udp.Bound"/>
             message. The sender of the <see cref="T:Akka.IO.Udp.Bound"/> message is the Listener actor (an internal actor responsible for
             listening to server events). To unbind the port an <see cref="T:Akka.IO.Udp.Unbind"/> message must be sent to the Listener actor.
            
             If the bind request is rejected because the Udp system is not able to register more channels (see the <c>nr-of-selectors</c>
             and <c>max-channels</c> configuration options in the <c>akka.io.udp</c> section of the configuration) the sender will be notified
             with a <see cref="T:Akka.IO.Udp.CommandFailed"/> message. This message contains the original command for reference.
            
             The handler provided in the <see cref="T:Akka.IO.Udp.Bind"/> message will receive inbound datagrams to the bound port
             wrapped in <see cref="T:Akka.IO.Udp.Received"/> messages which contain the payload of the datagram and the sender address.
            
             UDP datagrams can be sent by sending <see cref="T:Akka.IO.Udp.Send"/> messages to the Listener actor. The sender port of the
             outbound datagram will be the port to which the Listener is bound.
            
             == Simple send ==
            
             Udp provides a simple method of sending UDP datagrams if no reply is expected. To acquire the Sender actor
             a SimpleSend message has to be sent to the manager. The sender of the command will be notified by a SimpleSenderReady
             message that the service is available. UDP datagrams can be sent by sending <see cref="T:Akka.IO.Udp.Send"/> messages to the
             sender of SimpleSenderReady. All the datagrams will contain an ephemeral local port as sender and answers will be
             discarded.
            
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.UdpManager.#ctor(Akka.IO.UdpExt)">
            <summary>
            TBD
            </summary>
            <param name="udp">TBD</param>
        </member>
        <member name="M:Akka.IO.UdpManager.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="m">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.UdpSender">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.UdpSender.#ctor(Akka.IO.UdpExt,Akka.IO.IChannelRegistry,Akka.Actor.IActorRef,System.Collections.Generic.IEnumerable{Akka.IO.Inet.SocketOption})">
            <summary>
            TBD
            </summary>
            <param name="udp">TBD</param>
            <param name="channelRegistry">TBD</param>
            <param name="commander">TBD</param>
            <param name="options">TBD</param>
        </member>
        <member name="P:Akka.IO.UdpSender.Udp">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.UdpSender.Channel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.UdpSender.Receive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.UdpSender.PostStop">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.IO.WithUdpSend">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.WithUdpSend.Channel">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.WithUdpSend.Udp">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.WithUdpSend.SendHandlers(Akka.IO.ChannelRegistration)">
            <summary>
            TBD
            </summary>
            <param name="registration">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.ByteString">
            <summary>
            TBD
            </summary>
            <summary>
            A rope-like immutable data structure containing bytes.
            The goal of this structure is to reduce copying of arrays
            when concatenating and slicing sequences of bytes,
            and also providing a thread safe way of working with bytes.
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.FromArray(System.Byte[])">
            <summary>
            Creates a new ByteString by copying a byte array.
            </summary>
            <param name="array">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.FromArray(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a new ByteString by copying length bytes starting at offset from
            an Array.
            </summary>
            <param name="array">TBD</param>
            <param name="offset">TBD</param>
            <param name="length">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.FromString(System.String)">
            <summary>
            Creates a new ByteString which will contain the UTF-8 representation of the given String
            </summary>
            <param name="str">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.FromString(System.String,System.Text.Encoding)">
            <summary>
            Creates a new ByteString which will contain the representation of the given String in the given charset
            </summary>
            <param name="str">TBD</param>
            <param name="encoding">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.FromByteBuffer(Akka.IO.ByteBuffer)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.IO.ByteString.Empty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.NewBuilder">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.ByteString.ByteString1C">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1C.#ctor(System.Byte[])">
            <summary>
            TBD
            </summary>
            <param name="bytes">TBD</param>
        </member>
        <member name="P:Akka.IO.ByteString.ByteString1C.Item(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="idx">TBD</param>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1C.AsByteBuffer">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.IO.ByteString.ByteString1C.Count">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1C.Iterator">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1C.GetEnumerator">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1C.ToByteString1">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1C.Concat(Akka.IO.ByteString)">
            <summary>
            TBD
            </summary>
            <param name="that">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1C.Slice(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="from">TBD</param>
            <param name="until">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1C.DecodeString(System.Text.Encoding)">
            <summary>
            TBD
            </summary>
            <param name="charset">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.ByteString.ByteString1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="bytes">TBD</param>
            <param name="startIndex">TBD</param>
            <param name="length">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1.#ctor(System.Byte[])">
            <summary>
            TBD
            </summary>
            <param name="bytes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.IO.ByteString.ByteString1.Item(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="idx">TBD</param>
            <exception cref="T:System.IndexOutOfRangeException">TBD</exception>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1.AsByteBuffer">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1.Iterator">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1.IsCompact">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1.Compact">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.IO.ByteString.ByteString1.Count">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1.Concat(Akka.IO.ByteString)">
            <summary>
            TBD
            </summary>
            <param name="that">TBD</param>
            <exception cref="T:System.InvalidOperationException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1.DecodeString(System.Text.Encoding)">
            <summary>
            TBD
            </summary>
            <param name="charset">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteString1.GetEnumerator">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.ByteString.ByteStrings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.ByteStrings.#ctor(Akka.IO.ByteString.ByteString1[])">
            <summary>
            TBD
            </summary>
            <param name="byteStrings">TBD</param>
        </member>
        <member name="M:Akka.IO.ByteString.ByteStrings.#ctor(Akka.IO.ByteString.ByteString1[],System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="byteStrings">TBD</param>
            <param name="length">TBD</param>
        </member>
        <member name="P:Akka.IO.ByteString.ByteStrings.Item(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="idx">TBD</param>
            <exception cref="T:System.IndexOutOfRangeException">TBD</exception>
        </member>
        <member name="M:Akka.IO.ByteString.ByteStrings.AsByteBuffer">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteStrings.Iterator">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteStrings.GetEnumerator">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteStrings.Concat(Akka.IO.ByteString)">
            <summary>
            TBD
            </summary>
            <param name="that">TBD</param>
            <exception cref="T:System.InvalidOperationException">
            This exception is thrown if this <see cref="T:Akka.IO.ByteString"/> cannot be concatenated with <paramref name="that"/>.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteStrings.IsCompact">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ByteStrings.Compact">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.IO.ByteString.ByteStrings.Count">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.ByteString.ByteStrings.Items">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.ByteStrings.DecodeString(System.Text.Encoding)">
            <summary>
            TBD
            </summary>
            <param name="charset">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.IO.ByteString.Item(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="index">TBD</param>
        </member>
        <member name="M:Akka.IO.ByteString.AsByteBuffer">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.newBuilder">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.Iterator">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.IO.ByteString.Head">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.Tail">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.IO.ByteString.Last">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.Init">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.Slice(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="from">TBD</param>
            <param name="until">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.Take(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.TakeRight(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.Drop(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.DropRight(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.TakeWhile(System.Func{System.Byte,System.Boolean})">
            <summary>
            TBD
            </summary>
            <param name="p">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.DropWhile(System.Func{System.Byte,System.Boolean})">
            <summary>
            TBD
            </summary>
            <param name="p">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.Span(System.Func{System.Byte,System.Boolean})">
            <summary>
            TBD
            </summary>
            <param name="p">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.SplitAt(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.IndexWhere(System.Func{System.Byte,System.Boolean})">
            <summary>
            TBD
            </summary>
            <param name="p">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.IndexOf(System.Byte)">
            <summary>
            TBD
            </summary>
            <param name="elem">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.ToArray">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.Compact">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.IsCompact">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.GetEnumerator">
            <summary>
            N/A
            </summary>
            <exception cref="T:System.NotSupportedException">
            This exception is thrown automatically since iterators aren't supported in <see cref="T:Akka.IO.ByteString"/>.
            </exception>
            <returns>N/A</returns>
        </member>
        <member name="P:Akka.IO.ByteString.IsEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.ByteString.NonEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.IO.ByteString.Count">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteString.Concat(Akka.IO.ByteString)">
            <summary>
            TBD
            </summary>
            <param name="that">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.DecodeString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.DecodeString(System.Text.Encoding)">
            <summary>
            TBD
            </summary>
            <param name="charset">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.op_Addition(Akka.IO.ByteString,Akka.IO.ByteString)">
            <summary>
            TBD
            </summary>
            <param name="lhs">TBD</param>
            <param name="rhs">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.CopyToBuffer(Akka.IO.ByteBuffer)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.Create(Akka.IO.ByteBuffer)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.Create(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <param name="offset">TBD</param>
            <param name="length">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.Create(System.Byte[])">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.Equals(Akka.IO.ByteString)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteString.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.CompactByteString">
            <summary>
            TBD
            </summary>
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.IO.CompactByteString.EmptyCompactByteString">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.CompactByteString.FromString(System.String,System.Text.Encoding)">
            <summary>
            TBD
            </summary>
            <param name="str">TBD</param>
            <param name="encoding">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.CompactByteString.FromArray(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="array">TBD</param>
            <param name="offset">TBD</param>
            <param name="length">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.CompactByteString.IsCompact">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.CompactByteString.Compact">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.ByteStringBuilder">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteStringBuilder.FillArray(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="len">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteStringBuilder.FillByteBuffer(System.Int32,Akka.IO.ByteOrder,System.Action{Akka.IO.ByteBuffer})">
            <summary>
            TBD
            </summary>
            <param name="len">TBD</param>
            <param name="byteOrder">TBD</param>
            <param name="fill">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.IO.ByteStringBuilder.Length">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.IO.ByteStringBuilder.SizeHint(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="len">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteStringBuilder.Append(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            TBD
            </summary>
            <param name="xs">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteStringBuilder.PutByte(System.Byte)">
            <summary>
            TBD
            </summary>
            <param name="x">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteStringBuilder.PutShort(System.Int32,Akka.IO.ByteOrder)">
            <summary>
            TBD
            </summary>
            <param name="x">TBD</param>
            <param name="byteOrder">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteStringBuilder.PutInt(System.Int32,Akka.IO.ByteOrder)">
            <summary>
            TBD
            </summary>
            <param name="x">TBD</param>
            <param name="byteOrder">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteStringBuilder.PutBytes(System.Byte[])">
            <summary>
            TBD
            </summary>
            <param name="array">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteStringBuilder.PutBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="array">TBD</param>
            <param name="start">TBD</param>
            <param name="len">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteStringBuilder.op_Addition(Akka.IO.ByteStringBuilder,System.Byte)">
            <summary>
            TBD
            </summary>
            <param name="lhs">TBD</param>
            <param name="rhs">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.IO.ByteStringBuilder.Result">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.IO.ByteOrder">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.IO.ByteOrder.BigEndian">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.IO.ByteOrder.LittleEndian">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.NotUsed">
            <summary>
            This type is used in generic type signatures wherever the actual value is of no importance.
            It is a combination of F#s 'unit' and C#s 'void', which both have different issues when
            used from the other language. An example use-case is the materialized value of an Akka Stream for cases
            where no result shall be returned from materialization.
            </summary>
        </member>
        <member name="F:Akka.NotUsed.Instance">
            <summary>
            The singleton instance of <see cref="T:Akka.NotUsed"/>.
            </summary>
        </member>
        <member name="M:Akka.NotUsed.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.NotUsed.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.NotUsed.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.NotUsed.Equals(Akka.NotUsed)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.NotUsed.CompareTo(Akka.NotUsed)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.PatternMatch">
            <summary>
            Class PatternMatch.
            </summary>
        </member>
        <member name="M:Akka.PatternMatch.Match(System.Object)">
            <summary>
            Matches the specified target.
            </summary>
            <param name="target">The target.</param>
            <returns>Case.</returns>
        </member>
        <member name="M:Akka.PatternMatch.Match``1(System.Object)">
            <summary>
            Matches the specified target and return a result of target processing.
            </summary>
            <param name="target">The target.</param>
            <returns>Case.</returns>
        </member>
        <member name="T:Akka.IMatchResult">
            <summary>
            Interface IMatchResult
            </summary>
        </member>
        <member name="P:Akka.IMatchResult.WasHandled">
            <summary>
            Gets a value indicating whether [was handled].
            </summary>
            <value><c>true</c> if [was handled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Akka.Case">
            <summary>
            Class Case.
            </summary>
        </member>
        <member name="F:Akka.Case._message">
            <summary>
            The _message
            </summary>
        </member>
        <member name="F:Akka.Case._handled">
            <summary>
            The _handled
            </summary>
        </member>
        <member name="P:Akka.Case.WasHandled">
            <summary>
            Gets a value indicating whether [was handled].
            </summary>
            <value><c>true</c> if [was handled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Akka.Case.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Case"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Case.With``1(System.Action)">
            <summary>
            Withes the specified action.
            </summary>
            <typeparam name="TMessage">The type of the t message.</typeparam>
            <param name="action">The action.</param>
            <returns>Case.</returns>
        </member>
        <member name="M:Akka.Case.With``1(System.Action{``0})">
            <summary>
            Withes the specified action.
            </summary>
            <typeparam name="TMessage">The type of the t message.</typeparam>
            <param name="action">The action.</param>
            <returns>Case.</returns>
        </member>
        <member name="M:Akka.Case.Default(System.Action{System.Object})">
            <summary>
            Defaults the specified action.
            </summary>
            <param name="action">The action.</param>
            <returns>IMatchResult.</returns>
        </member>
        <member name="T:Akka.Case.AlwaysHandled">
            <summary>
            Class AlwaysHandled.
            </summary>
        </member>
        <member name="F:Akka.Case.AlwaysHandled.Instance">
            <summary>
            The instance
            </summary>
        </member>
        <member name="M:Akka.Case.AlwaysHandled.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Akka.Case.AlwaysHandled"/> class from being created.
            </summary>
        </member>
        <member name="P:Akka.Case.AlwaysHandled.WasHandled">
            <summary>
            Gets a value indicating whether [was handled].
            </summary>
            <value><c>true</c> if [was handled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Akka.Case`1">
            <summary>
            Class Case with returning result.
            </summary>
            <typeparam name="T">The type of return value</typeparam>
        </member>
        <member name="F:Akka.Case`1._message">
            <summary>
            The _message
            </summary>
        </member>
        <member name="F:Akka.Case`1._handled">
            <summary>
            The _handled
            </summary>
        </member>
        <member name="F:Akka.Case`1._result">
            <summary>
            The final result of execution
            </summary>
        </member>
        <member name="P:Akka.Case`1.WasHandled">
            <summary>
            Gets a value indicating whether [was handled].
            </summary>
            <value><c>true</c> if [was handled]; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Akka.Case`1.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Case"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Akka.Case`1.With``1(System.Func{`0})">
            <summary>
            Withes the specified action.
            </summary>
            <typeparam name="TMessage">The type of the t message.</typeparam>
            <param name="function">The function.</param>
            <returns>Case.</returns>
        </member>
        <member name="M:Akka.Case`1.With``1(System.Func{``0,`0})">
            <summary>
            Withes the specified action.
            </summary>
            <typeparam name="TMessage">The type of the t message.</typeparam>
            <param name="function">The action.</param>
            <returns>Case.</returns>
        </member>
        <member name="M:Akka.Case`1.ResultOrDefault(System.Func{System.Object,`0})">
            <summary>
            Defaults the specified action.
            </summary>
            <param name="function">The default function.</param>
            <returns>The result of the matching</returns>
        </member>
        <member name="T:Akka.Pattern.Backoff">
            <summary>
            Builds back-off options for creating a back-off supervisor. You can pass <see cref="T:Akka.Pattern.BackoffOptions"/> to <see cref="M:Akka.Pattern.BackoffSupervisor.Props(Akka.Actor.Props,System.String,System.TimeSpan,System.TimeSpan,System.Double)"/>.
            </summary>
        </member>
        <member name="M:Akka.Pattern.Backoff.OnFailure(Akka.Actor.Props,System.String,System.TimeSpan,System.TimeSpan,System.Double)">
            <summary>
            Back-off options for creating a back-off supervisor actor that expects a child actor to restart on failure.
            </summary>
            <param name="childProps">The <see cref="T:Akka.Actor.Props"/> of the child actor that will be started and supervised</param>
            <param name="childName">Name of the child actor</param>
            <param name="minBackoff">Minimum (initial) duration until the child actor will started again, if it is terminated</param>
            <param name="maxBackoff">The exponential back-off is capped to this duration</param>
            <param name="randomFactor">After calculation of the exponential back-off an additional random delay based on this factor is added, e.g. `0.2` adds up to `20%` delay. In order to skip this additional delay pass in `0`.</param>
        </member>
        <member name="M:Akka.Pattern.Backoff.OnStop(Akka.Actor.Props,System.String,System.TimeSpan,System.TimeSpan,System.Double)">
            <summary>
            Back-off options for creating a back-off supervisor actor that expects a child actor to stop on failure.
            </summary>
            <param name="childProps">The <see cref="T:Akka.Actor.Props"/> of the child actor that will be started and supervised</param>
            <param name="childName">Name of the child actor</param>
            <param name="minBackoff">Minimum (initial) duration until the child actor will started again, if it is terminated</param>
            <param name="maxBackoff">The exponential back-off is capped to this duration</param>
            <param name="randomFactor">After calculation of the exponential back-off an additional random delay based on this factor is added, e.g. `0.2` adds up to `20%` delay. In order to skip this additional delay pass in `0`.</param>
        </member>
        <member name="M:Akka.Pattern.BackoffOptions.WithAutoReset(System.TimeSpan)">
            <summary>
            Returns a new <see cref="T:Akka.Pattern.BackoffOptions"/> with automatic back-off reset. The back-off algorithm is reset if the child does not crash within the specified `resetBackoff`.
            </summary>
            <param name="resetBackoff">The back-off is reset if the child does not crash within this duration</param>
        </member>
        <member name="M:Akka.Pattern.BackoffOptions.WithManualReset">
            <summary>
            Returns a new <see cref="T:Akka.Pattern.BackoffOptions"/> with manual back-off reset. The back-off is only reset if the child sends a `BackoffSupervisor.Reset` to its parent(the backoff-supervisor actor).
            </summary>
        </member>
        <member name="M:Akka.Pattern.BackoffOptions.WithSupervisorStrategy(Akka.Actor.OneForOneStrategy)">
            <summary>
            Returns a new <see cref="T:Akka.Pattern.BackoffOptions"/> with the supervisorStrategy.
            </summary>
            <param name="supervisorStrategy">The <see cref="T:Akka.Actor.SupervisorStrategy"/> that the back-off supervisor will use. The default supervisor strategy is used as fallback if the specified SupervisorStrategy (its decider) does not explicitly handle an exception</param>
        </member>
        <member name="M:Akka.Pattern.BackoffOptions.WithDefaultStoppingStrategy">
            <summary>
            Returns a new <see cref="T:Akka.Pattern.BackoffOptions"/> with a default <see cref="F:Akka.Actor.SupervisorStrategy.StoppingStrategy"/>. The default supervisor strategy is used as fallback for throwables not handled by <see cref="F:Akka.Actor.SupervisorStrategy.StoppingStrategy"/>.
            </summary>
        </member>
        <member name="P:Akka.Pattern.BackoffOptions.Props">
            <summary>
            Returns the props to create the back-off supervisor.
            </summary>
        </member>
        <member name="T:Akka.Pattern.BackoffSupervisor">
            <summary>
            Actor used to supervise actors with ability to restart them after back-off timeout occurred. 
            It's designed for cases when i.e. persistent actor stops due to journal unavailability or failure. 
            In this case it better to wait before restart.
            </summary>
        </member>
        <member name="T:Akka.Pattern.BackoffSupervisor.GetCurrentChild">
            <summary>
            Send this message to the <see cref="T:Akka.Pattern.BackoffSupervisor"/> and it will reply with <see cref="T:Akka.Pattern.BackoffSupervisor.CurrentChild"/> containing the `ActorRef` of the current child, if any.
            </summary>
        </member>
        <member name="F:Akka.Pattern.BackoffSupervisor.GetCurrentChild.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Pattern.BackoffSupervisor.CurrentChild">
            <summary>
            Send this message to the <see cref="T:Akka.Pattern.BackoffSupervisor"/> and it will reply with <see cref="T:Akka.Pattern.BackoffSupervisor.CurrentChild"/> containing the `ActorRef` of the current child, if any.
            </summary>
        </member>
        <member name="M:Akka.Pattern.BackoffSupervisor.CurrentChild.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="ref">TBD</param>
        </member>
        <member name="T:Akka.Pattern.BackoffSupervisor.Reset">
            <summary>
            Send this message to the <see cref="T:Akka.Pattern.BackoffSupervisor"/> and it will reset the back-off. This should be used in conjunction with `withManualReset` in <see cref="T:Akka.Pattern.BackoffOptionsImpl"/>.
            </summary>
        </member>
        <member name="F:Akka.Pattern.BackoffSupervisor.StartChild.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Pattern.BackoffSupervisor.Props(Akka.Actor.Props,System.String,System.TimeSpan,System.TimeSpan,System.Double)">
            <summary>
            Props for creating a <see cref="T:Akka.Pattern.BackoffSupervisor"/> actor.
            </summary>
            <param name="childProps">The <see cref="T:Akka.Actor.Props"/> of the child actor that will be started and supervised</param>
            <param name="childName">Name of the child actor</param>
            <param name="minBackoff">Minimum (initial) duration until the child actor will started again, if it is terminated</param>
            <param name="maxBackoff">The exponential back-off is capped to this duration</param>
            <param name="randomFactor">After calculation of the exponential back-off an additional random delay based on this factor is added, e.g. `0.2` adds up to `20%` delay. In order to skip this additional delay pass in `0`.</param>
        </member>
        <member name="M:Akka.Pattern.BackoffSupervisor.Props(Akka.Pattern.BackoffOptions)">
            <summary>
            Props for creating a <see cref="T:Akka.Pattern.BackoffSupervisor"/> actor from <see cref="T:Akka.Pattern.BackoffOptions"/>.
            </summary>
            <param name="options">The <see cref="T:Akka.Pattern.BackoffOptions"/> that specify how to construct a backoff-supervisor.</param>
            <returns></returns>
        </member>
        <member name="M:Akka.Pattern.BackoffSupervisor.PropsWithSupervisorStrategy(Akka.Actor.Props,System.String,System.TimeSpan,System.TimeSpan,System.Double,Akka.Actor.SupervisorStrategy)">
            <summary>
            Props for creating a <see cref="T:Akka.Pattern.BackoffSupervisor"/> actor with a custom supervision strategy.
            </summary>
            <param name="childProps">The <see cref="T:Akka.Actor.Props"/> of the child actor that will be started and supervised</param>
            <param name="childName">Name of the child actor</param>
            <param name="minBackoff">Minimum (initial) duration until the child actor will started again, if it is terminated</param>
            <param name="maxBackoff">The exponential back-off is capped to this duration</param>
            <param name="randomFactor">After calculation of the exponential back-off an additional random delay based on this factor is added, e.g. `0.2` adds up to `20%` delay. In order to skip this additional delay pass in `0`.</param>
            <param name="strategy">The supervision strategy to use for handling exceptions in the child</param>
        </member>
        <member name="T:Akka.Pattern.BackoffSupervisorBase">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Pattern.CircuitBreaker">
             <summary>
             Provides circuit breaker functionality to provide stability when working with 
             "dangerous" operations, e.g. calls to remote systems
             
            <list type="bullet">
            <listheader>
                <description>Transitions through three states:</description>
            </listheader>
            <item>
                <term>In *Closed* state, </term>
                <description>calls pass through until the maxFailures count is reached. 
                     This causes the circuit breaker to open. Both exceptions and calls exceeding 
                     callTimeout are considered failures.</description>
            </item>
            <item>
                <term>In *Open* state, </term>
                <description>calls fail-fast with an exception. After resetTimeout, 
                     circuit breaker transitions to half-open state.</description>
            </item>
            <item>
                <term>In *Half-Open* state, </term>
                <description>the first call will be allowed through, if it succeeds 
                     the circuit breaker will reset to closed state. If it fails, the circuit 
                     breaker will re-open to open state. All calls beyond the first that execute 
                     while the first is running will fail-fast with an exception.</description>
            </item>
            </list>
             </summary>
        </member>
        <member name="F:Akka.Pattern.CircuitBreaker._currentState">
            <summary>
            The current state of the breaker -- Closed, Half-Open, or Closed -- *access only via helper methods*
            </summary>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.SwapState(Akka.Util.Internal.AtomicState,Akka.Util.Internal.AtomicState)">
            <summary>
            Helper method for access to the underlying state via Interlocked
            </summary>
            <param name="oldState">Previous state on transition</param>
            <param name="newState">Next state on transition</param>
            <returns>Whether the previous state matched correctly</returns>
        </member>
        <member name="P:Akka.Pattern.CircuitBreaker.CurrentState">
            <summary>
            Helper method for access to the underlying state via Interlocked
            </summary>
        </member>
        <member name="P:Akka.Pattern.CircuitBreaker.MaxFailures">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Pattern.CircuitBreaker.CallTimeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Pattern.CircuitBreaker.ResetTimeout">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.Create(System.Int32,System.TimeSpan,System.TimeSpan)">
            <summary>
            Create a new CircuitBreaker
            </summary>
            <param name="maxFailures">Maximum number of failures before opening the circuit</param>
            <param name="callTimeout"><see cref="T:System.TimeSpan"/> of time after which to consider a call a failure</param>
            <param name="resetTimeout"><see cref="T:System.TimeSpan"/> of time after which to attempt to close the circuit</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.#ctor(System.Int32,System.TimeSpan,System.TimeSpan)">
            <summary>
            Create a new CircuitBreaker
            </summary>
            <param name="maxFailures">Maximum number of failures before opening the circuit</param>
            <param name="callTimeout"><see cref="T:System.TimeSpan"/> of time after which to consider a call a failure</param>
            <param name="resetTimeout"><see cref="T:System.TimeSpan"/> of time after which to attempt to close the circuit</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Pattern.CircuitBreaker.CurrentFailureCount">
            <summary>
            Retrieves current failure count.
            </summary>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.WithCircuitBreaker``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Wraps invocation of asynchronous calls that need to be protected
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="body">Call needing protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing the call result</returns>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.WithCircuitBreaker(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Wraps invocation of asynchronous calls that need to be protected
            </summary>
            <param name="body">Call needing protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.WithSyncCircuitBreaker(System.Action)">
            <summary>
            The failure will be recorded farther down.
            </summary>
            <param name="body">TBD</param>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.WithSyncCircuitBreaker``1(System.Func{``0})">
             <summary>
             Wraps invocations of asynchronous calls that need to be protected
             If this does not complete within the time allotted, it should return default(<typeparamref name="T"/>)
             
             <code>
              Await.result(
                  withCircuitBreaker(try Future.successful(body) catch { case NonFatal(t)  Future.failed(t) }),
                  callTimeout)
             </code>
            
             </summary>
             <typeparam name="T">TBD</typeparam>
             <param name="body">TBD</param>
             <returns><typeparamref name="T"/> or default(<typeparamref name="T"/>)</returns>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.OnOpen(System.Action)">
            <summary>
            Adds a callback to execute when circuit breaker opens
            </summary>
            <param name="callback"><see cref="T:System.Action"/> Handler to be invoked on state change</param>
            <returns>CircuitBreaker for fluent usage</returns>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.OnHalfOpen(System.Action)">
            <summary>
            Adds a callback to execute when circuit breaker transitions to half-open
            </summary>
            <param name="callback"><see cref="T:System.Action"/> Handler to be invoked on state change</param>
            <returns>CircuitBreaker for fluent usage</returns>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.OnClose(System.Action)">
            <summary>
            Adds a callback to execute when circuit breaker state closes
            </summary>
            <param name="callback"><see cref="T:System.Action"/> Handler to be invoked on state change</param>
            <returns>CircuitBreaker for fluent usage</returns>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.Transition(Akka.Util.Internal.AtomicState,Akka.Util.Internal.AtomicState)">
            <summary>
            Implements consistent transition between states. Throws IllegalStateException if an invalid transition is attempted.
            </summary>
            <param name="fromState">State being transitioning from</param>
            <param name="toState">State being transitioned to</param>
            <exception cref="T:Akka.Pattern.IllegalStateException">
            This exception is thrown if an invalid transition is attempted from <paramref name="fromState"/> to <paramref name="toState"/>.
            </exception>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.TripBreaker(Akka.Util.Internal.AtomicState)">
            <summary>
            Trips breaker to an open state. This is valid from Closed or Half-Open states
            </summary>
            <param name="fromState">State we're coming from (Closed or Half-Open)</param>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.ResetBreaker">
            <summary>
            Resets breaker to a closed state.  This is valid from an Half-Open state only.
            </summary>
        </member>
        <member name="M:Akka.Pattern.CircuitBreaker.AttemptReset">
            <summary>
            Attempts to reset breaker by transitioning to a half-open state.  This is valid from an Open state only.
            </summary>
        </member>
        <member name="T:Akka.Pattern.Open">
            <summary>
            Concrete implementation of Open state
            </summary>
        </member>
        <member name="M:Akka.Pattern.Open.#ctor(Akka.Pattern.CircuitBreaker)">
            <summary>
            TBD
            </summary>
            <param name="breaker">TBD</param>
        </member>
        <member name="M:Akka.Pattern.Open.Invoke``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            N/A
            </summary>
            <typeparam name="T">N/A</typeparam>
            <param name="body">N/A</param>
            <exception cref="T:Akka.Pattern.OpenCircuitException">This exception is thrown automatically since the circuit is open.</exception>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Pattern.Open.Invoke(System.Func{System.Threading.Tasks.Task})">
            <summary>
            N/A
            </summary>
            <param name="body">N/A</param>
            <exception cref="T:Akka.Pattern.OpenCircuitException">This exception is thrown automatically since the circuit is open.</exception>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Pattern.Open.CallFails">
            <summary>
            No-op for open, calls are never executed so cannot succeed or fail
            </summary>
        </member>
        <member name="M:Akka.Pattern.Open.CallSucceeds">
            <summary>
            No-op for open, calls are never executed so cannot succeed or fail
            </summary>
        </member>
        <member name="M:Akka.Pattern.Open.EnterInternal">
            <summary>
            On entering this state, schedule an attempted reset and store the entry time to
            calculate remaining time before attempted reset.
            </summary>
        </member>
        <member name="T:Akka.Pattern.HalfOpen">
            <summary>
            Concrete implementation of half-open state
            </summary>
        </member>
        <member name="M:Akka.Pattern.HalfOpen.#ctor(Akka.Pattern.CircuitBreaker)">
            <summary>
            TBD
            </summary>
            <param name="breaker">TBD</param>
        </member>
        <member name="M:Akka.Pattern.HalfOpen.Invoke``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Allows a single call through, during which all other callers fail-fast. If the call fails, the breaker reopens.
            If the call succeeds, the breaker closes.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="body">Implementation of the call that needs protected</param>
            <exception cref="T:Akka.Pattern.OpenCircuitException">TBD</exception>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing result of protected call</returns>
        </member>
        <member name="M:Akka.Pattern.HalfOpen.Invoke(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Allows a single call through, during which all other callers fail-fast. If the call fails, the breaker reopens.
            If the call succeeds, the breaker closes.
            </summary>
            <param name="body">Implementation of the call that needs protected</param>
            <exception cref="T:Akka.Pattern.OpenCircuitException">TBD</exception>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing result of protected call</returns>
        </member>
        <member name="M:Akka.Pattern.HalfOpen.CallFails">
            <summary>
            Reopen breaker on failed call.
            </summary>
        </member>
        <member name="M:Akka.Pattern.HalfOpen.CallSucceeds">
            <summary>
            Reset breaker on successful call.
            </summary>
        </member>
        <member name="M:Akka.Pattern.HalfOpen.EnterInternal">
            <summary>
            On entry, guard should be reset for that first call to get in
            </summary>
        </member>
        <member name="M:Akka.Pattern.HalfOpen.ToString">
            <summary>
            Override for more descriptive toString
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Pattern.Closed">
            <summary>
            Concrete implementation of Closed state
            </summary>
        </member>
        <member name="M:Akka.Pattern.Closed.#ctor(Akka.Pattern.CircuitBreaker)">
            <summary>
            TBD
            </summary>
            <param name="breaker">TBD</param>
        </member>
        <member name="M:Akka.Pattern.Closed.Invoke``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Implementation of invoke, which simply attempts the call
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="body">Implementation of the call that needs protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing result of protected call</returns>
        </member>
        <member name="M:Akka.Pattern.Closed.Invoke(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Implementation of invoke, which simply attempts the call
            </summary>
            <param name="body">Implementation of the call that needs protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing result of protected call</returns>
        </member>
        <member name="M:Akka.Pattern.Closed.CallFails">
            <summary>
            On failed call, the failure count is incremented.  The count is checked against the configured maxFailures, and
            the breaker is tripped if we have reached maxFailures.
            </summary>
        </member>
        <member name="M:Akka.Pattern.Closed.CallSucceeds">
            <summary>
            On successful call, the failure count is reset to 0
            </summary>
        </member>
        <member name="M:Akka.Pattern.Closed.EnterInternal">
            <summary>
            On entry of this state, failure count is reset.
            </summary>
        </member>
        <member name="M:Akka.Pattern.Closed.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Akka.Pattern.FutureTimeoutSupport">
            <summary>
            Used to help make it easier to schedule timeouts in conjunction
            with the built-in <see cref="T:Akka.Actor.IScheduler"/>
            </summary>
        </member>
        <member name="M:Akka.Pattern.FutureTimeoutSupport.After``1(System.TimeSpan,Akka.Actor.IScheduler,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Returns a <see cref="T:System.Threading.Tasks.Task"/> that will be completed with the success or failure
            of the provided value after the specified duration.
            </summary>
            <typeparam name="T">The return type of task.</typeparam>
            <param name="duration">The duration to wait.</param>
            <param name="scheduler">The scheduler instance to use.</param>
            <param name="value">The task we're going to wrap.</param>
            <returns>a <see cref="T:System.Threading.Tasks.Task"/> that will be completed with the success or failure
            of the provided value after the specified duration</returns>
        </member>
        <member name="T:Akka.Pattern.IllegalStateException">
            <summary>
            This exception is thrown when a method has been invoked at an illegal or inappropriate time.
            </summary>
        </member>
        <member name="M:Akka.Pattern.IllegalStateException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Pattern.IllegalStateException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Pattern.IllegalStateException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Pattern.IllegalStateException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="innerEx">The inner <see cref="T:System.Exception"/> that was thrown.</param>
        </member>
        <member name="M:Akka.Pattern.IllegalStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Pattern.IllegalStateException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Pattern.OpenCircuitException">
            <summary>
            This exception is thrown when the CircuitBreaker is open.
            </summary>
        </member>
        <member name="M:Akka.Pattern.OpenCircuitException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Pattern.OpenCircuitException"/> class.
            </summary>
        </member>
        <member name="M:Akka.Pattern.OpenCircuitException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Pattern.OpenCircuitException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:Akka.Pattern.OpenCircuitException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Pattern.OpenCircuitException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="cause">The exception that is the cause of the current exception.</param>
        </member>
        <member name="M:Akka.Pattern.OpenCircuitException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Pattern.OpenCircuitException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Akka.Routing.BroadcastRoutingLogic">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route a message to multiple <see cref="T:Akka.Routing.Routee">routees</see>.
            </summary>
        </member>
        <member name="M:Akka.Routing.BroadcastRoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks all the <see cref="T:Akka.Routing.Routee">routees</see> in <paramref name="routees"/> to receive the <paramref name="message"/>.
            </summary>
            <param name="message">The message that is being routed.</param>
            <param name="routees">A collection of routees that receives the <paramref name="message"/>.</param>
            <returns>A <see cref="T:Akka.Routing.Routee"/> that contains all the given <paramref name="routees"/> that receives the <paramref name="message"/>.</returns>
        </member>
        <member name="T:Akka.Routing.BroadcastPool">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Pool"/> router that sends messages it receives to all of its <see cref="T:Akka.Routing.Routee">routees</see>.
            </summary>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastPool"/> class.
            
            <note>
            A <see cref="T:Akka.Routing.BroadcastPool"/> configured in this way uses the <see cref="P:Akka.Routing.Pool.DefaultSupervisorStrategy"/> supervisor strategy.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastPool"/> class.
            </summary>
            <param name="config">The configuration used to configure the pool.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.GetNrOfInstances(Akka.Actor.ActorSystem)">
            <summary>
            Used by the <see cref="T:Akka.Routing.RoutedActorCell" /> to determine the initial number of routees.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The number of routees associated with this pool.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.BroadcastPool"/> router with a given <see cref="T:Akka.Actor.SupervisorStrategy"/>.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy" />.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.BroadcastPool"/> router with a given <see cref="T:Akka.Routing.Resizer"/>.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer" />.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.BroadcastPool"/> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.BroadcastPool"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.BroadcastPool"/>.</returns>
        </member>
        <member name="T:Akka.Routing.BroadcastPool.BroadcastPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.BroadcastPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.BroadcastPool.BroadcastPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.BroadcastPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.BroadcastPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.BroadcastPool.BroadcastPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.BroadcastPool.BroadcastPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.BroadcastPool.BroadcastPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.BroadcastPool.BroadcastPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.BroadcastPool.BroadcastPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.BroadcastGroup">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Group"/> router that sends messages it receives to all of its routees.
            </summary>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastGroup"/> class.
            <note>
            If 'routees.path' is defined in the provided configuration then those paths will be used by the router.
            </note>
            </summary>
            <param name="config">The configuration to use to lookup paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastGroup"/> class.
            </summary>
            <param name="paths">A list of actor paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastGroup"/> class.
            </summary>
            <param name="paths">An enumeration of actor paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.#ctor(System.Collections.Generic.IEnumerable{Akka.Actor.IActorRef})">
            <summary>
            Obsolete. Use <see cref="M:Akka.Routing.BroadcastGroup.#ctor(System.Collections.Generic.IEnumerable{System.String})"/> instead.
            <code>
            new BroadcastGroup(actorRefs.Select(c => c.Path.ToString()))
            </code>
            </summary>
            <param name="routees">N/A</param>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.BroadcastGroup"/> class.
            </summary>
            <param name="paths">An enumeration of actor paths used by the group router.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.GetPaths(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the actor paths used by this router during routee selection.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>An enumeration of actor paths used during routee selection</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.BroadcastGroup" /> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.BroadcastGroup"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.BroadcastGroup"/>.</returns>
        </member>
        <member name="T:Akka.Routing.BroadcastGroup.BroadcastGroupSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.BroadcastGroup"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.BroadcastGroup.BroadcastGroupSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.BroadcastGroup"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.BroadcastGroup"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.BroadcastGroup.BroadcastGroupSurrogate.Paths">
            <summary>
            The actor paths used by this router during routee selection.
            </summary>
        </member>
        <member name="P:Akka.Routing.BroadcastGroup.BroadcastGroupSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHash`1">
            <summary>
            Consistent Hashing node ring implementation.
            
             A good explanation of Consistent Hashing:
            http://weblogs.java.net/blog/tomwhite/archive/2007/11/consistent_hash.html
            
            Note that toString of the ring nodes are used for the node
            hash, i.e. make sure it is different for different nodes.
            </summary>
            <typeparam name="T">The type of objects to store in the hash.</typeparam>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.#ctor(System.Collections.Generic.SortedDictionary{System.Int32,`0},System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHash`1"/> class.
            </summary>
            <param name="nodes">TBD</param>
            <param name="virtualNodesFactor">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the given <paramref name="virtualNodesFactor"/> is less than one.
            </exception>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.Add(`0)">
            <summary>
            Adds a node to the hash ring.
            
            Note that <see cref="T:Akka.Routing.ConsistentHash`1"/> is immutable and
            this operation returns a new instance.
            </summary>
            <param name="node">The node to add to the hash ring</param>
            <returns>A new instance of this hash ring with the given node added.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.Remove(`0)">
            <summary>
            Removes a node from the hash ring.
            
            Note that <see cref="T:Akka.Routing.ConsistentHash`1"/> is immutable and
            this operation returns a new instance.
            </summary>
            <param name="node">The node to remove from the hash ring</param>
            <returns>A new instance of this hash ring with the given node removed.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.NodeFor(System.Byte[])">
            <summary>
            Retrieves the node associated with the data key.
            </summary>
            <param name="key">The data key used for lookup.</param>
            <exception cref="T:System.InvalidOperationException">
            This exception is thrown if the node ring is empty.
            </exception>
            <returns>The node associated with the data key</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.NodeFor(System.String)">
            <summary>
            Retrieves the node associated with the data key.
            </summary>
            <param name="key">The data key used for lookup.</param>
            <exception cref="T:System.InvalidOperationException">
            This exception is thrown if the node ring is empty.
            </exception>
            <returns>The node associated with the data key</returns>
        </member>
        <member name="P:Akka.Routing.ConsistentHash`1.IsEmpty">
            <summary>
            Check to determine if the node ring is empty (i.e. no nodes added or all removed)
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHash`1.ConsistentHashingGroupSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.ConsistentHashingGroup"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.ConsistentHashingGroupSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.ConsistentHashingGroup"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.ConsistentHashingGroup"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.ConsistentHash`1.ConsistentHashingGroupSurrogate.Paths">
            <summary>
            The actor paths used by this router during routee selection.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.op_Addition(Akka.Routing.ConsistentHash{`0},`0)">
            <summary>
            Adds a node to the hash ring.
            
            Note that <see cref="T:Akka.Routing.ConsistentHash`1"/> is immutable and
            this operation returns a new instance.
            </summary>
            <param name="hash">The hash ring used to derive a new ring with the given node added.</param>
            <param name="node">The node to add to the hash ring</param>
            <returns>A new instance of this hash ring with the given node added.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHash`1.op_Subtraction(Akka.Routing.ConsistentHash{`0},`0)">
            <summary>
            Removes a node from the hash ring.
            
            Note that <see cref="T:Akka.Routing.ConsistentHash`1"/> is immutable and
            this operation returns a new instance.
            </summary>
            <param name="hash">The hash ring used to derive a new ring with the given node removed.</param>
            <param name="node">The node to remove from the hash ring</param>
            <returns>A new instance of this hash ring with the given node removed.</returns>
        </member>
        <member name="T:Akka.Routing.ConsistentHash">
            <summary>
            Static helper class for creating <see cref="T:Akka.Routing.ConsistentHash`1"/> instances.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash.Create``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Factory method to create a <see cref="T:Akka.Routing.ConsistentHash`1"/> instance.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="nodes">TBD</param>
            <param name="virtualNodesFactor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHash.ConcatenateNodeHash(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="nodeHash">TBD</param>
            <param name="vnode">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Routing.ConsistentHash.ConsistentHashingPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.ConsistentHashingPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash.ConsistentHashingPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.ConsistentHashingPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.ConsistentHashingPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.ConsistentHash.ConsistentHashingPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHash.ConsistentHashingPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHash.ConsistentHashingPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHash.ConsistentHashingPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHash.ConsistentHashingPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHash.ToBytesOrObject(System.Object)">
            <summary>
            Translate the offered object into a byte array, or returns the original object
            if it needs to be serialized first.
            </summary>
            <param name="obj">An arbitrary .NET object</param>
            <returns>The object encoded into bytes - in the case of custom classes, the hashcode may be used.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHash.HashFor(System.Byte[])">
            <summary>
            TBD
            </summary>
            <param name="bytes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHash.HashFor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="hashKey">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingRouter">
            <summary>
            Static class for assisting with <see cref="T:Akka.Routing.ConsistentHashMapping"/> instances
            </summary>
        </member>
        <member name="F:Akka.Routing.ConsistentHashingRouter.EmptyConsistentHashMapping">
            <summary>
            Default empty <see cref="T:Akka.Routing.ConsistentHashMapping"/> implementation
            </summary>
        </member>
        <member name="T:Akka.Routing.IConsistentHashable">
            <summary>
            This interface marks a given class as consistently hashable, for use with
            <see cref="T:Akka.Routing.ConsistentHashingGroup"/> or <see cref="T:Akka.Routing.ConsistentHashingPool"/>
            routers.
            </summary>
        </member>
        <member name="P:Akka.Routing.IConsistentHashable.ConsistentHashKey">
            <summary>
            The consistent hash key of the marked class.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashableEnvelope">
            <summary>
            This class represents a <see cref="T:Akka.Routing.RouterEnvelope"/> that can be wrapped around a message in order to make
            it hashable for use with <see cref="T:Akka.Routing.ConsistentHashingGroup"/> or <see cref="T:Akka.Routing.ConsistentHashingPool"/> routers.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashableEnvelope.#ctor(System.Object,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashableEnvelope"/> class.
            </summary>
            <param name="message">The message that is being wrapped in the envelope.</param>
            <param name="hashKey">The key used as the consistent hash key for the envelope.</param>
        </member>
        <member name="P:Akka.Routing.ConsistentHashableEnvelope.HashKey">
            <summary>
            The key used as the consistent hash key.
            
            <remarks>
            This is the same as the <see cref="P:Akka.Routing.ConsistentHashableEnvelope.ConsistentHashKey"/>
            </remarks>
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHashableEnvelope.ConsistentHashKey">
            <summary>
            The consistent hash key of the envelope.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashMapping">
            <summary>
            Delegate for computing the hashkey from any given type of message. Extracts the property / data
            that is going to be used for a given hash, but doesn't actually return the hash values themselves.
            
            If returning a byte[] or string it will be used as is, otherwise the configured
            <see cref="T:Akka.Serialization.Serializer"/> will be applied to the returned data.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingRoutingLogic">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route a message to a <see cref="T:Akka.Routing.Routee"/>
            determined using consistent-hashing. This process has the router select a routee based on a message's
            consistent hash key. There are 3 ways to define the key, which can be used individually or combined
            to form the key. The <see cref="T:Akka.Routing.ConsistentHashMapping"/> is tried first.
            
            <ol>
            <li>
            You can define a <see cref="T:Akka.Routing.ConsistentHashMapping"/> or use <see cref="M:Akka.Routing.ConsistentHashingRoutingLogic.WithHashMapping(Akka.Routing.ConsistentHashMapping)"/>
            of the router to map incoming messages to their consistent hash key.
            This makes the decision transparent for the sender.
            </li>
            <li>
            Messages may implement <see cref="T:Akka.Routing.IConsistentHashable"/>. The hash key is part
            of the message and it's convenient to define it together with the message
            definition.
            </li>
            <li>
            The message can be wrapped in a <see cref="T:Akka.Routing.ConsistentHashableEnvelope"/> to
            define what data to use for the consistent hash key. The sender knows what key
            to use.
            </li>
            </ol>
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingRoutingLogic.#ctor(Akka.Actor.ActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/> class.
            
            <note>
            A <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/> configured in this way uses the
            <see cref="F:Akka.Routing.ConsistentHashingRouter.EmptyConsistentHashMapping"/> as the hash
            mapping function with a virtual node factor of 0 (zero).
            </note>
            </summary>
            <param name="system">The actor system that owns the router with this logic.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingRoutingLogic.#ctor(Akka.Actor.ActorSystem,System.Int32,Akka.Routing.ConsistentHashMapping)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/> class.
            </summary>
            <param name="system">The actor system that owns the router with this logic.</param>
            <param name="virtualNodesFactor">The number of virtual nodes to use on the hash ring.</param>
            <param name="hashMapping">The consistent hash mapping function to use on incoming messages.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingRoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks a <see cref="T:Akka.Routing.Routee" /> to receive the <paramref name="message" />.
            </summary>
            <param name="message">The message that is being routed</param>
            <param name="routees">A collection of routees to choose from when receiving the <paramref name="message" />.</param>
            <returns>A <see cref="T:Akka.Routing.Routee" /> that receives the <paramref name="message" />.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingRoutingLogic.WithHashMapping(Akka.Routing.ConsistentHashMapping)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/> router logic with a given <see cref="T:Akka.Routing.ConsistentHashMapping"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="mapping">The <see cref="T:Akka.Routing.ConsistentHashMapping"/> used to configure the new router.</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if the given <paramref name="mapping"/> is undefined.
            </exception>
            <returns>A new router logic with the provided <paramref name="mapping"/>.</returns>
        </member>
        <member name="T:Akka.Routing.ConsistentRoutee">
            <summary>
            INTERNAL API
            
            Important to use ActorRef with full address, with host and port, in the hash ring,
            so that same ring is produced on different nodes.
            The ConsistentHash uses toString of the ring nodes, and the ActorRef itself
            isn't a good representation, because LocalActorRef doesn't include the
            host and port.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentRoutee.#ctor(Akka.Routing.Routee,Akka.Actor.Address)">
            <summary>
            TBD
            </summary>
            <param name="routee">TBD</param>
            <param name="selfAddress">TBD</param>
        </member>
        <member name="P:Akka.Routing.ConsistentRoutee.Routee">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentRoutee.SelfAddress">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentRoutee.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingPool">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Pool"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using consistent-hashing.
            Please refer to <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/> for more information on consistent hashing.
            
            <note>
            Using <see cref="T:Akka.Routing.Resizer"/> with <see cref="T:Akka.Routing.ConsistentHashingPool"/> is potentially harmful, as hash ranges
            might change radically during live message processing. This router works best with fixed-sized pools or fixed
            number of routees per node in the event of clustered deployments.
            </note>
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingPool"/> class.
            <note>
            A <see cref="T:Akka.Routing.ConsistentHashingPool"/> configured in this way uses the <see cref="P:Akka.Routing.Pool.DefaultSupervisorStrategy"/> supervisor strategy.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingPool"/> class.
            
            <note>
            'virtual-nodes-factor' defaults to 0 (zero) if it is not defined in the provided configuration.
            </note>
            </summary>
            <param name="config">The configuration used to configure the pool.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.#ctor(System.Int32,Akka.Routing.ConsistentHashMapping)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="hashMapping">The consistent hash mapping function to use on incoming messages.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean,System.Int32,Akka.Routing.ConsistentHashMapping)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
            <param name="virtualNodesFactor">The number of virtual nodes to use on the hash ring.</param>
            <param name="hashMapping">The consistent hash mapping function to use on incoming messages.</param>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingPool.VirtualNodesFactor">
            <summary>
            Virtual nodes used in the <see cref="T:Akka.Routing.ConsistentHash`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.GetNrOfInstances(Akka.Actor.ActorSystem)">
            <summary>
            Used by the <see cref="T:Akka.Routing.RoutedActorCell" /> to determine the initial number of routees.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The number of routees associated with this pool.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingPool" /> router with a given <see cref="T:Akka.Actor.SupervisorStrategy" />.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy" />.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingPool" /> router with a given <see cref="T:Akka.Routing.Resizer" />.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            <note>
            Using <see cref="T:Akka.Routing.Resizer"/> with <see cref="T:Akka.Routing.ConsistentHashingPool"/> is potentially harmful, as hash ranges
            might change radically during live message processing. This router works best with fixed-sized pools or fixed
            number of routees per node in the event of clustered deployments.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer" />.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingPool" /> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.WithVirtualNodesFactor(System.Int32)">
            <summary>
            Setting the number of virtual nodes per node, used in <see cref="T:Akka.Routing.ConsistentHash" />.
            </summary>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.WithHashMapping(Akka.Routing.ConsistentHashMapping)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingPool"/> router with a given <see cref="T:Akka.Routing.ConsistentHashMapping"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="mapping">The <see cref="T:Akka.Routing.ConsistentHashMapping"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="mapping"/>.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the given <paramref name="routerConfig"/> is not a <see cref="T:Akka.Routing.ConsistentHashingPool"/>.
            </exception>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.ConsistentHashingPool"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.ConsistentHashingPool"/>.</returns>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingPool.ConsistentHashingPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.ConsistentHashingPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingPool.ConsistentHashingPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.ConsistentHashingPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.ConsistentHashingPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingPool.ConsistentHashingPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingPool.ConsistentHashingPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingPool.ConsistentHashingPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingPool.ConsistentHashingPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingPool.ConsistentHashingPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingGroup">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Group"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using consistent-hashing.
            Please refer to <see cref="T:Akka.Routing.ConsistentHashingRoutingLogic"/> for more information on consistent hashing.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingGroup"/> class.
            </summary>
            <param name="config">
            The configuration to use to lookup paths used by the group router.
            
            <note>
            If 'routees.path' is defined in the provided configuration then those paths will be used by the router.
            'virtual-nodes-factor' defaults to 0 (zero) if it is not defined in the provided configuration.
            </note>
            </param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingGroup"/> class.
            </summary>
            <param name="paths">>A list of actor paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingGroup"/> class.
            </summary>
            <param name="paths">A list of actor paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.#ctor(System.Collections.Generic.IEnumerable{Akka.Actor.IActorRef})">
            <summary>
            Obsolete. Use <see cref="M:Akka.Routing.ConsistentHashingGroup.#ctor(System.Collections.Generic.IEnumerable{System.String})"/> instead.
            <code>
            new ConsistentHashingGroup(actorRefs.Select(c => c.Path.ToString()))
            </code>
            </summary>
            <param name="routees">N/A</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.#ctor(System.Collections.Generic.IEnumerable{System.String},Akka.Routing.ConsistentHashMapping)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingGroup"/> class.
            </summary>
            <param name="paths">An enumeration of actor paths used by the group router.</param>
            <param name="hashMapping">The consistent hash mapping function to use on incoming messages.</param>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Int32,Akka.Routing.ConsistentHashMapping,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ConsistentHashingGroup"/> class.
            </summary>
            <param name="paths">An enumeration of actor paths used by the group router.</param>
            <param name="virtualNodesFactor">The number of virtual nodes to use on the hash ring.</param>
            <param name="hashMapping">The consistent hash mapping function to use on incoming messages.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingGroup.VirtualNodesFactor">
            <summary>
            Virtual nodes used in the <see cref="T:Akka.Routing.ConsistentHash`1"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.GetPaths(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the actor paths used by this router during routee selection.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>An enumeration of actor paths used during routee selection</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingGroup" /> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.WithVirtualNodesFactor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingGroup" /> router with a given <see cref="P:Akka.Routing.ConsistentHashingGroup.VirtualNodesFactor"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="vnodes">The <see cref="P:Akka.Routing.ConsistentHashingGroup.VirtualNodesFactor"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="vnodes" />.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.WithHashMapping(Akka.Routing.ConsistentHashMapping)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ConsistentHashingGroup"/> router with a given <see cref="T:Akka.Routing.ConsistentHashMapping"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="mapping">The <see cref="T:Akka.Routing.ConsistentHashMapping"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="mapping"/>.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the given <paramref name="routerConfig"/> is not a <see cref="T:Akka.Routing.ConsistentHashingGroup"/>.
            </exception>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.ConsistentHashingGroup"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.ConsistentHashingGroup"/>.</returns>
        </member>
        <member name="T:Akka.Routing.ConsistentHashingGroup.ConsistentHashingGroupSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.ConsistentHashingGroup"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.ConsistentHashingGroup.ConsistentHashingGroupSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.ConsistentHashingGroup"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.ConsistentHashingGroup"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingGroup.ConsistentHashingGroupSurrogate.Paths">
            <summary>
            The actor paths used by this router during routee selection.
            </summary>
        </member>
        <member name="P:Akka.Routing.ConsistentHashingGroup.ConsistentHashingGroupSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.IListeners">
            <summary>
            This interface is needed to implement listening capabilities on an actor.
            
            <remarks>
            <ul>
            <li>Use the <see cref="M:Akka.Routing.ListenerSupport.Gossip(System.Object)"/> method to send a message to the listeners.</li>
            <li>Send <code>Listen(Self)</code> to another Actor to start listening.</li>
            <li>Send <code>Deafen(Self)</code> to another Actor to stop listening.</li>
            <li>Send <code>WithListeners(delegate)</code> to traverse the current listeners.</li>
            </ul>
            </remarks>
            </summary>
        </member>
        <member name="P:Akka.Routing.IListeners.Listeners">
            <summary>
            Retrieves the support needed to interact with an actor's listeners.
            </summary>
        </member>
        <member name="T:Akka.Routing.ListenerMessage">
            <summary>
            This class represents a message sent by an actor to another actor that is listening to it.
            </summary>
        </member>
        <member name="T:Akka.Routing.Listen">
            <summary>
            The class represents a <see cref="T:Akka.Routing.ListenerMessage"/> sent by an <see cref="T:Akka.Actor.IActorRef"/> to another <see cref="T:Akka.Actor.IActorRef"/>
            instructing the second actor to start listening for messages sent by the first actor.
            </summary>
        </member>
        <member name="M:Akka.Routing.Listen.#ctor(Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.Listen"/> class.
            </summary>
            <param name="listener">The actor that receives the message.</param>
        </member>
        <member name="P:Akka.Routing.Listen.Listener">
            <summary>
            The actor that receives the message.
            </summary>
        </member>
        <member name="T:Akka.Routing.Deafen">
            <summary>
            The class represents a <see cref="T:Akka.Routing.ListenerMessage"/> sent by an <see cref="T:Akka.Actor.IActorRef"/> to another <see cref="T:Akka.Actor.IActorRef"/>
            instructing the second actor to stop listening for messages sent by the first actor.
            </summary>
        </member>
        <member name="M:Akka.Routing.Deafen.#ctor(Akka.Actor.IActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.Deafen"/> class.
            </summary>
            <param name="listener">The actor that no longer receives the message.</param>
        </member>
        <member name="P:Akka.Routing.Deafen.Listener">
            <summary>
            The actor that no longer receives the message.
            </summary>
        </member>
        <member name="T:Akka.Routing.WithListeners">
            <summary>
            This class represents a <see cref="T:Akka.Routing.ListenerMessage"/> instructing an <see cref="T:Akka.Actor.IActorRef"/>
            to perform a supplied <see cref="T:System.Action`1"/> for all of its listeners.
            </summary>
        </member>
        <member name="M:Akka.Routing.WithListeners.#ctor(System.Action{Akka.Actor.IActorRef})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.WithListeners"/> class.
            </summary>
            <param name="listenerFunction">The action to perform for all of an actor's listeners.</param>
        </member>
        <member name="P:Akka.Routing.WithListeners.ListenerFunction">
            <summary>
            The action to perform for all of an actor's listeners.
            </summary>
        </member>
        <member name="T:Akka.Routing.ListenerSupport">
            <summary>
            This class adds <see cref="T:Akka.Routing.IListeners"/> capabilities to an actor.
            
            <note>
            <see cref="P:Akka.Routing.ListenerSupport.ListenerReceive"/> must be wired manually into the actor's
            <see cref="M:Akka.Actor.UntypedActor.OnReceive(System.Object)"/> method.
            </note>
            </summary>
        </member>
        <member name="F:Akka.Routing.ListenerSupport.Listeners">
            <summary>
            The collection of registered listeners that is listening for messages from an actor.
            </summary>
        </member>
        <member name="P:Akka.Routing.ListenerSupport.ListenerReceive">
            <summary>
            Retrieves the wiring needed to implement listening functionality.
            
            <note>
            This needs to be chained into the actor's <see cref="M:Akka.Actor.UntypedActor.OnReceive(System.Object)"/> method.
            </note>
            </summary>
        </member>
        <member name="M:Akka.Routing.ListenerSupport.Add(Akka.Actor.IActorRef)">
            <summary>
            Adds the specified actor to the collection of registered listeners.
            </summary>
            <param name="actor">The actor to add to the collection of registered listeners.</param>
        </member>
        <member name="M:Akka.Routing.ListenerSupport.Remove(Akka.Actor.IActorRef)">
            <summary>
            Removes the specified actor from the collection of registered listeners.
            </summary>
            <param name="actor">The actor to remove from the collection of registered listeners.</param>
        </member>
        <member name="M:Akka.Routing.ListenerSupport.Gossip(System.Object)">
            <summary>
            Sends the supplied message to all registered listeners.
            
            <note>
            Messages sent this way use <see cref="F:Akka.Actor.ActorRefs.NoSender"/> as the sender.
            </note>
            </summary>
            <param name="message">The message sent to all registered listeners.</param>
        </member>
        <member name="M:Akka.Routing.ListenerSupport.Gossip(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Sends the supplied message to all registered listeners.
            </summary>
            <param name="message">The message sent to all registered listeners.</param>
            <param name="sender">The actor that sends the message.</param>
        </member>
        <member name="T:Akka.Routing.RandomLogic">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route a message to a random <see cref="T:Akka.Routing.Routee"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.RandomLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks a random <see cref="T:Akka.Routing.Routee"/> to receive the <paramref name="message"/>.
            </summary>
            <param name="message">The message that is being routed.</param>
            <param name="routees">A collection of routees to randomly choose from when receiving the <paramref name="message"/>.</param>
            <returns>A <see cref="T:Akka.Routing.Routee" /> that receives the <paramref name="message"/>.</returns>
        </member>
        <member name="T:Akka.Routing.RandomPool">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Pool"/> router that sends messages to a random <see cref="T:Akka.Routing.Routee"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.RandomPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RandomPool"/> class.
            </summary>
            <param name="config">The configuration used to configure the pool.</param>
        </member>
        <member name="M:Akka.Routing.RandomPool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RandomPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
        </member>
        <member name="M:Akka.Routing.RandomPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RandomPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
        </member>
        <member name="M:Akka.Routing.RandomPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.RandomPool.GetNrOfInstances(Akka.Actor.ActorSystem)">
            <summary>
            Used by the <see cref="T:Akka.Routing.RoutedActorCell" /> to determine the initial number of routees.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The number of routees associated with this pool.</returns>
        </member>
        <member name="M:Akka.Routing.RandomPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RandomPool" /> router with a given <see cref="T:Akka.Actor.SupervisorStrategy" />.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy" />.</returns>
        </member>
        <member name="M:Akka.Routing.RandomPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RandomPool" /> router with a given <see cref="T:Akka.Routing.Resizer" />.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer" />.</returns>
        </member>
        <member name="M:Akka.Routing.RandomPool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RandomPool" /> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.RandomPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="M:Akka.Routing.RandomPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.RandomPool"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.RandomPool"/>.</returns>
        </member>
        <member name="T:Akka.Routing.RandomPool.RandomPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.RandomPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="P:Akka.Routing.RandomPool.RandomPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.RandomPool.RandomPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.RandomPool.RandomPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.RandomPool.RandomPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.RandomPool.RandomPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="M:Akka.Routing.RandomPool.RandomPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.RandomPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.RandomPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="T:Akka.Routing.RandomGroup">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Group"/> router that sends messages to a random <see cref="T:Akka.Routing.Routee"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.RandomGroup.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RandomGroup"/> class.
            </summary>
            <param name="config">
            The configuration to use to lookup paths used by the group router.
            
            <note>
            If 'routees.path' is defined in the provided configuration then those paths will be used by the router.
            </note>
            </param>
        </member>
        <member name="M:Akka.Routing.RandomGroup.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RandomGroup"/> class.
            </summary>
            <param name="paths">>A list of actor paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.RandomGroup.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RandomGroup"/> class.
            </summary>
            <param name="paths">An enumeration of paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.RandomGroup.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RandomGroup"/> class.
            </summary>
            <param name="paths">An enumeration of paths used by the group router.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
        </member>
        <member name="M:Akka.Routing.RandomGroup.GetPaths(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the actor paths used by this router during routee selection.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>An enumeration of actor paths used during routee selection</returns>
        </member>
        <member name="M:Akka.Routing.RandomGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.RandomGroup.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RandomGroup" /> router with a given dispatcher id.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.RandomGroup.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.RandomGroup"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.RandomGroup"/>.</returns>
        </member>
        <member name="T:Akka.Routing.RandomGroup.RandomGroupSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.RandomGroup"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.RandomGroup.RandomGroupSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.RandomGroup"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.RandomGroup"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.RandomGroup.RandomGroupSurrogate.Paths">
            <summary>
            The actor paths used by this router during routee selection.
            </summary>
        </member>
        <member name="P:Akka.Routing.RandomGroup.RandomGroupSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.ResizablePoolActor">
            <summary>
            INTERNAL API.
            
            Defines <see cref="T:Akka.Routing.Pool"/> routers who can resize the number of routees
            they use based on a defined <see cref="T:Akka.Routing.Resizer"/>
            </summary>
        </member>
        <member name="M:Akka.Routing.ResizablePoolActor.#ctor(Akka.Actor.SupervisorStrategy)">
            <summary>
            TBD
            </summary>
            <param name="supervisorStrategy">TBD</param>
        </member>
        <member name="P:Akka.Routing.ResizablePoolActor.ResizerCell">
            <summary>
            TBD
            </summary>
            <exception cref="T:Akka.Actor.ActorInitializationException">TBD</exception>
        </member>
        <member name="M:Akka.Routing.ResizablePoolActor.OnReceive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.ResizablePoolActor.StopIfAllRouteesRemoved">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Routing.Resize">
            <summary>
            Command used to resize a <see cref="T:Akka.Routing.ResizablePoolActor"/>
            </summary>
        </member>
        <member name="T:Akka.Routing.ResizablePoolCell">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="F:Akka.Routing.ResizablePoolCell._resizeInProgress">
            <summary>
            must always use ResizeInProgressState static class to compare or assign values
            </summary>
        </member>
        <member name="M:Akka.Routing.ResizablePoolCell.#ctor(Akka.Actor.Internal.ActorSystemImpl,Akka.Actor.IInternalActorRef,Akka.Actor.Props,Akka.Dispatch.MessageDispatcher,Akka.Actor.Props,Akka.Actor.IInternalActorRef,Akka.Routing.Pool)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ResizablePoolCell"/> class.
            </summary>
            <param name="system">TBD</param>
            <param name="self">TBD</param>
            <param name="routerProps">TBD</param>
            <param name="dispatcher">TBD</param>
            <param name="routeeProps">TBD</param>
            <param name="supervisor">TBD</param>
            <param name="pool">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if pool's resizer is undefined.
            </exception>
        </member>
        <member name="M:Akka.Routing.ResizablePoolCell.PreSuperStart">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.ResizablePoolCell.SendMessage(Akka.Actor.Envelope)">
            <summary>
            TBD
            </summary>
            <param name="envelope">TBD</param>
        </member>
        <member name="M:Akka.Routing.ResizablePoolCell.Resize(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="initial">TBD</param>
        </member>
        <member name="T:Akka.Routing.Resizer">
            <summary>
            <see cref="T:Akka.Routing.Pool"/> routers with dynamically resizable number of routees are implemented by providing a Resizer
            implementation in the <see cref="T:Akka.Routing.Pool"/> configuration
            </summary>
        </member>
        <member name="M:Akka.Routing.Resizer.IsTimeForResize(System.Int64)">
            <summary>
            Is it time for resizing. Typically implemented with modulo of nth message, but
            could be based on elapsed time or something else. The messageCounter starts with 0
            for the initial resize and continues with 1 for the first message. Make sure to perform
            initial resize before first message (messageCounter == 0), because there is no guarantee
            that resize will be done when concurrent messages are in play.
            
            CAUTION: this method is invoked from the thread which tries to send a
            message to the pool, i.e. the ActorRef.!() method, hence it may be called
            concurrently.
            </summary>
            <param name="messageCounter">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.Resizer.Resize(System.Collections.Generic.IEnumerable{Akka.Routing.Routee})">
             <summary>
             Decide if the capacity of the router need to be changed. Will be invoked when `isTimeForResize`
             returns true and no other resize is in progress.
            
             Return the number of routees to add or remove. Negative value will remove that number of routees.
             Positive value will add that number of routess. 0 will not change the routees.
            
             This method is invoked only in the context of the Router actor.
             </summary>
             <param name="currentRoutees">TBD</param>
             <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.Resizer.FromConfig(Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="parentConfig">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Routing.DefaultResizer">
            <summary>
            Implementation of <see cref="T:Akka.Routing.Resizer"/> that adjust the <see cref="T:Akka.Routing.Pool"/> based on specified thresholds.
            </summary>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.#ctor(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.DefaultResizer"/> class.
            </summary>
            <param name="lower">TBD</param>
            <param name="upper">TBD</param>
            <param name="pressureThreshold">TBD</param>
            <param name="rampupRate">TBD</param>
            <param name="backoffThreshold">TBD</param>
            <param name="backoffRate">TBD</param>
            <param name="messagesPerResize">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception can be thrown for a number of reasons. These include:
            <ul>
            <li>The given <paramref name="lower"/> bound was negative.</li>
            <li>The given <paramref name="upper"/> bound was negative.</li>
            <li>The given <paramref name="upper"/> bound was below the <paramref name="lower"/>bound.</li>
            <li>The given <paramref name="rampupRate"/> was negative.</li>
            <li>The given <paramref name="backoffThreshold"/> was greater than one.</li>
            <li>The given <paramref name="backoffRate"/> was negative.</li>
            <li>The given <paramref name="messagesPerResize"/> was less than one.</li>
            </ul>
            </exception>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.FromConfig(Akka.Configuration.Config)">
            <summary>
            TBD
            </summary>
            <param name="resizerConfig">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Apply(Akka.Configuration.Config)">
            <summary>
            Creates a new DefaultResizer from the given configuration
            </summary>
            <param name="resizerConfig">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.IsTimeForResize(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="messageCounter">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Resize(System.Collections.Generic.IEnumerable{Akka.Routing.Routee})">
            <summary>
            TBD
            </summary>
            <param name="currentRoutees">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Capacity(System.Collections.Generic.IEnumerable{Akka.Routing.Routee})">
            <summary>
            Returns the overall desired change in resizer capacity. Positive value will
            add routees to the resizer. Negative value will remove routees from the
            resizer
            </summary>
            <param name="currentRoutees">The current actor in the resizer</param>
            <returns>the number of routees by which the resizer should be adjusted (positive, negative or zero)</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Pressure(System.Collections.Generic.IEnumerable{Akka.Routing.Routee})">
             <summary>
             Number of routees considered busy, or above 'pressure level'.
            
             Implementation depends on the value of `pressureThreshold`
             (default is 1).
             <ul>
             <li> 0:   number of routees currently processing a message.</li>
             <li> 1:   number of routees currently processing a message has
                       some messages in mailbox.</li>
             <li> > 1: number of routees with at least the configured `pressureThreshold`
                       messages in their mailbox. Note that estimating mailbox size of
                       default UnboundedMailbox is O(N) operation.</li>
             </ul>
             </summary>
             <param name="currentRoutees">An enumeration of the current routees</param>
             <returns>The number of routees considered to be above pressure level.</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Filter(System.Int32,System.Int32)">
            <summary>
            This method can be used to smooth the capacity delta by considering
            the current pressure and current capacity.
            </summary>
            <param name="pressure">pressure current number of busy routees</param>
            <param name="capacity">capacity current number of routees</param>
            <returns>proposed change in the capacity</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Rampup(System.Int32,System.Int32)">
            <summary>
            Computes a proposed positive (or zero) capacity delta using
            the configured `rampupRate`.
            </summary>
            <param name="pressure">the current number of busy routees</param>
            <param name="capacity">the current number of total routees</param>
            <returns>proposed increase in capacity</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Backoff(System.Int32,System.Int32)">
            <summary>
            Computes a proposed negative (or zero) capacity delta using
            the configured `backoffThreshold` and `backoffRate`
            </summary>
            <param name="pressure">pressure current number of busy routees</param>
            <param name="capacity">capacity current number of routees</param>
            <returns>proposed decrease in capacity (as a negative number)</returns>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.LowerBound">
            <summary>
            The fewest number of routees the router should ever have.
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.UpperBound">
            <summary>
            The most number of routees the router should ever have. 
            Must be greater than or equal to `lowerBound`.
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.PressureThreshold">
            <summary>
            * Threshold to evaluate if routee is considered to be busy (under pressure).
            Implementation depends on this value (default is 1).
            <ul>
            <li> 0:   number of routees currently processing a message.</li>
            <li> 1:   number of routees currently processing a message has
                      some messages in mailbox.</li>
            <li> > 1: number of routees with at least the configured `pressureThreshold`
                      messages in their mailbox. Note that estimating mailbox size of
                      default UnboundedMailbox is O(N) operation.</li>
            </ul>
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.RampupRate">
            <summary>
            Percentage to increase capacity whenever all routees are busy.
            For example, 0.2 would increase 20% (rounded up), i.e. if current
            capacity is 6 it will request an increase of 2 more routees.
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.BackoffThreshold">
             <summary>
             Minimum fraction of busy routees before backing off.
             For example, if this is 0.3, then we'll remove some routees only when
             less than 30% of routees are busy, i.e. if current capacity is 10 and
             3 are busy then the capacity is unchanged, but if 2 or less are busy
             the capacity is decreased.
            
             Use 0.0 or negative to avoid removal of routees.
             </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.BackoffRate">
            <summary>
            Fraction of routees to be removed when the resizer reaches the
            backoffThreshold.
            For example, 0.1 would decrease 10% (rounded up), i.e. if current
            capacity is 9 it will request an decrease of 1 routee.
            </summary>
        </member>
        <member name="P:Akka.Routing.DefaultResizer.MessagesPerResize">
            <summary>
            Number of messages between resize operation.
            Use 1 to resize before each message.
            </summary>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Equals(Akka.Routing.DefaultResizer)">
            <summary>
            Determines whether the specified resizer, is equal to this instance.
            </summary>
            <param name="other">The resizer to compare.</param>
            <returns><c>true</c> if the specified router is equal to this instance; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Routing.DefaultResizer.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="T:Akka.Routing.RoundRobinRoutingLogic">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route a message to a <see cref="T:Akka.Routing.Routee"/> determined using round-robin.
            This process has the router select from a list of routees in sequential order. When the list has been exhausted, the router iterates
            again from the beginning of the list.
            <note>
            For concurrent calls, round robin is just a best effort.
            </note>
            </summary>
        </member>
        <member name="M:Akka.Routing.RoundRobinRoutingLogic.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinRoutingLogic"/> class.
            </summary>
        </member>
        <member name="M:Akka.Routing.RoundRobinRoutingLogic.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinRoutingLogic"/> class.
            </summary>
            <param name="next">The index to use when starting the selection process. Note that it will start at (next + 1).</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinRoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks the next <see cref="T:Akka.Routing.Routee"/> in the collection to receive the <paramref name="message"/>.
            </summary>
            <param name="message">The message that is being routed.</param>
            <param name="routees">A collection of routees to choose from when receiving the <paramref name="message"/>.</param>
            <returns>A <see cref="T:Akka.Routing.Routee" /> that is receives the <paramref name="message"/>.</returns>
        </member>
        <member name="T:Akka.Routing.RoundRobinPool">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Pool"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using round-robin.
            This process has the router select from a list of routees in sequential order. When the list has been exhausted, the router
            iterates again from the beginning of the list.
            <note>
            For concurrent calls, round robin is just a best effort.
            </note>
            </summary>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinPool"/> class.
            </summary>
            <param name="config">The configuration used to configure the pool.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinPool"/> class.
            <note>
            A <see cref="T:Akka.Routing.RoundRobinPool"/> configured in this way uses the <see cref="P:Akka.Routing.Pool.DefaultSupervisorStrategy"/> supervisor strategy.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.#ctor(System.Int32,Akka.Routing.Resizer)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinPool"/> class.
            <note>
            A <see cref="T:Akka.Routing.RoundRobinPool"/> configured in this way uses the <see cref="P:Akka.Routing.Pool.DefaultSupervisorStrategy"/> supervisor strategy.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.GetNrOfInstances(Akka.Actor.ActorSystem)">
            <summary>
            Used by the <see cref="T:Akka.Routing.RoutedActorCell"/> to determine the initial number of routees.
            </summary>
            <param name="sys">The actor system that owns this router.</param>
            <returns>The number of routees associated with this pool.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RoundRobinPool"/> router with a given <see cref="T:Akka.Actor.SupervisorStrategy"/>.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy"/>.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RoundRobinPool"/> router with a given <see cref="T:Akka.Routing.Resizer"/>.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer"/>.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RoundRobinPool"/> router with a given dispatcher id.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.RoundRobinPool"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.RoundRobinPool"/>.</returns>
        </member>
        <member name="T:Akka.Routing.RoundRobinPool.RoundRobinPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.RoundRobinPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.RoundRobinPool.RoundRobinPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.RoundRobinPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.RoundRobinPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.RoundRobinPool.RoundRobinPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.RoundRobinPool.RoundRobinPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.RoundRobinPool.RoundRobinPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.RoundRobinPool.RoundRobinPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.RoundRobinPool.RoundRobinPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.RoundRobinGroup">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Group"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using round-robin.
            This process has the router select from a list of routees in sequential order. When the list has been exhausted, the router
            iterates again from the beginning of the list.
            <note>
            For concurrent calls, round robin is just a best effort.
            </note>
            <note>
            The configuration parameter trumps the constructor arguments. This means that
            if you provide `paths` during instantiation they will be ignored if
            the router is defined in the configuration file for the actor being used.
            </note>
            </summary>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinGroup"/> class.
            </summary>
            <param name="config">
            The configuration to use to lookup paths used by the group router.
            <note>
            If 'routees.path' is defined in the provided configuration then those paths will be used by the router.
            </note>
            </param>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinGroup"/> class.
            </summary>
            <param name="paths">A list of paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinGroup"/> class.
            </summary>
            <param name="paths">An enumeration of actor paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.#ctor(System.Collections.Generic.IEnumerable{Akka.Actor.IActorRef})">
            <summary>
            Obsolete. Use <see cref="M:Akka.Routing.RoundRobinGroup.#ctor(System.Collections.Generic.IEnumerable{System.String})"/> instead.
            </summary>
            <param name="routees">N/A</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoundRobinGroup"/> class.
            </summary>
            <param name="paths">A list of paths used by the group router.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to routees.</param>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.GetPaths(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the actor paths used by this router during routee selection.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>An enumeration of actor paths used during routee selection</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.RoundRobinGroup"/> router with a given dispatcher id.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcherId">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.RoundRobinGroup"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.RoundRobinGroup"/>.</returns>
        </member>
        <member name="T:Akka.Routing.RoundRobinGroup.RoundRobinGroupSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.RoundRobinGroup"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.RoundRobinGroup.RoundRobinGroupSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.RoundRobinGroup"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.RoundRobinGroup"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.RoundRobinGroup.RoundRobinGroupSurrogate.Paths">
            <summary>
            The actor paths used by this router during routee selection.
            </summary>
        </member>
        <member name="P:Akka.Routing.RoundRobinGroup.RoundRobinGroupSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.RoutedActorCell">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.#ctor(Akka.Actor.Internal.ActorSystemImpl,Akka.Actor.IInternalActorRef,Akka.Actor.Props,Akka.Dispatch.MessageDispatcher,Akka.Actor.Props,Akka.Actor.IInternalActorRef)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoutedActorCell"/> class.
            </summary>
            <param name="system">TBD</param>
            <param name="self">TBD</param>
            <param name="routerProps">TBD</param>
            <param name="dispatcher">TBD</param>
            <param name="routeeProps">TBD</param>
            <param name="supervisor">TBD</param>
        </member>
        <member name="P:Akka.Routing.RoutedActorCell.Router">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Routing.RoutedActorCell.RouteeProps">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Routing.RoutedActorCell.RouterConfig">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.AddRoutee(Akka.Routing.Routee)">
            <summary>
            TBD
            </summary>
            <param name="routee">TBD</param>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.AddRoutees(System.Collections.Generic.IList{Akka.Routing.Routee})">
            <summary>
            TBD
            </summary>
            <param name="routees">TBD</param>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.RemoveRoutee(Akka.Routing.Routee,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="routee">TBD</param>
            <param name="stopChild">TBD</param>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.RemoveRoutees(System.Collections.Generic.IList{Akka.Routing.Routee},System.Boolean)">
            <summary>
            Remove routees from <see cref="P:Akka.Routing.RoutedActorCell.Router"/>. Messages in flight may still
            be routed to the old <see cref="P:Akka.Routing.RoutedActorCell.Router"/> instance containing the old routees.
            </summary>
            <param name="affectedRoutees">TBD</param>
            <param name="stopChild">TBD</param>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.StopIfChild(Akka.Routing.Routee)">
            <summary>
            Used to stop child routees - typically used in resizable <see cref="T:Akka.Routing.Pool"/> routers
            </summary>
            <param name="routee">TBD</param>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.Start">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.PreSuperStart">
            <summary>
            Called when <see cref="P:Akka.Routing.RoutedActorCell.Router"/> is initialized but before the base class' <see cref="M:Akka.Routing.RoutedActorCell.Start"/> to
            be able to do extra initialization in a subclass.
            </summary>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.SendMessage(Akka.Actor.Envelope)">
            <summary>
            TBD
            </summary>
            <param name="envelope">TBD</param>
        </member>
        <member name="M:Akka.Routing.RoutedActorCell.CreateNewActorInstance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Routing.RoutedActorRef">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.RoutedActorRef.#ctor(Akka.Actor.Internal.ActorSystemImpl,Akka.Actor.Props,Akka.Dispatch.MessageDispatcher,Akka.Dispatch.MailboxType,Akka.Actor.Props,Akka.Actor.IInternalActorRef,Akka.Actor.ActorPath)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RoutedActorRef"/> class.
            </summary>
            <param name="system">TBD</param>
            <param name="routerProps">TBD</param>
            <param name="routerDispatcher">TBD</param>
            <param name="routerMailbox">TBD</param>
            <param name="routeeProps">TBD</param>
            <param name="supervisor">TBD</param>
            <param name="path">TBD</param>
        </member>
        <member name="M:Akka.Routing.RoutedActorRef.NewCell">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Routing.NoRoutee">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.NoRoutee.Send(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
        </member>
        <member name="T:Akka.Routing.Routee">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Routing.Routee.NoRoutee">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.Routee.Send(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
        </member>
        <member name="M:Akka.Routing.Routee.Ask(System.Object,System.Nullable{System.TimeSpan})">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.Routee.FromActorRef(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actorRef">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Routing.ActorRefRoutee">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Routing.ActorRefRoutee.Actor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.ActorRefRoutee.#ctor(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
        </member>
        <member name="M:Akka.Routing.ActorRefRoutee.Send(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
        </member>
        <member name="M:Akka.Routing.ActorRefRoutee.Ask(System.Object,System.Nullable{System.TimeSpan})">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.ActorRefRoutee.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.ActorRefRoutee.Equals(Akka.Routing.ActorRefRoutee)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.ActorRefRoutee.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Routing.ActorSelectionRoutee">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Routing.ActorSelectionRoutee.Selection">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.ActorSelectionRoutee.#ctor(Akka.Actor.ActorSelection)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
        </member>
        <member name="M:Akka.Routing.ActorSelectionRoutee.Send(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
        </member>
        <member name="M:Akka.Routing.ActorSelectionRoutee.Ask(System.Object,System.Nullable{System.TimeSpan})">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="timeout">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.ActorSelectionRoutee.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.ActorSelectionRoutee.Equals(Akka.Routing.ActorSelectionRoutee)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.ActorSelectionRoutee.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Routing.RouterEnvelope">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterEnvelope.#ctor(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="P:Akka.Routing.RouterEnvelope.Message">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Routing.Broadcast">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.Broadcast.#ctor(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="T:Akka.Routing.SeveralRoutees">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.SeveralRoutees.#ctor(Akka.Routing.Routee[])">
            <summary>
            TBD
            </summary>
            <param name="routees">TBD</param>
        </member>
        <member name="M:Akka.Routing.SeveralRoutees.Send(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
        </member>
        <member name="T:Akka.Routing.RoutingLogic">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route messages to one or more actors.
            These actors are known in the system as a <see cref="T:Akka.Routing.Routee"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.RoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks a <see cref="T:Akka.Routing.Routee"/> to receive the <paramref name="message"/>.
            <note>
            Normally it picks one of the passed routees, but it is up to the implementation
            to return whatever <see cref="T:Akka.Routing.Routee"/> to use for sending a specific message.
            </note>
            </summary>
            <param name="message">The message that is being routed</param>
            <param name="routees">A collection of routees to choose from when receiving the <paramref name="message"/>.</param>
            <returns>A <see cref="T:Akka.Routing.Routee"/> that receives the <paramref name="message"/>.</returns>
        </member>
        <member name="T:Akka.Routing.Router">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.Router.#ctor(Akka.Routing.RoutingLogic,Akka.Actor.IActorRef,Akka.Actor.IActorRef[])">
            <summary>
            TBD
            </summary>
            <param name="logic">TBD</param>
            <param name="routee">TBD</param>
            <param name="routees">TBD</param>
        </member>
        <member name="M:Akka.Routing.Router.#ctor(Akka.Routing.RoutingLogic,Akka.Routing.Routee[])">
            <summary>
            TBD
            </summary>
            <param name="logic">TBD</param>
            <param name="routees">TBD</param>
        </member>
        <member name="P:Akka.Routing.Router.Routees">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Routing.Router.RoutingLogic">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.Router.Route(System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
        </member>
        <member name="M:Akka.Routing.Router.Send(Akka.Routing.Routee,System.Object,Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="routee">TBD</param>
            <param name="message">TBD</param>
            <param name="sender">TBD</param>
        </member>
        <member name="M:Akka.Routing.Router.WithRoutees(Akka.Routing.Routee[])">
            <summary>
            Create a new instance with the specified routees and the same <see cref="P:Akka.Routing.Router.RoutingLogic"/>.
            </summary>
            <param name="routees">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.Router.AddRoutee(Akka.Routing.Routee)">
            <summary>
            Create a new instance with one more routee and the same <see cref="P:Akka.Routing.Router.RoutingLogic"/>.
            </summary>
            <param name="routee">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.Router.AddRoutee(Akka.Actor.IActorRef)">
            <summary>
            Create a new instance with one more routee and the same <see cref="P:Akka.Routing.Router.RoutingLogic"/>.
            </summary>
            <param name="routee">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.Router.AddRoutee(Akka.Actor.ActorSelection)">
            <summary>
            Create a new instance with one more routee and the same <see cref="P:Akka.Routing.Router.RoutingLogic"/>.
            </summary>  
            <param name="routee">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.Router.RemoveRoutee(Akka.Routing.Routee)">
            <summary>
            Create a new instance without the specified routee.
            </summary>
            <param name="routee">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.Router.RemoveRoutee(Akka.Actor.IActorRef)">
            <summary>
            Create a new instance without the specified routee.
            </summary>
            <param name="routee">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.Router.RemoveRoutee(Akka.Actor.ActorSelection)">
            <summary>
            Create a new instance without the specified routee.
            </summary>
            <param name="routee">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Routing.RouterActor">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="P:Akka.Routing.RouterActor.Cell">
            <summary>
            TBD
            </summary>
            <exception cref="T:Akka.Actor.ActorInitializationException">TBD</exception>
        </member>
        <member name="M:Akka.Routing.RouterActor.OnReceive(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
        </member>
        <member name="M:Akka.Routing.RouterActor.StopIfAllRouteesRemoved">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterActor.PreRestart(System.Exception,System.Object)">
            <summary>
            TBD
            </summary>
            <param name="cause">TBD</param>
            <param name="message">TBD</param>
        </member>
        <member name="T:Akka.Routing.RouterConfig">
            <summary>
            This class provides base functionality used in the creation and configuration of the various routers in the system.
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterConfig.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RouterConfig"/> class.
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterConfig.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RouterConfig"/> class.
            <note>
            This method defaults to setting the dispatcher to use the <see cref="F:Akka.Dispatch.Dispatchers.DefaultDispatcherId"/>.
            </note>
            </summary>
            <param name="routerDispatcher">The dispatcher to use when passing messages to routees.</param>
        </member>
        <member name="P:Akka.Routing.RouterConfig.NoRouter">
            <summary>
            A configuration that specifies that no router is to be used.
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterConfig.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system"/>.
            </summary>
            <param name="system">The ActorSystem this router belongs to.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="P:Akka.Routing.RouterConfig.RouterDispatcher">
            <summary>
            Dispatcher ID to use for running the "head" actor, which handles supervision, death watch and router management messages.
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterConfig.RoutingLogicController(Akka.Routing.RoutingLogic)">
            <summary>
            Possibility to define an actor for controlling the routing
            logic from external stimuli(e.g.monitoring metrics).
            This actor will be a child of the router "head" actor.
            Management messages not handled by the "head" actor are
            delegated to this controller actor.
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterConfig.IsManagementMessage(System.Object)">
            <summary>
            Determines whether a provided message is handled by the router.
            </summary>
            <param name="message">The message to inspect.</param>
            <returns><c>true</c> if this message is handled by the router; otherwise <c>false</c>.</returns>
        </member>
        <member name="P:Akka.Routing.RouterConfig.StopRouterWhenAllRouteesRemoved">
            <summary>
            Specify that this router should stop itself when all routees have terminated (been removed).
            By Default it is `true`, unless a `resizer` is used.
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterConfig.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="M:Akka.Routing.RouterConfig.VerifyConfig(Akka.Actor.ActorPath)">
            <summary>
            Check that everything is there which is needed. Called in constructor of RoutedActorRef to fail early.
            </summary>
            <param name="path">TBD</param>
        </member>
        <member name="M:Akka.Routing.RouterConfig.CreateRouterActor">
            <summary>
            The router "head" actor.
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterConfig.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current router.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current router.</returns>
        </member>
        <member name="M:Akka.Routing.RouterConfig.Equals(Akka.Routing.RouterConfig)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Routing.RouterConfig.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Routing.Group">
            <summary>
            This class provides base functionality for all group routers in the system.
            Group routers are routers that use already created routees. These routees
            are supplied to the router and are addressed through <see cref="T:Akka.Actor.ActorSelection"/>
            paths.
            </summary>
        </member>
        <member name="M:Akka.Routing.Group.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            TBD
            </summary>
            <param name="paths">TBD</param>
            <param name="routerDispatcher">TBD</param>
        </member>
        <member name="P:Akka.Routing.Group.Paths">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.Group.GetPaths(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the actor paths used by this router during routee selection.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>An enumeration of actor paths used during routee selection</returns>
        </member>
        <member name="M:Akka.Routing.Group.Props">
            <summary>
            Adds the current router to an empty <see cref="T:Akka.Actor.Props"/>.
            </summary>
            <returns>An empty <see cref="T:Akka.Actor.Props"/> configured to use the current router.</returns>
        </member>
        <member name="M:Akka.Routing.Group.RouteeFor(System.String,Akka.Actor.IActorContext)">
            <summary>
            TBD
            </summary>
            <param name="path">TBD</param>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.Group.CreateRouterActor">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.Group.Equals(Akka.Routing.Group)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Routing.Group.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Routing.Group.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Routing.Pool">
            <summary>
            This class provides base functionality for all pool routers in the system.
            Pool routers are routers that create their own routees based on the provided
            configuration.
            </summary>
        </member>
        <member name="M:Akka.Routing.Pool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.Pool"/> class.
            <note>
            If a <paramref name="routerDispatcher"/> is not provided, this constructor sets up
            the pool to use the default dispatcher <see cref="F:Akka.Dispatch.Dispatchers.DefaultDispatcherId"/>.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
        </member>
        <member name="P:Akka.Routing.Pool.NrOfInstances">
            <summary>
            Retrieves the current number of routees in the pool.
            </summary>
        </member>
        <member name="M:Akka.Routing.Pool.GetNrOfInstances(Akka.Actor.ActorSystem)">
            <summary>
            Used by the <see cref="T:Akka.Routing.RoutedActorCell"/> to determine the initial number of routees.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The number of routees associated with this pool.</returns>
        </member>
        <member name="P:Akka.Routing.Pool.UsePoolDispatcher">
            <summary>
            Retrieve whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="M:Akka.Routing.Pool.NewRoutee(Akka.Actor.Props,Akka.Actor.IActorContext)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.Routee"/> configured to use the provided <paramref name="routeeProps"/>
            and the pool dispatcher if enabled.
            </summary>
            <param name="routeeProps">The <see cref="T:Akka.Actor.Props"/> to configure with the pool dispatcher.</param>
            <param name="context">The context for the provided <paramref name="routeeProps"/>.</param>
            <returns>
            A new <see cref="T:Akka.Routing.Routee"/> configured to use the provided <paramref name="routeeProps"/>
            and the pool dispatcher if enabled.
            </returns>
        </member>
        <member name="M:Akka.Routing.Pool.EnrichWithPoolDispatcher(Akka.Actor.Props,Akka.Actor.IActorContext)">
            <summary>
            TBD
            </summary>
            <param name="routeeProps">TBD</param>
            <param name="context">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Routing.Pool.Resizer">
            <summary>
            Retrieve the resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.Pool.SupervisorStrategy">
            <summary>
            Retrieve the strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="M:Akka.Routing.Pool.Props(Akka.Actor.Props)">
            <summary>
            Adds the current router to the provided <paramref name="routeeProps"/>.
            </summary>
            <param name="routeeProps">The <see cref="T:Akka.Actor.Props"/> to configure with the current router.</param>
            <returns>The provided <paramref name="routeeProps"/> configured to use the current router.</returns>
        </member>
        <member name="P:Akka.Routing.Pool.StopRouterWhenAllRouteesRemoved">
            <summary>
            Specify that this router should stop itself when all routees have terminated (been removed).
            </summary>
        </member>
        <member name="M:Akka.Routing.Pool.CreateRouterActor">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Routing.Pool.DefaultSupervisorStrategy">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.Pool.Equals(Akka.Routing.Pool)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Routing.Pool.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Routing.Pool.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Routing.CustomRouterConfig">
            <summary>
            If a custom router implementation is not a <see cref="T:Akka.Routing.Group"/> nor 
            a <see cref="T:Akka.Routing.Pool"/> it may extend this base class.
            </summary>
        </member>
        <member name="M:Akka.Routing.CustomRouterConfig.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.CustomRouterConfig.#ctor(System.String)">
            <summary>
            TBD
            </summary>
            <param name="routerDispatcher">TBD</param>
        </member>
        <member name="M:Akka.Routing.CustomRouterConfig.CreateRouterActor">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Routing.FromConfig">
            <summary>
            Router configuration which has no default, i.e. external configuration is required.
            This can be used when the dispatcher to be used for the head Router needs to be configured
            </summary>
        </member>
        <member name="M:Akka.Routing.FromConfig.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.FromConfig" /> class.
            </summary>
        </member>
        <member name="M:Akka.Routing.FromConfig.#ctor(Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.FromConfig" /> class.
            </summary>
            <param name="resizer">TBD</param>
            <param name="supervisorStrategy">TBD</param>
            <param name="routerDispatcher">TBD</param>
        </member>
        <member name="P:Akka.Routing.FromConfig.Instance">
            <summary>
            Retrieves a <see cref="T:Akka.Routing.RouterConfig"/> based on what's stored in the configuration.
            <note>
            This router is set to use the default dispatcher <see cref="F:Akka.Dispatch.Dispatchers.DefaultDispatcherId"/>.
            </note>
            </summary>
        </member>
        <member name="M:Akka.Routing.FromConfig.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            N/A
            </summary>
            <param name="system">N/A</param>
            <exception cref="T:System.NotSupportedException">
            This exception is automatically thrown since <see cref="T:Akka.Routing.FromConfig"/> cannot create routers.
            </exception>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Routing.FromConfig.CreateRouterActor">
            <summary>
            N/A
            </summary>
            <exception cref="T:System.NotSupportedException">
            This exception is automatically thrown since <see cref="T:Akka.Routing.FromConfig"/> cannot create router actors.
            </exception>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Routing.FromConfig.VerifyConfig(Akka.Actor.ActorPath)">
            <summary>
            N/A
            </summary>
            <param name="path">N/A</param>
            <exception cref="T:Akka.Configuration.ConfigurationException">
            This exception is automatically thrown since 'akka.actor.dispatch' is missing router configuration for <paramref name="path"/>.
            </exception>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Routing.FromConfig.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Setting the supervisor strategy to be used for the "head" Router actor
            </summary>
            <param name="strategy">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.FromConfig.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Setting the resizer to be used.
            </summary>
            <param name="resizer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.FromConfig.WithDispatcher(System.String)">
            <summary>
            Setting the dispatcher to be used for the router head actor, which handles
            supervision, death watch and router management messages.
            </summary>
            <param name="dispatcherId">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.FromConfig.GetNrOfInstances(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="sys">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.FromConfig.Props">
            <summary>
            Enriches a <see cref="T:Akka.Actor.Props"/> with what what's stored in the router configuration.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Routing.FromConfig.FromConfigSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.FromConfig"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.FromConfig.FromConfigSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.FromConfig"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.FromConfig"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="M:Akka.Routing.FromConfig.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.FromConfig"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.FromConfig"/>.</returns>
        </member>
        <member name="T:Akka.Routing.NoRouter">
            <summary>
            Routing configuration that indicates no routing; this is also the default
            value which hence overrides the merge strategy in order to accept values
            from lower-precedence sources. The decision whether or not to create a
            router is taken in the <see cref="T:Akka.Actor.LocalActorRefProvider"/> based on <see cref="M:Akka.Routing.NoRouter.Props(Akka.Actor.Props)"/>.
            </summary>
        </member>
        <member name="M:Akka.Routing.NoRouter.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.NoRouter.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            N/A
            </summary>
            <param name="system">N/A</param>
            <exception cref="T:System.NotSupportedException">
            This exception is automatically thrown since <see cref="T:Akka.Routing.NoRouter"/> cannot create routers.
            </exception>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Routing.NoRouter.CreateRouterActor">
            <summary>
            N/A
            </summary>
            <exception cref="T:System.NotSupportedException">
            This exception is automatically thrown since <see cref="T:Akka.Routing.NoRouter"/> cannot create router actors.
            </exception>
            <returns>N/A</returns>
        </member>
        <member name="P:Akka.Routing.NoRouter.RouterDispatcher">
            <summary>
            N/A
            </summary>
            <exception cref="T:System.NotSupportedException">
            This exception is automatically thrown since <see cref="T:Akka.Routing.NoRouter"/> does not have a dispatcher.
            </exception>
        </member>
        <member name="M:Akka.Routing.NoRouter.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            TBD
            </summary>
            <param name="routerConfig">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.NoRouter.Props(Akka.Actor.Props)">
            <summary>
            TBD
            </summary>
            <param name="routeeProps">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Routing.NoRouter.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Routing.NoRouter.NoRouterSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.NoRouter"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.NoRouter.NoRouterSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.NoRouter"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.NoRouter"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="M:Akka.Routing.NoRouter.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.NoRouter"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.NoRouter"/>.</returns>
        </member>
        <member name="T:Akka.Routing.RouterMessage">
            <summary>
            This class contains convenience methods used to send messages to a <see cref="T:Akka.Routing.Router"/>.
            </summary>
        </member>
        <member name="F:Akka.Routing.RouterMessage.GetRoutees">
            <summary>
            Sends a <see cref="T:Akka.Routing.RouterManagementMessage"/> to a <see cref="T:Akka.Routing.Router"/>
            to retrieve a list of routees that the router is currently using.
            </summary>
        </member>
        <member name="T:Akka.Routing.RouterManagementMessage">
            <summary>
            This class represents a non-routed message that is processed by the <see cref="T:Akka.Routing.Router"/>.
            These types of messages are for managing the router itself, like adding routees, deleting
            routees, etc.
            </summary>
        </member>
        <member name="T:Akka.Routing.GetRoutees">
            <summary>
            This class represents a <see cref="T:Akka.Routing.RouterManagementMessage"/> sent to a <see cref="T:Akka.Routing.Router"/> instructing
            it to send a <see cref="T:Akka.Routing.Routees"/> message back to the requestor that lists the routees that the router
            is currently using.
            </summary>
        </member>
        <member name="T:Akka.Routing.Routees">
            <summary>
            This class represents a message used to carry information about what routees a <see cref="T:Akka.Routing.Router"/> is currently using.
            </summary>
        </member>
        <member name="M:Akka.Routing.Routees.#ctor(System.Collections.Generic.IEnumerable{Akka.Routing.Routee})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.Routees"/> class.
            </summary>
            <param name="routees">The routees that a <see cref="T:Akka.Routing.Router"/> is currently using.</param>
        </member>
        <member name="P:Akka.Routing.Routees.Members">
            <summary>
            An enumeration of routees that a <see cref="T:Akka.Routing.Router"/> is currently using.
            </summary>
        </member>
        <member name="T:Akka.Routing.RemoveRoutee">
            <summary>
            This class represents a <see cref="T:Akka.Routing.RouterManagementMessage"/> sent to a <see cref="T:Akka.Routing.Router"/> instructing
            it to remove a specific routee from the router's collection of routees. It may be handled after other messages.
            
            <note>
            For a pool with child routees the routee is stopped by sending a <see cref="T:Akka.Actor.PoisonPill"/>
            to the routee. Precautions are taken to reduce the risk of dropping messages that are concurrently
            being routed to the remove routee, but there are no guarantees. 
            </note>
            </summary>
        </member>
        <member name="M:Akka.Routing.RemoveRoutee.#ctor(Akka.Routing.Routee)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RemoveRoutee"/> class.
            </summary>
            <param name="routee">The routee to remove from the router's collection of routees.</param>
        </member>
        <member name="P:Akka.Routing.RemoveRoutee.Routee">
            <summary>
            The routee removed from the router's collection of routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.AddRoutee">
            <summary>
            This class represents a <see cref="T:Akka.Routing.RouterManagementMessage"/> sent to a <see cref="T:Akka.Routing.Router"/> instructing
            it to add a specific routee to the router's collection of routees. It may be handled after other messages.
            </summary>
        </member>
        <member name="M:Akka.Routing.AddRoutee.#ctor(Akka.Routing.Routee)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.AddRoutee"/> class.
            </summary>
            <param name="routee">The routee added to the router's collection of routees.</param>
        </member>
        <member name="P:Akka.Routing.AddRoutee.Routee">
            <summary>
            The routee added to the router's collection of routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.AdjustPoolSize">
            <summary>
            This class represents a <see cref="T:Akka.Routing.RouterManagementMessage"/> sent to a <see cref="T:Akka.Routing.Pool"/> router instructing
            it to increase or decrease the number of alloted routees the router can use. It may be handled after other messages.
            
            <remarks>
            Positive <see cref="P:Akka.Routing.AdjustPoolSize.Change"/> will add that number of routees to the <see cref="T:Akka.Routing.Pool"/>.
            Negative <see cref="P:Akka.Routing.AdjustPoolSize.Change"/> will remove that number of routees from the <see cref="T:Akka.Routing.Pool"/>.
            </remarks>
             <notes>
            Routees are stopped by sending a <see cref="T:Akka.Actor.PoisonPill"/> to the routee.
            Precautions are taken to reduce the risk of dropping messages that are concurrently
            being routed to the remove routee, but there are no guarantees. 
            </notes>
            </summary>
        </member>
        <member name="M:Akka.Routing.AdjustPoolSize.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.AdjustPoolSize"/> class.
            </summary>
            <param name="change">The number of routees to add or subtract from the <see cref="T:Akka.Routing.Pool"/>.</param>
        </member>
        <member name="P:Akka.Routing.AdjustPoolSize.Change">
            <summary>
            The number of routees added or subtracted from the <see cref="T:Akka.Routing.Pool"/>.
            </summary>
        </member>
        <member name="T:Akka.Routing.RouterPoolActor">
            <summary>
            INTERNAL API
            
            Actor implementation for <see cref="F:Akka.Routing.RouterPoolActor.Pool"/> routers.
            </summary>
        </member>
        <member name="F:Akka.Routing.RouterPoolActor.Pool">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Routing.RouterPoolActor.#ctor(Akka.Actor.SupervisorStrategy)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.RouterPoolActor"/> class.
            </summary>
            <param name="supervisorStrategy">The supervisor strategy.</param>
            <exception cref="T:Akka.Actor.ActorInitializationException">TBD</exception>
        </member>
        <member name="M:Akka.Routing.RouterPoolActor.SupervisorStrategy">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Routing.RouterPoolActor.OnReceive(System.Object)">
            <summary>
            Called when [receive].
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:Akka.Routing.ScatterGatherFirstCompletedRoutingLogic">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route a message to a <see cref="T:Akka.Routing.Routee"/> determined
            using scatter-gather-first-completed. This process has the router send a message to all of its routees. The first
            response is used and the remaining are discarded. If the none of the routees respond within a specified time
            limit, a timeout failure occurs.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedRoutingLogic.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedRoutingLogic"/> class.
            </summary>
            <param name="within">The amount of time to wait for a response.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedRoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks all the provided <paramref name="routees"/> to receive the <paramref name="message" />.
            </summary>
            <param name="message">The message that is being routed</param>
            <param name="routees">A collection of routees to choose from when receiving the <paramref name="message" />.</param>
            <returns>A <see cref="T:Akka.Routing.ScatterGatherFirstCompletedRoutees" /> that receives the <paramref name="message" />.</returns>
        </member>
        <member name="T:Akka.Routing.ScatterGatherFirstCompletedRoutees">
            <summary>
            This class represents a single point <see cref="T:Akka.Routing.Routee"/> that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined
            using scatter-gather-first-completed. This process has the router send a message to all of its routees. The first
            response is used and the remaining are discarded. If the none of the routees respond within a specified time limit,
            a timeout failure occurs.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedRoutees.#ctor(Akka.Routing.Routee[],System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedRoutees"/> class.
            </summary>
            <param name="routees">The list of routees that the router uses to send messages.</param>
            <param name="within">The time within which at least one response is expected.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedRoutees.Send(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Sends a message to the collection of routees.
            </summary>
            <param name="message">The message that is being sent.</param>
            <param name="sender">The actor sending the message.</param>
        </member>
        <member name="T:Akka.Routing.ScatterGatherFirstCompletedPool">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Pool"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using scatter-gather-first-completed.
            This process has the router send a message to all of its routees. The first response is used and the remaining are discarded. If the none of the
            routees respond within a specified time limit, a timeout failure occurs.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> class.
            </summary>
            <param name="config">
            The configuration to use to lookup paths used by the group router.
            
            <note>
            'within' must be defined in the provided configuration.
            </note>
            </param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> class.
            
            <note>
            A <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> configured in this way uses the <see cref="P:Akka.Routing.Pool.DefaultSupervisorStrategy"/> supervisor strategy.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="within">The amount of time to wait for a response.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.#ctor(System.Int32,Akka.Routing.Resizer,System.TimeSpan,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedPool.Within">
            <summary>
            The amount of time to wait for a response.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.GetNrOfInstances(Akka.Actor.ActorSystem)">
            <summary>
            Used by the <see cref="T:Akka.Routing.RoutedActorCell" /> to determine the initial number of routees.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The number of routees associated with this pool.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool" /> router with a given <see cref="T:Akka.Actor.SupervisorStrategy" />.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy" />.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool" /> router with a given <see cref="T:Akka.Routing.Resizer" />.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer" />.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool" /> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/>.</returns>
        </member>
        <member name="T:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.ScatterGatherFirstCompletedPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate.Within">
            <summary>
            The amount of time to wait for a response.
            </summary>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedPool.ScatterGatherFirstCompletedPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.ScatterGatherFirstCompletedGroup">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Group"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using scatter-gather-first-completed.
            This process has the router send a message to all of its routees. The first response is used and the remaining are discarded. If the none of the
            routees respond within a specified time limit, a timeout failure occurs.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/> class.
            </summary>
            <param name="config">
            The configuration to use to lookup paths used by the group router.
            
            <note>
            If 'routees.path' is defined in the provided configuration then those paths will be used by the router.
            If 'within' is defined in the provided configuration then that will be used as the interval.
            </note>
            </param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.#ctor(System.TimeSpan,System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup" /> class.
            </summary>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="paths">A list of actor paths used by the group router.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.#ctor(System.Collections.Generic.IEnumerable{System.String},System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup" /> class.
            </summary>
            <param name="paths">An enumeration of actor paths used by the group router.</param>
            <param name="within">The amount of time to wait for a response.</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.#ctor(System.Collections.Generic.IEnumerable{Akka.Actor.IActorRef},System.TimeSpan)">
            <summary>
            Obsolete. Use <see cref="M:Akka.Routing.ScatterGatherFirstCompletedGroup.#ctor(System.Collections.Generic.IEnumerable{System.String},System.TimeSpan)"/> instead.
            <code>
            new ScatterGatherFirstCompletedGroup(actorRefs.Select(c => c.Path.ToString()), within)
            </code>
            </summary>
            <param name="routees">N/A</param>
            <param name="within">N/A</param>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.#ctor(System.Collections.Generic.IEnumerable{System.String},System.TimeSpan,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup" /> class.
            </summary>
            <param name="paths">An enumeration of actor paths used by the group router.</param>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedGroup.Within">
            <summary>
            The amount of time to wait for a response.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.GetPaths(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the actor paths used by this router during routee selection.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>An enumeration of actor paths used during routee selection</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup" /> router with a given dispatcher id.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/>.</returns>
        </member>
        <member name="T:Akka.Routing.ScatterGatherFirstCompletedGroup.ScatterGatherFirstCompletedGroupSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.ScatterGatherFirstCompletedGroup.ScatterGatherFirstCompletedGroupSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.ScatterGatherFirstCompletedGroup"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedGroup.ScatterGatherFirstCompletedGroupSurrogate.Within">
            <summary>
            The amount of time to wait for a response.
            </summary>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedGroup.ScatterGatherFirstCompletedGroupSurrogate.Paths">
            <summary>
            The actor paths used by this router during routee selection.
            </summary>
        </member>
        <member name="P:Akka.Routing.ScatterGatherFirstCompletedGroup.ScatterGatherFirstCompletedGroupSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.SmallestMailboxRoutingLogic">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route a message to a <see cref="T:Akka.Routing.Routee"/>
            determined using smallest-mailbox. This process has the router select a routee based on the fewest number
            of messages in its routees' mailbox. The selection is done in the following order:
            
            <ul>
            <li>Pick any routee with an empty mailbox.</li>
            <li>Pick a routee with the fewest pending messages in its mailbox.</li>
            <li>Pick any remaining routees.</li>
            </ul>
            <note>
            Remote routees are consider lowest priority, since their mailbox size is unknown.
            </note>
            <note>
            For the case, when all routees are of unpredictable size, the selection process fails back to round-robin.
            </note>
            </summary>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxRoutingLogic.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.SmallestMailboxRoutingLogic"/> class.
            </summary>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxRoutingLogic.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.SmallestMailboxRoutingLogic"/> class.
            </summary>
            <param name="next">Seed value used in the fallback selection process.</param>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxRoutingLogic.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks a <see cref="T:Akka.Routing.Routee" /> to receive the <paramref name="message" />.
            </summary>
            <param name="message">The message that is being routed</param>
            <param name="routees">A collection of routees to choose from when receiving the <paramref name="message" />.</param>
            <returns>A <see cref="T:Akka.Routing.Routee" /> that receives the <paramref name="message" />.</returns>
        </member>
        <member name="T:Akka.Routing.SmallestMailboxPool">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Pool"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using smallest-mailbox.
            Please refer to <see cref="T:Akka.Routing.SmallestMailboxRoutingLogic"/> for more information on the selection process.
            </summary>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.SmallestMailboxPool"/> class.
            </summary>
            <param name="config">The configuration used to configure the pool.</param>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.SmallestMailboxPool"/> class.
            <note>
            A <see cref="T:Akka.Routing.SmallestMailboxPool"/> configured in this way uses the <see cref="P:Akka.Routing.Pool.DefaultSupervisorStrategy"/> supervisor strategy.
            </note>
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.SmallestMailboxPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.GetNrOfInstances(Akka.Actor.ActorSystem)">
            <summary>
            Used by the <see cref="T:Akka.Routing.RoutedActorCell" /> to determine the initial number of routees.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The number of routees associated with this pool.</returns>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.SmallestMailboxPool" /> router with a given <see cref="T:Akka.Actor.SupervisorStrategy" />.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy" />.</returns>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.SmallestMailboxPool" /> router with a given <see cref="T:Akka.Routing.Resizer" />.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer" /> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer" />.</returns>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.SmallestMailboxPool" /> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information. </returns>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.SmallestMailboxPool"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.SmallestMailboxPool"/>.</returns>
        </member>
        <member name="T:Akka.Routing.SmallestMailboxPool.SmallestMailboxPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.SmallestMailboxPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.SmallestMailboxPool.SmallestMailboxPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.SmallestMailboxPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.SmallestMailboxPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.SmallestMailboxPool.SmallestMailboxPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.SmallestMailboxPool.SmallestMailboxPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.SmallestMailboxPool.SmallestMailboxPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.SmallestMailboxPool.SmallestMailboxPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.SmallestMailboxPool.SmallestMailboxPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.TailChopping">
            <summary>
            This class contains logic used by a <see cref="T:Akka.Routing.Router"/> to route a message to a <see cref="T:Akka.Routing.Routee"/> determined using tail-chopping.
            This process has the router select a random routee, then waits an interval before sending to a different randomly chosen routee.
            The first response is used and the remaining are discarded. If the none of the routees respond within a specified time limit,
            a timeout failure occurs.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChopping.#ctor(Akka.Actor.IScheduler,System.TimeSpan,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChopping"/> class.
            </summary>
            <param name="within">The time within which at least one response is expected.</param>
            <param name="interval">The duration after which the next routee will be picked.</param>
            <param name="scheduler">The <see cref="T:Akka.Actor.IScheduler"/> used to force deadlines.</param>
        </member>
        <member name="M:Akka.Routing.TailChopping.Select(System.Object,Akka.Routing.Routee[])">
            <summary>
            Picks all of the provided <paramref name="routees"/> to receive the <paramref name="message" />.
            </summary>
            <param name="message">The message that is being routed</param>
            <param name="routees">A collection of routees used when receiving the <paramref name="message" />.</param>
            <returns>A <see cref="T:Akka.Routing.TailChoppingRoutee" /> that receives the <paramref name="message" />.</returns>
        </member>
        <member name="T:Akka.Routing.TailChoppingRoutee">
            <summary>
            This class represents a single point <see cref="T:Akka.Routing.Routee"/> that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using tail-chopping.
            This process has the routee select a random routee, then waits an interval before sending to a different randomly chosen routee.
            The first response is used and the remaining are discarded. If the none of the routees respond within a specified time limit,
            a timeout failure occurs.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingRoutee.#ctor(Akka.Actor.IScheduler,Akka.Routing.Routee[],System.TimeSpan,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChoppingRoutee"/> class.
            </summary>
            <param name="routees">The list of routees that the router uses to send messages.</param>
            <param name="within">The time within which at least one response is expected.</param>
            <param name="interval">The duration after which the next routee will be picked.</param>
            <param name="scheduler">The <see cref="T:Akka.Actor.IScheduler"/> used to force deadlines.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingRoutee.Send(System.Object,Akka.Actor.IActorRef)">
            <summary>
            Sends a message to the collection of routees.
            </summary>
            <param name="message">The message that is being sent.</param>
            <param name="sender">The actor sending the message.</param>
        </member>
        <member name="T:Akka.Routing.TailChoppingPool">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Pool"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using tail-chopping.
            This process has the router select a random routee, then waits an interval before sending to a different randomly chosen routee.
            The first response is used and the remaining are discarded. If the none of the routees respond within a specified time limit,
            a timeout failure occurs.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChoppingPool"/> class.
            <note>
            'nr-of-instances', 'within', and 'tail-chopping-router.interval'
            must be defined in the provided configuration.
            </note>
            </summary>
            <param name="config">The configuration used to configure the pool.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.#ctor(System.Int32,System.TimeSpan,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChoppingPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="interval">The interval to wait before sending to the next routee.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.#ctor(System.Int32,Akka.Routing.Resizer,Akka.Actor.SupervisorStrategy,System.String,System.TimeSpan,System.TimeSpan,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChoppingPool"/> class.
            </summary>
            <param name="nrOfInstances">The initial number of routees in the pool.</param>
            <param name="resizer">The resizer to use when dynamically allocating routees to the pool.</param>
            <param name="supervisorStrategy">The strategy to use when supervising the pool.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="interval">The interval to wait before sending to the next routee.</param>
            <param name="usePoolDispatcher"><c>true</c> to use the pool dispatcher; otherwise <c>false</c>.</param>
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.Within">
            <summary>
            The amount of time to wait for a response.
            </summary>
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.Interval">
            <summary>
            The amount of time to wait before sending to the next routee.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.GetNrOfInstances(Akka.Actor.ActorSystem)">
            <summary>
            Used by the <see cref="T:Akka.Routing.RoutedActorCell" /> to determine the initial number of routees.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The number of routees associated with this pool.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.WithSupervisorStrategy(Akka.Actor.SupervisorStrategy)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.TailChoppingPool"/> router with a given <see cref="T:Akka.Actor.SupervisorStrategy"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="strategy">The <see cref="T:Akka.Actor.SupervisorStrategy"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="strategy"/>.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.WithResizer(Akka.Routing.Resizer)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.TailChoppingPool"/> router with a given <see cref="T:Akka.Routing.Resizer"/>.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="resizer">The <see cref="T:Akka.Routing.Resizer"/> used to configure the new router.</param>
            <returns>A new router with the provided <paramref name="resizer"/>.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.TailChoppingPool"/> router with a given dispatcher id.
            
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.WithFallback(Akka.Routing.RouterConfig)">
            <summary>
            Configure the current router with an auxiliary router for routes that it does not know how to handle.
            </summary>
            <param name="routerConfig">The router to use as an auxiliary source.</param>
            <returns>The router configured with the auxiliary information.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.TailChoppingPool"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.TailChoppingPool"/>.</returns>
        </member>
        <member name="T:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.TailChoppingPool"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.TailChoppingPool"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.TailChoppingPool"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.Interval">
            The interval to wait before sending to the next routee.
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.Within">
            The amount of time to wait for a response.
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.NrOfInstances">
            <summary>
            The number of routees associated with this pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.UsePoolDispatcher">
            <summary>
            Determine whether or not to use the pool dispatcher. The dispatcher is defined in the
            'pool-dispatcher' configuration property in the deployment section of the router.
            </summary>
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.Resizer">
            <summary>
            The resizer to use when dynamically allocating routees to the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.SupervisorStrategy">
            <summary>
            The strategy to use when supervising the pool.
            </summary>
        </member>
        <member name="P:Akka.Routing.TailChoppingPool.TailChoppingPoolSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="T:Akka.Routing.TailChoppingGroup">
            <summary>
            This class represents a <see cref="T:Akka.Routing.Group"/> router that sends messages to a <see cref="T:Akka.Routing.Routee"/> determined using tail-chopping.
            This process has the router select a random routee, then waits an interval before sending to a different randomly chosen routee.
            The first response is used and the remaining are discarded. If the none of the routees respond within a specified time limit,
            a timeout failure occurs.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.#ctor(Akka.Configuration.Config)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChoppingGroup"/> class.
            </summary>
            <param name="config">
            The configuration to use to lookup paths used by the group router.
            <note>
            If 'routees.path' is defined in the provided configuration then those paths will be used by the router.
            If 'within' is defined in the provided configuration then that will be used as the timeout.
            If 'tail-chopping-router.interval' is defined in the provided configuration then that will be used as the interval.
            </note>
            </param>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.#ctor(System.Collections.Generic.IEnumerable{System.String},System.TimeSpan,System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChoppingGroup"/> class.
            </summary>
            <param name="routeePaths">The actor paths used by this router during routee selection.</param>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="interval">The interval to wait before sending to the next routee.</param>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.#ctor(System.Collections.Generic.IEnumerable{System.String},System.TimeSpan,System.TimeSpan,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Routing.TailChoppingGroup"/> class.
            </summary>
            <param name="routeePaths">The actor paths used by this router during routee selection.</param>
            <param name="within">The amount of time to wait for a response.</param>
            <param name="interval">The interval to wait before sending to the next routee.</param>
            <param name="routerDispatcher">The dispatcher to use when passing messages to the routees.</param>
        </member>
        <member name="P:Akka.Routing.TailChoppingGroup.Within">
            <summary>
            The amount of time to wait for a response.
            </summary>
        </member>
        <member name="P:Akka.Routing.TailChoppingGroup.Interval">
            <summary>
            The amount of time to wait before sending to the next routee.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.CreateRouter(Akka.Actor.ActorSystem)">
            <summary>
            Creates a router that is responsible for routing messages to routees within the provided <paramref name="system" />.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The newly created router tied to the given system.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.GetPaths(Akka.Actor.ActorSystem)">
            <summary>
            Retrieves the actor paths used by this router during routee selection.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>An enumeration of actor paths used during routee selection</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.WithDispatcher(System.String)">
            <summary>
            Creates a new <see cref="T:Akka.Routing.TailChoppingGroup" /> router with a given dispatcher id.
            <note>
            This method is immutable and returns a new instance of the router.
            </note>
            </summary>
            <param name="dispatcher">The dispatcher id used to configure the new router.</param>
            <returns>A new router with the provided dispatcher id.</returns>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a surrogate representation of the current <see cref="T:Akka.Routing.TailChoppingGroup"/>.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The surrogate representation of the current <see cref="T:Akka.Routing.TailChoppingGroup"/>.</returns>
        </member>
        <member name="T:Akka.Routing.TailChoppingGroup.TailChoppingGroupSurrogate">
            <summary>
            This class represents a surrogate of a <see cref="T:Akka.Routing.TailChoppingGroup"/> router.
            Its main use is to help during the serialization process.
            </summary>
        </member>
        <member name="M:Akka.Routing.TailChoppingGroup.TailChoppingGroupSurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            Creates a <see cref="T:Akka.Routing.TailChoppingGroup"/> encapsulated by this surrogate.
            </summary>
            <param name="system">The actor system that owns this router.</param>
            <returns>The <see cref="T:Akka.Routing.TailChoppingGroup"/> encapsulated by this surrogate.</returns>
        </member>
        <member name="P:Akka.Routing.TailChoppingGroup.TailChoppingGroupSurrogate.Paths">
            <summary>
            The actor paths used by this router during routee selection.
            </summary>
        </member>
        <member name="P:Akka.Routing.TailChoppingGroup.TailChoppingGroupSurrogate.Within">
            <summary>
            The amount of time to wait for a response.
            </summary>
        </member>
        <member name="P:Akka.Routing.TailChoppingGroup.TailChoppingGroupSurrogate.Interval">
            <summary>
            The interval to wait before sending to the next routee.
            </summary>
        </member>
        <member name="P:Akka.Routing.TailChoppingGroup.TailChoppingGroupSurrogate.RouterDispatcher">
            <summary>
            The dispatcher to use when passing messages to the routees.
            </summary>
        </member>
        <member name="T:Akka.Serialization.ByteArraySerializer">
            <summary>
            This is a special <see cref="T:Akka.Serialization.Serializer"/> that serializes and deserializes byte arrays only
            (just returns the byte array unchanged/uncopied).
            </summary>
        </member>
        <member name="M:Akka.Serialization.ByteArraySerializer.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Serialization.ByteArraySerializer" /> class.
            </summary>
            <param name="system">The actor system to associate with this serializer. </param>
        </member>
        <member name="P:Akka.Serialization.ByteArraySerializer.IncludeManifest">
            <summary>
            Returns whether this serializer needs a manifest in the fromBinary method
            </summary>
        </member>
        <member name="M:Akka.Serialization.ByteArraySerializer.ToBinary(System.Object)">
            <summary>
            Serializes the given object into a byte array
            </summary>
            <param name="obj">The object to serialize </param>
            <exception cref="T:System.NotSupportedException">
            This exception is thrown if the given <paramref name="obj"/> is not a byte array.
            </exception>
            <returns>A byte array containing the serialized object</returns>
        </member>
        <member name="M:Akka.Serialization.ByteArraySerializer.FromBinary(System.Byte[],System.Type)">
            <summary>
            Deserializes a byte array into an object of type <paramref name="type"/>.
            </summary>
            <param name="bytes">The array containing the serialized object</param>
            <param name="type">The type of object contained in the array</param>
            <returns>The object contained in the array</returns>
        </member>
        <member name="T:Akka.Serialization.NewtonSoftJsonSerializerSettings">
            <summary>
            A typed settings for a <see cref="T:Akka.Serialization.NewtonSoftJsonSerializer"/> class.
            </summary>
        </member>
        <member name="F:Akka.Serialization.NewtonSoftJsonSerializerSettings.Default">
            <summary>
            A default instance of <see cref="T:Akka.Serialization.NewtonSoftJsonSerializerSettings"/> used when no custom configuration has been provided.
            </summary>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializerSettings.Create(Akka.Configuration.Config)">
            <summary>
            Creates a new instance of the <see cref="T:Akka.Serialization.NewtonSoftJsonSerializerSettings"/> based on a provided <paramref name="config"/>.
            Config may define several key-values:
            <ul>
            <li>`encode-type-names` (boolean) mapped to <see cref="P:Akka.Serialization.NewtonSoftJsonSerializerSettings.EncodeTypeNames"/></li>
            <li>`preserve-object-references` (boolean) mapped to <see cref="P:Akka.Serialization.NewtonSoftJsonSerializerSettings.PreserveObjectReferences"/></li>
            <li>`converters` (type list) mapped to <see cref="P:Akka.Serialization.NewtonSoftJsonSerializerSettings.Converters"/>. They must implement <see cref="T:Newtonsoft.Json.JsonConverter"/> and define either default constructor or constructor taking <see cref="T:Akka.Actor.ExtendedActorSystem"/> as its only parameter.</li>
            </ul>
            </summary>
            <exception cref="T:System.ArgumentNullException">Raised when no <paramref name="config"/> was provided.</exception>
            <exception cref="T:System.ArgumentException">Raised when types defined in `converters` list didn't inherit <see cref="T:Newtonsoft.Json.JsonConverter"/>.</exception>
        </member>
        <member name="P:Akka.Serialization.NewtonSoftJsonSerializerSettings.EncodeTypeNames">
            <summary>
            When true, serializer will encode a type names into serialized json $type field. This must be true 
            if <see cref="T:Akka.Serialization.NewtonSoftJsonSerializer"/> is a default serializer in order to support polymorphic 
            deserialization.
            </summary>
        </member>
        <member name="P:Akka.Serialization.NewtonSoftJsonSerializerSettings.PreserveObjectReferences">
            <summary>
            When true, serializer will track a reference dependencies in serialized object graph. This must be 
            true if <see cref="T:Akka.Serialization.NewtonSoftJsonSerializer"/>.
            </summary>
        </member>
        <member name="P:Akka.Serialization.NewtonSoftJsonSerializerSettings.Converters">
            <summary>
            A collection of an additional converter types to be applied to a <see cref="T:Akka.Serialization.NewtonSoftJsonSerializer"/>.
            Converters must inherit from <see cref="T:Newtonsoft.Json.JsonConverter"/> class and implement a default constructor.
            </summary>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializerSettings.#ctor(System.Boolean,System.Boolean,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Creates a new instance of the <see cref="T:Akka.Serialization.NewtonSoftJsonSerializerSettings"/>.
            </summary>
            <param name="encodeTypeNames">Determines if a special `$type` field should be emitted into serialized JSON. Must be true if corresponding serializer is used as default.</param>
            <param name="preverveObjectReferences">Determines if object references should be tracked within serialized object graph. Must be true if corresponding serialize is used as default.</param>
            <param name="converters">A list of types implementing a <see cref="T:Newtonsoft.Json.JsonConverter"/> to support custom types serialization.</param>
        </member>
        <member name="T:Akka.Serialization.NewtonSoftJsonSerializer">
            <summary>
            This is a special <see cref="P:Akka.Serialization.NewtonSoftJsonSerializer.Serializer"/> that serializes and deserializes javascript objects only.
            These objects need to be in the JavaScript Object Notation (JSON) format.
            </summary>
        </member>
        <member name="P:Akka.Serialization.NewtonSoftJsonSerializer.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Serialization.NewtonSoftJsonSerializer.Serializer">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Serialization.NewtonSoftJsonSerializer" /> class.
            </summary>
            <param name="system">The actor system to associate with this serializer. </param>
        </member>
        <member name="P:Akka.Serialization.NewtonSoftJsonSerializer.IncludeManifest">
            <summary>
            Returns whether this serializer needs a manifest in the fromBinary method
            </summary>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.ToBinary(System.Object)">
            <summary>
            Serializes the given object into a byte array
            </summary>
            <param name="obj">The object to serialize </param>
            <returns>A byte array containing the serialized object</returns>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.FromBinary(System.Byte[],System.Type)">
            <summary>
            Deserializes a byte array into an object of type <paramref name="type"/>.
            </summary>
            <param name="bytes">The array containing the serialized object</param>
            <param name="type">The type of object contained in the array</param>
            <returns>The object contained in the array</returns>
        </member>
        <member name="T:Akka.Serialization.NewtonSoftJsonSerializer.SurrogateConverter">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.SurrogateConverter.#ctor(Akka.Serialization.NewtonSoftJsonSerializer)">
            <summary>
            TBD
            </summary>
            <param name="parent">TBD</param>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.SurrogateConverter.CanConvert(System.Type)">
            <summary>
                Determines whether this instance can convert the specified object type.
            </summary>
            <param name="objectType">Type of the object.</param>
            <returns><c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.SurrogateConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
            <param name="objectType">Type of the object.</param>
            <param name="existingValue">The existing value of object being read.</param>
            <param name="serializer">The calling serializer.</param>
            <returns>The object value.</returns>
        </member>
        <member name="M:Akka.Serialization.NewtonSoftJsonSerializer.SurrogateConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
            <param name="value">The value.</param>
            <param name="serializer">The calling serializer.</param>
        </member>
        <member name="T:Akka.Serialization.NullSerializer">
            <summary>
            This is a special <see cref="T:Akka.Serialization.Serializer"/> that serializes and deserializes nulls only
            </summary>
        </member>
        <member name="M:Akka.Serialization.NullSerializer.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Serialization.NullSerializer" /> class.
            </summary>
            <param name="system">The actor system to associate with this serializer. </param>
        </member>
        <member name="P:Akka.Serialization.NullSerializer.Identifier">
            <summary>
            Completely unique value to identify this implementation of the <see cref="T:Akka.Serialization.Serializer"/> used to optimize network traffic
            </summary>
        </member>
        <member name="P:Akka.Serialization.NullSerializer.IncludeManifest">
            <summary>
            Returns whether this serializer needs a manifest in the fromBinary method
            </summary>
        </member>
        <member name="M:Akka.Serialization.NullSerializer.ToBinary(System.Object)">
            <summary>
            Serializes the given object into a byte array
            </summary>
            <param name="obj">The object to serialize </param>
            <returns>A byte array containing the serialized object</returns>
        </member>
        <member name="M:Akka.Serialization.NullSerializer.FromBinary(System.Byte[],System.Type)">
            <summary>
            Deserializes a byte array into an object of type <paramref name="type"/>
            </summary>
            <param name="bytes">The array containing the serialized object</param>
            <param name="type">The type of object contained in the array</param>
            <returns>The object contained in the array</returns>
        </member>
        <member name="T:Akka.Serialization.Information">
            <summary>
            Serialization information needed for serializing local actor refs.
            </summary>
        </member>
        <member name="T:Akka.Serialization.Serialization">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Serialization.Serialization.SerializeWithTransport``1(Akka.Actor.ActorSystem,Akka.Actor.Address,System.Func{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="system">TBD</param>
            <param name="address">TBD</param>
            <param name="action">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Serialization.Serialization.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
        </member>
        <member name="P:Akka.Serialization.Serialization.System">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Serialization.Serialization.AddSerializer(Akka.Serialization.Serializer)">
            <summary>
            TBD
            </summary>
            <param name="serializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Serialization.Serialization.AddSerializationMap(System.Type,Akka.Serialization.Serializer)">
            <summary>
            TBD
            </summary>
            <param name="type">TBD</param>
            <param name="serializer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Serialization.Serialization.Deserialize(System.Byte[],System.Int32,System.Type)">
            <summary>
            Deserializes the given array of bytes using the specified serializer id, using the optional type hint to the Serializer.
            </summary>
            <param name="bytes">TBD</param>
            <param name="serializerId">TBD</param>
            <param name="type">TBD</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            This exception is thrown if the system cannot find the serializer with the given <paramref name="serializerId"/>.
            </exception>
            <returns>The resulting object</returns>
        </member>
        <member name="M:Akka.Serialization.Serialization.Deserialize(System.Byte[],System.Int32,System.String)">
            <summary>
            Deserializes the given array of bytes using the specified serializer id, using the optional type hint to the Serializer.
            </summary>
            <param name="bytes">TBD</param>
            <param name="serializerId">TBD</param>
            <param name="manifest">TBD</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            This exception is thrown if the system cannot find the serializer with the given <paramref name="serializerId"/>
            or it couldn't find the given <paramref name="manifest"/> with the given <paramref name="serializerId"/>.
            </exception>
            <returns>The resulting object</returns>
        </member>
        <member name="M:Akka.Serialization.Serialization.FindSerializerFor(System.Object)">
            <summary>
            Returns the Serializer configured for the given object, returns the NullSerializer if it's null.
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Serialization.Serialization.FindSerializerForType(System.Type)">
            <summary>
            Returns the configured Serializer for the given Class. The configured Serializer
            is used if the configured class `IsAssignableFrom` from the <see cref="T:System.Type">type</see>, i.e.
            the configured class is a super class or implemented interface. In case of
            ambiguity it is primarily using the most specific configured class,
            and secondly the entry configured first.
            </summary>
            <param name="objectType">TBD</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            This exception is thrown if the serializer of the given <paramref name="objectType"/> could not be found.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Serialization.Serialization.SerializedActorPath(Akka.Actor.IActorRef)">
            <summary>
            TBD
            </summary>
            <param name="actorRef">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Serialization.Serializer">
             <summary>
             A Serializer represents a bimap between an object and an array of bytes representing that object.
            
             Serializers are loaded using reflection during <see cref="T:Akka.Actor.ActorSystem"/>
             start-up, where two constructors are tried in order:
            
             <ul>
             <li>taking exactly one argument of type <see cref="T:Akka.Actor.ExtendedActorSystem"/>;
             this should be the preferred one because all reflective loading of classes
             during deserialization should use ExtendedActorSystem.dynamicAccess (see
             [[akka.actor.DynamicAccess]]), and</li>
             <li>without arguments, which is only an option if the serializer does not
             load classes using reflection.</li>
             </ul>
            
             <b>Be sure to always use the PropertyManager for loading classes!</b> This is necessary to
             avoid strange match errors and inequalities which arise from different class loaders loading
             the same class.
             </summary>
        </member>
        <member name="F:Akka.Serialization.Serializer.system">
            <summary>
            The actor system to associate with this serializer.
            </summary>
        </member>
        <member name="M:Akka.Serialization.Serializer.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Serialization.Serializer" /> class.
            </summary>
            <param name="system">The actor system to associate with this serializer. </param>
        </member>
        <member name="P:Akka.Serialization.Serializer.Identifier">
            <summary>
            Completely unique value to identify this implementation of Serializer, used to optimize network traffic
            Values from 0 to 16 is reserved for Akka internal usage
            </summary>
        </member>
        <member name="P:Akka.Serialization.Serializer.IncludeManifest">
            <summary>
            Returns whether this serializer needs a manifest in the fromBinary method
            </summary>
        </member>
        <member name="M:Akka.Serialization.Serializer.ToBinary(System.Object)">
            <summary>
            Serializes the given object into a byte array
            </summary>
            <param name="obj">The object to serialize </param>
            <returns>A byte array containing the serialized object</returns>
        </member>
        <member name="M:Akka.Serialization.Serializer.ToBinaryWithAddress(Akka.Actor.Address,System.Object)">
            <summary>
            Serializes the given object into a byte array and uses the given address to decorate serialized ActorRef's
            </summary>
            <param name="address">The address to use when serializing local ActorRefs</param>
            <param name="obj">The object to serialize</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Serialization.Serializer.FromBinary(System.Byte[],System.Type)">
            <summary>
            Deserializes a byte array into an object of type <paramref name="type"/>.
            </summary>
            <param name="bytes">The array containing the serialized object</param>
            <param name="type">The type of object contained in the array</param>
            <returns>The object contained in the array</returns>
        </member>
        <member name="M:Akka.Serialization.Serializer.FromBinary``1(System.Byte[])">
            <summary>
            Deserializes a byte array into an object.
            </summary>
            <param name="bytes">The array containing the serialized object</param>
            <returns>The object contained in the array</returns>
        </member>
        <member name="T:Akka.Serialization.SerializerWithStringManifest">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Serialization.SerializerWithStringManifest.#ctor(Akka.Actor.ExtendedActorSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Serialization.SerializerWithStringManifest"/> class.
            </summary>
            <param name="system">The actor system to associate with this serializer.</param>
        </member>
        <member name="P:Akka.Serialization.SerializerWithStringManifest.IncludeManifest">
            <summary>
            Returns whether this serializer needs a manifest in the fromBinary method
            </summary>
        </member>
        <member name="M:Akka.Serialization.SerializerWithStringManifest.FromBinary(System.Byte[],System.Type)">
            <summary>
            Deserializes a byte array into an object of type <paramref name="type" />.
            </summary>
            <param name="bytes">The array containing the serialized object</param>
            <param name="type">The type of object contained in the array</param>
            <returns>The object contained in the array</returns>
        </member>
        <member name="M:Akka.Serialization.SerializerWithStringManifest.FromBinary(System.Byte[],System.String)">
            <summary>
            Deserializes a byte array into an object using an optional <paramref name="manifest"/> (type hint).
            </summary>
            <param name="bytes">The array containing the serialized object</param>
            <param name="manifest">The type hint used to deserialize the object contained in the array.</param>
            <returns>The object contained in the array</returns>
        </member>
        <member name="M:Akka.Serialization.SerializerWithStringManifest.Manifest(System.Object)">
            <summary>
            Returns the manifest (type hint) that will be provided in the <see cref="M:Akka.Serialization.SerializerWithStringManifest.FromBinary(System.Byte[],System.Type)"/> method.
            
            <note>
            This method returns <see cref="F:System.String.Empty"/> if a manifest is not needed.
            </note>
            </summary>
            <param name="o">The object for which the manifest is needed.</param>
            <returns>The manifest needed for the deserialization of the specified <paramref name="o"/>.</returns>
        </member>
        <member name="T:Akka.Serialization.SerializerIdentifierHelper">
            <summary>
            INTERNAL API.
            </summary>
        </member>
        <member name="F:Akka.Serialization.SerializerIdentifierHelper.SerializationIdentifiers">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Serialization.SerializerIdentifierHelper.GetSerializerIdentifierFromConfig(System.Type,Akka.Actor.ExtendedActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="type">TBD</param>
            <param name="system">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the system couldn't find the given serializer <paramref name="type"/> id in the configuration.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.AtomicBoolean">
            <summary>
            Implementation of the java.concurrent.util.AtomicBoolean type.
            
            Uses <see cref="M:System.Threading.Interlocked.MemoryBarrier"/> internally to enforce ordering of writes
            without any explicit locking. .NET's strong memory on write guarantees might already enforce
            this ordering, but the addition of the MemoryBarrier guarantees it.
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicBoolean.#ctor(System.Boolean)">
            <summary>
            Sets the initial value of this <see cref="T:Akka.Util.AtomicBoolean"/> to <paramref name="initialValue"/>.
            </summary>
            <param name="initialValue">TBD</param>
        </member>
        <member name="P:Akka.Util.AtomicBoolean.Value">
            <summary>
            The current value of this <see cref="T:Akka.Util.AtomicReference`1"/>
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicBoolean.CompareAndSet(System.Boolean,System.Boolean)">
            <summary>
            If <see cref="P:Akka.Util.AtomicBoolean.Value"/> equals <paramref name="expected"/>, then set the Value to
            <paramref name="newValue"/>.
            </summary>
            <param name="expected">TBD</param>
            <param name="newValue">TBD</param>
            <returns><c>true</c> if <paramref name="newValue"/> was set</returns>
        </member>
        <member name="M:Akka.Util.AtomicBoolean.GetAndSet(System.Boolean)">
            <summary>
            Atomically sets the <see cref="P:Akka.Util.AtomicBoolean.Value"/> to <paramref name="newValue"/> and returns the old <see cref="P:Akka.Util.AtomicBoolean.Value"/>.
            </summary>
            <param name="newValue">The new value</param>
            <returns>The old value</returns>
        </member>
        <member name="M:Akka.Util.AtomicBoolean.op_Implicit(Akka.Util.AtomicBoolean)~System.Boolean">
            <summary>
            Performs an implicit conversion from <see cref="T:Akka.Util.AtomicBoolean"/> to <see cref="T:System.Boolean"/>.
            </summary>
            <param name="atomicBoolean">The boolean to convert</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Akka.Util.AtomicBoolean.op_Implicit(System.Boolean)~Akka.Util.AtomicBoolean">
            <summary>
            Performs an implicit conversion from <see cref="T:System.Boolean"/> to <see cref="T:Akka.Util.AtomicBoolean"/>.
            </summary>
            <param name="value">The boolean to convert</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="T:Akka.Util.AtomicReference`1">
            <summary>
            Implementation of the java.concurrent.util AtomicReference type.
            
            Uses <see cref="T:System.Threading.Volatile"/> internally to enforce ordering of writes
            without any explicit locking. .NET's strong memory on write guarantees might already enforce
            this ordering, but the addition of the Volatile guarantees it.
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.#ctor(`0)">
            <summary>
            Sets the initial value of this <see cref="T:Akka.Util.AtomicReference`1"/> to <paramref name="originalValue"/>.
            </summary>
            <param name="originalValue">TBD</param>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="F:Akka.Util.AtomicReference`1.atomicValue">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.AtomicReference`1.Value">
            <summary>
            The current value of this <see cref="T:Akka.Util.AtomicReference`1"/>
            </summary>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.CompareAndSet(`0,`0)">
            <summary>
            If <see cref="P:Akka.Util.AtomicReference`1.Value"/> equals <paramref name="expected"/>, then set the Value to
            <paramref name="newValue"/>.
            </summary>
            <param name="expected">TBD</param>
            <param name="newValue">TBD</param>
            <returns><c>true</c> if <paramref name="newValue"/> was set</returns>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.GetAndSet(`0)">
            <summary>
            Atomically sets the <see cref="P:Akka.Util.AtomicReference`1.Value"/> to <paramref name="newValue"/> and returns the old <see cref="P:Akka.Util.AtomicReference`1.Value"/>.
            </summary>
            <param name="newValue">The new value</param>
            <returns>The old value</returns>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.op_Implicit(Akka.Util.AtomicReference{`0})~`0">
            <summary>
            Performs an implicit conversion from <see cref="T:Akka.Util.AtomicReference`1"/> to <see cref="!:T"/>.
            </summary>
            <param name="atomicReference">The reference to convert</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Akka.Util.AtomicReference`1.op_Implicit(`0)~Akka.Util.AtomicReference{`0}">
            <summary>
            Performs an implicit conversion from <see cref="!:T"/> to <see cref="T:Akka.Util.AtomicReference`1"/>.
            </summary>
            <param name="value">The reference to convert</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="T:Akka.Util.Base64Encoding">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Util.Base64Encoding.Base64Chars">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Base64Encoding.Base64Encode(System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Base64Encoding.Base64Encode(System.String)">
            <summary>
            TBD
            </summary>
            <param name="s">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.ByteIterator">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Util.ByteIterator.ByteArrayIterator">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.ByteIterator.ByteArrayIterator.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="array">TBD</param>
            <param name="from">TBD</param>
            <param name="until">TBD</param>
        </member>
        <member name="P:Akka.Util.ByteIterator.ByteArrayIterator.Len">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.ByteIterator.ByteArrayIterator.HasNext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.ByteIterator.ByteArrayIterator.Head">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.ByteIterator.ByteArrayIterator.Next">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.IndexOutOfRangeException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.ByteArrayIterator.Clear">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.ByteIterator.ByteArrayIterator.Length">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.ByteArrayIterator.Clone">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.ByteArrayIterator.Take(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.ByteArrayIterator.Drop(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.ByteArrayIterator.TakeWhile(System.Func{System.Byte,System.Boolean})">
            <summary>
            TBD
            </summary>
            <param name="p">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.ByteArrayIterator.DropWhile(System.Func{System.Byte,System.Boolean})">
            <summary>
            TBD
            </summary>
            <param name="p">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.ByteArrayIterator.CopToArray(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="xs">TBD</param>
            <param name="start">TBD</param>
            <param name="len">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.ByteArrayIterator.ToByteString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.ByteArrayIterator.GetBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="xs">TBD</param>
            <param name="offset">TBD</param>
            <param name="n">TBD</param>
            <exception cref="T:System.IndexOutOfRangeException">TBD</exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.ByteArrayIterator.ToArray">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.ByteArrayIterator.CopyToBuffer(Akka.IO.ByteBuffer)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.ByteIterator.MultiByteIterator">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.ByteIterator.MultiByteIterator.#ctor(Akka.Util.ByteIterator.ByteArrayIterator[])">
            <summary>
            TBD
            </summary>
            <param name="iterators">TBD</param>
        </member>
        <member name="M:Akka.Util.ByteIterator.MultiByteIterator.#ctor(Akka.Util.ILinearSeq{Akka.Util.ByteIterator.ByteArrayIterator})">
            <summary>
            TBD
            </summary>
            <param name="iterators">TBD</param>
        </member>
        <member name="M:Akka.Util.ByteIterator.MultiByteIterator.Clear">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.ByteIterator.MultiByteIterator.HasNext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.ByteIterator.MultiByteIterator.Head">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.ByteIterator.MultiByteIterator.Next">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.ByteIterator.MultiByteIterator.Len">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.ByteIterator.MultiByteIterator.Take(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.MultiByteIterator.Drop(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.MultiByteIterator.TakeWhile(System.Func{System.Byte,System.Boolean})">
            <summary>
            TBD
            </summary>
            <param name="p">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.MultiByteIterator.DropWhile(System.Func{System.Byte,System.Boolean})">
            <summary>
            TBD
            </summary>
            <param name="p">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.MultiByteIterator.ToByteString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.MultiByteIterator.GetToArray``1(``0[],System.Int32,System.Int32,System.Int32,System.Func{``0},System.Action{``0[],System.Int32,System.Int32})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="xs">TBD</param>
            <param name="offset">TBD</param>
            <param name="n">TBD</param>
            <param name="elemSize">TBD</param>
            <param name="getSingle">TBD</param>
            <param name="getMulti">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.MultiByteIterator.GetBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="xs">TBD</param>
            <param name="offset">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.MultiByteIterator.ToArray">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.MultiByteIterator.CopyToBuffer(Akka.IO.ByteBuffer)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Util.ByteIterator.Len">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.ByteIterator.HasNext">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.ByteIterator.Head">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.ByteIterator.Next">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.Clear">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.ByteIterator.Clone">
            <summary>
            N/A
            </summary>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.Duplicate">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.Take(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.Drop(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.Slice(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="from">TBD</param>
            <param name="until">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.TakeWhile(System.Func{System.Byte,System.Boolean})">
            <summary>
            N/A
            </summary>
            <param name="p">N/A</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.DropWhile(System.Func{System.Byte,System.Boolean})">
            <summary>
            N/A
            </summary>
            <param name="p">N/A</param>
            <exception cref="T:System.NotSupportedException">TBD</exception>
            <returns>N/A</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.Span(System.Func{System.Byte,System.Boolean})">
            <summary>
            TBD
            </summary>
            <param name="p">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.IndexWhere(System.Func{System.Byte,System.Boolean})">
            <summary>
            TBD
            </summary>
            <param name="p">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.IndexOf(System.Byte)">
            <summary>
            TBD
            </summary>
            <param name="elem">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.ToByteString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.ForEach(System.Action{System.Byte})">
            <summary>
            TBD
            </summary>
            <param name="f">TBD</param>
        </member>
        <member name="M:Akka.Util.ByteIterator.FoldLeft``1(``0,System.Func{``0,System.Byte,``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="z">TBD</param>
            <param name="op">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.ToArray">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.GetByte">
            <summary>
            Get a single Byte from this iterator. Identical to next().
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.GetShort(Akka.IO.ByteOrder)">
            <summary>
            Get a single Short from this iterator.
            </summary>
            <param name="byteOrder">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.GetInt(Akka.IO.ByteOrder)">
            <summary>
            Get a single Int from this iterator.
            </summary>
            <param name="byteOrder">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.GetLong(Akka.IO.ByteOrder)">
            <summary>
            Get a single Long from this iterator.
            </summary>
            <param name="byteOrder">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.GetBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="xs">TBD</param>
            <param name="offset">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.GetBytes(System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ByteIterator.CopyToBuffer(Akka.IO.ByteBuffer)">
            <summary>
            TBD
            </summary>
            <param name="buffer">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.ILinearSeq`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="P:Akka.Util.ILinearSeq`1.IsEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.ILinearSeq`1.Head">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.ILinearSeq`1.Tail">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.ArrayLinearSeq`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Util.ArrayLinearSeq`1.#ctor(`0[])">
            <summary>
            TBD
            </summary>
            <param name="array">TBD</param>
        </member>
        <member name="P:Akka.Util.ArrayLinearSeq`1.IsEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.ArrayLinearSeq`1.Head">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.ArrayLinearSeq`1.Tail">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ArrayLinearSeq`1.GetEnumerator">
            <summary>
            Retrieves an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Akka.Util.ArrayLinearSeq`1.op_Implicit(`0[])~Akka.Util.ArrayLinearSeq{`0}">
            <summary>
            Performs an implicit conversion from <see cref="!:T[]"/> to <see cref="T:Akka.Util.ArrayLinearSeq`1"/>.
            </summary>
            <param name="value">The array to convert</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="T:Akka.Util.ConcurrentSet`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Util.ConcurrentSet`1.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.ConcurrentSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            TBD
            </summary>
            <param name="collection">TBD</param>
        </member>
        <member name="M:Akka.Util.ConcurrentSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            TBD
            </summary>
            <param name="comparer">TBD</param>
        </member>
        <member name="M:Akka.Util.ConcurrentSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            TBD
            </summary>
            <param name="collection">TBD</param>
            <param name="comparer">TBD</param>
        </member>
        <member name="M:Akka.Util.ConcurrentSet`1.#ctor(System.Int32,System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="concurrencyLevel">TBD</param>
            <param name="capacity">TBD</param>
        </member>
        <member name="M:Akka.Util.ConcurrentSet`1.#ctor(System.Int32,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            TBD
            </summary>
            <param name="concurrencyLevel">TBD</param>
            <param name="collection">TBD</param>
            <param name="comparer">TBD</param>
        </member>
        <member name="M:Akka.Util.ConcurrentSet`1.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            TBD
            </summary>
            <param name="concurrencyLevel">TBD</param>
            <param name="capacity">TBD</param>
            <param name="comparer">TBD</param>
        </member>
        <member name="P:Akka.Util.ConcurrentSet`1.IsEmpty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.ConcurrentSet`1.Count">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.ConcurrentSet`1.Clear">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.ConcurrentSet`1.Contains(`0)">
            <summary>
            TBD
            </summary>
            <param name="item">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ConcurrentSet`1.TryAdd(`0)">
            <summary>
            TBD
            </summary>
            <param name="item">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.ConcurrentSet`1.TryRemove(`0)">
            <summary>
            TBD
            </summary>
            <param name="item">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.ContinuousEnumerator`1">
            <summary>
            Implements a circular <see cref="T:System.Collections.Generic.IEnumerator`1"/> around an existing <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            
            This allows for continuous read-only iteration over a set.
            </summary>
            <typeparam name="T">The type of objects to enumerate</typeparam>
        </member>
        <member name="M:Akka.Util.ContinuousEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Util.ContinuousEnumerator`1"/> class.
            </summary>
            <param name="internalEnumerator">The raw iterator from some <see cref="T:System.Collections.Generic.IEnumerable`1"/> object</param>
        </member>
        <member name="M:Akka.Util.ContinuousEnumerator`1.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Util.ContinuousEnumerator`1.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Akka.Util.ContinuousEnumerator`1.Reset">
            <inheritdoc/>
        </member>
        <member name="P:Akka.Util.ContinuousEnumerator`1.Current">
            <inheritdoc/>
        </member>
        <member name="T:Akka.Util.ContinuousEnumeratorExtensions">
            <summary>
            Extension method class for adding <see cref="T:Akka.Util.ContinuousEnumerator`1"/> support to any <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            instance within Akka.NET
            </summary>
        </member>
        <member name="M:Akka.Util.ContinuousEnumeratorExtensions.GetContinuousEnumerator``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Provides a <see cref="T:Akka.Util.ContinuousEnumerator`1"/> instance for <paramref name="collection"/>.
            
            Internally, it just wraps <paramref name="collection"/>'s internal iterator with circular iteration behavior.
            </summary>
            <param name="collection">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Either`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TA">TBD</typeparam>
            <typeparam name="TB">TBD</typeparam>
        </member>
        <member name="M:Akka.Util.Either`2.#ctor(`0,`1)">
            <summary>
            TBD
            </summary>
            <param name="left">TBD</param>
            <param name="right">TBD</param>
        </member>
        <member name="P:Akka.Util.Either`2.IsLeft">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Either`2.IsRight">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Either`2.Right">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Either`2.Left">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Either`2.Value">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Either`2.ToRight">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Either`2.ToLeft">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Either`2.op_Implicit(Akka.Util.Left{`0})~Akka.Util.Either{`0,`1}">
            <summary>
            Performs an implicit conversion from <see cref="T:Akka.Util.Left`1"/> to <see cref="T:Akka.Util.Either`2"/>.
            </summary>
            <param name="left">The object to convert</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Akka.Util.Either`2.op_Implicit(Akka.Util.Right{`1})~Akka.Util.Either{`0,`1}">
            <summary>
            Performs an implicit conversion from <see cref="T:Akka.Util.Right`1"/> to <see cref="T:Akka.Util.Either`2"/>.
            </summary>
            <param name="right">The object to convert</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Akka.Util.Either`2.Map``2(System.Func{`0,``0},System.Func{`1,``1})">
            <summary>
            TBD
            </summary>
            <typeparam name="TRes1">TBD</typeparam>
            <typeparam name="TRes2">TBD</typeparam>
            <param name="map1">TBD</param>
            <param name="map2">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Either`2.MapLeft``1(System.Func{`0,``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TRes">TBD</typeparam>
            <param name="map">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Either`2.MapRight``1(System.Func{`1,``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TRes">TBD</typeparam>
            <param name="map">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Either`2.Fold``1(System.Func{`0,``0},System.Func{`1,``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TRes">TBD</typeparam>
            <param name="left">TBD</param>
            <param name="right">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Either">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Either.Left``1(``0)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Either.Right``1(``0)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Right`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TA">TBD</typeparam>
            <typeparam name="TB">TBD</typeparam>
        </member>
        <member name="M:Akka.Util.Right`2.#ctor(`1)">
            <summary>
            TBD
            </summary>
            <param name="b">TBD</param>
        </member>
        <member name="P:Akka.Util.Right`2.IsLeft">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Right`2.IsRight">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Right`2.Value">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Util.Right`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Util.Right`1.#ctor(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
        </member>
        <member name="P:Akka.Util.Right`1.Value">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Right`1.IsLeft">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Right`1.IsRight">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Util.Left`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TA">TBD</typeparam>
            <typeparam name="TB">TBD</typeparam>
        </member>
        <member name="M:Akka.Util.Left`2.#ctor(`0)">
            <summary>
            TBD
            </summary>
            <param name="a">TBD</param>
        </member>
        <member name="P:Akka.Util.Left`2.IsLeft">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Left`2.IsRight">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Left`2.Value">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Util.Left`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Util.Left`1.#ctor(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
        </member>
        <member name="P:Akka.Util.Left`1.Value">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Left`1.IsLeft">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Left`1.IsRight">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Util.FastLazy`1">
            <summary>
            A fast, atomic lazy that only allows a single publish operation to happen,
            but allows executions to occur concurrently.
            
            Does not cache exceptions. Designed for use with <typeparamref name="T"/> types that are <see cref="T:System.IDisposable"/>
            or are otherwise considered to be expensive to allocate. 
            
            Read the full explanation here: https://github.com/Aaronontheweb/FastAtomicLazy#rationale
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Util.FastLazy`1.#ctor(System.Func{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Util.FastLazy`1"/> class.
            </summary>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if the given <paramref name="producer"/> is undefined.
            </exception>
        </member>
        <member name="P:Akka.Util.FastLazy`1.IsValueCreated">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Util.FastLazy`1.Value">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Util.FastLazy`2">
            <summary>
            A fast, atomic lazy that only allows a single publish operation to happen,
            but allows executions to occur concurrently.
            
            Does not cache exceptions. Designed for use with <typeparamref name="T"/> types that are <see cref="T:System.IDisposable"/>
            or are otherwise considered to be expensive to allocate. 
            
            Read the full explanation here: https://github.com/Aaronontheweb/FastAtomicLazy#rationale
            </summary>
            <typeparam name="S">State type</typeparam>
            <typeparam name="T">Value type</typeparam>
        </member>
        <member name="M:Akka.Util.FastLazy`2.#ctor(System.Func{`0,`1},`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Util.FastLazy`1"/> class.
            </summary>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if the given <paramref name="producer"/> or <paramref name="state"/> is undefined.
            </exception>
        </member>
        <member name="P:Akka.Util.FastLazy`2.IsValueCreated">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Util.FastLazy`2.Value">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Util.Index`2">
            <summary>
            An implementation of a ConcurrentMultiMap - in CLR that would be something like
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> where <c>TValue</c> is another <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            
            Add/remove is serialized over the specified key.
            Reads are fully concurrent.
            </summary>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TValue">TBD</typeparam>
        </member>
        <member name="M:Akka.Util.Index`2.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Index`2.Put(`0,`1)">
            <summary>
            Associates the value of <typeparamref name="TValue"/> with key of type <typeparamref name="TKey"/>.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
            <returns><c>true</c> if the value didn't exist for the key previously, and <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Util.Index`2.FindValue(`0,System.Func{`1,System.Boolean})">
            <summary>
            Find some <typeparamref name="TValue"/> for the first matching value where the supplied
            <paramref name="predicate"/> returns <c>true</c> for the given key.
             </summary>
            <param name="key">The key to use.</param>
            <param name="predicate">The predicate to filter values associated with <paramref name="key"/>.</param>
            <returns>The first <typeparamref name="TValue"/> matching <paramref name="predicate"/>. <c>default(TValue)</c> otherwise.</returns>
        </member>
        <member name="P:Akka.Util.Index`2.Item(`0)">
            <summary>
            TBD
            </summary>
            <param name="index">TBD</param>
        </member>
        <member name="M:Akka.Util.Index`2.ForEach(System.Action{`0,`1})">
            <summary>
            Applies the supplied <paramref name="fun"/> to all keys and their values.
            </summary>
            <param name="fun">The function to apply.</param>
        </member>
        <member name="P:Akka.Util.Index`2.Values">
            <summary>
            Returns the union of all value sets. 
            </summary>
        </member>
        <member name="P:Akka.Util.Index`2.Keys">
            <summary>
            Returns the key set.
            </summary>
        </member>
        <member name="M:Akka.Util.Index`2.Remove(`0,`1)">
            <summary>
            Disassociates the value of <typeparamref name="TValue"/> from
            the key of <typeparamref name="TKey"/>.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns><c>true</c> if <paramref name="value"/> was removed. <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Util.Index`2.RemoveValue(`1)">
            <summary>
            Remove the given <paramref name="value"/> from all keys.
            </summary>
            <param name="value">The value we're going to remove, if it exists for any key.</param>
        </member>
        <member name="M:Akka.Util.Index`2.Remove(`0)">
            <summary>
            Disassociates all values for the specified key.
            </summary>
            <param name="key">The key we're going to remove.</param>
            <returns>An enumerable collection of <typeparamref name="TValue"/> if the key exists. An empty collection otherwise.</returns>
        </member>
        <member name="P:Akka.Util.Index`2.IsEmpty">
            <summary>
            Returns <c>true</c> if the index is empty.
            </summary>
        </member>
        <member name="M:Akka.Util.Index`2.Clear">
            <summary>
            Removes all keys and values
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.ArrayExtensions">
            <summary>
            Provides extension utilities to arrays.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.IsNullOrEmpty(System.Array)">
            <summary>
            Determines if an array is null or empty.
            </summary>
            <param name="obj">The array to check.</param>
            <returns>True if null or empty, false otherwise.</returns>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.NonEmpty(System.Array)">
            <summary>
            Determines if an array is not null or empty.
            </summary>
            <param name="obj">The array to check.</param>
            <returns>True if not null or empty, false otherwise.</returns>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.Shuffle``1(``0[])">
            <summary>
            Shuffles an array of objects.
            </summary>
            <typeparam name="T">The type of the array to sort.</typeparam>
            <param name="array">The array to sort.</param>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.ZipWithIndex``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Implementation of Scala's ZipWithIndex method.
            
            Folds a collection into a Dictionary where the original value (of type T) acts as the key
            and the index of the item in the array acts as the value.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="collection">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.Slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            Grabs a subset of an IEnumerable based on a starting index and position
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="items">The array of items to slice</param>
            <param name="startIndex">The starting position to begin the slice</param>
            <param name="count">The number of items to take</param>
            <returns>A slice of size <paramref name="count"/> beginning from position <sparamref name="startIndex"/> in <paramref name="items"/>.</returns>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.From``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Select all the items in this array beginning with <paramref name="startingItem"/> and up until the end of the array.
            
            <note>
            If <paramref name="startingItem"/> is not found in the array, From will return an empty set.
            If <paramref name="startingItem"/> is found at the end of the array, From will return the entire original array.
            </note>
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="items">TBD</param>
            <param name="startingItem">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.Until``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Select all the items in this array from the beginning until (but not including) <paramref name="startingItem"/>
            <note>
            If <paramref name="startingItem"/> is not found in the array, Until will select all items.
            If <paramref name="startingItem"/> is the first item in the array, an empty array will be returned.
            </note>
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="items">TBD</param>
            <param name="startingItem">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.ArrayExtensions.Tail``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="items">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Internal.AtomicCounter">
            <summary>
            An atomic 32 bit integer counter.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.#ctor(System.Int32)">
            <summary>
            Creates an instance of an AtomicCounter.
            </summary>
            <param name="initialValue">The initial value of this counter.</param>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.#ctor">
            <summary>
            Creates an instance of an AtomicCounter with a starting value of -1.
            </summary>
        </member>
        <member name="F:Akka.Util.Internal.AtomicCounter._value">
            <summary>
            The current value of the atomic counter.
            </summary>
        </member>
        <member name="P:Akka.Util.Internal.AtomicCounter.Current">
            <summary>
            Retrieves the current value of the counter
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.Next">
            <summary>
            Increments the counter and returns the next value
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.Decrement">
            <summary>
            Decrements the counter and returns the next value
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.GetAndIncrement">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The original value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.IncrementAndGet">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The new value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.GetAndDecrement">
            <summary>
            Atomically decrements the counter by one.
            </summary>
            <returns>The original value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.DecrementAndGet">
            <summary>
            Atomically decrements the counter by one.
            </summary>
            <returns>The new value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.GetAndAdd(System.Int32)">
            <summary>
            Returns the current value and adds the specified value to the counter.
            </summary>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The original value before additions.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.AddAndGet(System.Int32)">
            <summary>
            Adds the specified value to the counter and returns the new value.
            </summary>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The new value after additions.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.Reset">
            <summary>
            Resets the counter to zero.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.GetAndSet(System.Int32)">
            <summary>
            Returns current counter value and sets a new value on it's place in one operation.
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounter.CompareAndSet(System.Int32,System.Int32)">
            <summary>
            Compares current counter value with provided <paramref name="expected"/> value,
            and sets it to <paramref name="newValue"/> if compared values where equal.
            Returns true if replacement has succeed.
            </summary>
            <param name="expected">TBD</param>
            <param name="newValue">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Internal.AtomicCounterLong">
            <summary>
            An atomic 64 bit integer counter.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.#ctor(System.Int64)">
            <summary>
            Creates an instance of an AtomicCounterLong.
            </summary>
            <param name="value">The initial value of this counter.</param>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.#ctor">
            <summary>
            Creates an instance of an AtomicCounterLong with a starting value of -1.
            </summary>
        </member>
        <member name="F:Akka.Util.Internal.AtomicCounterLong._value">
            <summary>
            The current value for this counter.
            </summary>
        </member>
        <member name="P:Akka.Util.Internal.AtomicCounterLong.Current">
            <summary>
            Retrieves the current value of the counter
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.Next">
            <summary>
            Increments the counter and returns the next value.
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.GetAndIncrement">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The original value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.IncrementAndGet">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The new value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.DecrementAndGet">
            <summary>
            Atomically decrements the counter by one
            </summary>
            <returns>The new value</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.GetAndAdd(System.Int64)">
            <summary>
            Gets the current value of the counter and adds an amount to it.
            </summary>
            <remarks>This uses a CAS loop as Interlocked.Increment is not atomic for longs on 32bit systems.</remarks>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The original value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.AddAndGet(System.Int64)">
            <summary>
            Adds an amount to the counter and returns the new value.
            </summary>
            <remarks>This uses a CAS loop as Interlocked.Increment is not atomic for longs on 32bit systems.</remarks>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The new counter value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.Reset">
            <summary>
            Resets the counter to zero.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.GetAndSet(System.Int64)">
            <summary>
            Returns current counter value and sets a new value on it's place in one operation.
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.CompareAndSet(System.Int64,System.Int64)">
            <summary>
            Compares current counter value with provided <paramref name="expected"/> value,
            and sets it to <paramref name="newValue"/> if compared values where equal.
            Returns true if replacement has succeed.
            </summary>
            <param name="expected">TBD</param>
            <param name="newValue">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicCounterLong.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Internal.AtomicState">
            <summary>
            Internal state abstraction
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.#ctor(System.TimeSpan,System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="callTimeout">TBD</param>
            <param name="startingCount">TBD</param>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.AddListener(System.Action)">
            <summary>
            Add a listener function which is invoked on state entry
            </summary>
            <param name="listener">listener implementation</param>
        </member>
        <member name="P:Akka.Util.Internal.AtomicState.HasListeners">
            <summary>
            Test for whether listeners exist
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.NotifyTransitionListeners">
            <summary>
            Notifies the listeners of the transition event via a 
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.CallThrough``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Shared implementation of call across all states.  Thrown exception or execution of the call beyond the allowed
            call timeout is counted as a failed call, otherwise a successful call
            
            NOTE: In .Net there is no way to cancel an uncancellable task. We are merely cancelling the wait and marking this
            as a failure.
            
            see http://blogs.msdn.com/b/pfxteam/archive/2011/11/10/10235834.aspx 
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="task">Implementation of the call</param>
            <returns>result of the call</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.CallThrough(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Shared implementation of call across all states.  Thrown exception or execution of the call beyond the allowed
            call timeout is counted as a failed call, otherwise a successful call
            
            NOTE: In .Net there is no way to cancel an uncancellable task. We are merely cancelling the wait and marking this
            as a failure.
            
            see http://blogs.msdn.com/b/pfxteam/archive/2011/11/10/10235834.aspx 
            </summary>
            <param name="task"><see cref="T:System.Threading.Tasks.Task"/> Implementation of the call</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/></returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.Invoke``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Abstract entry point for all states
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="body">Implementation of the call that needs protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing result of protected call</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.Invoke(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Abstract entry point for all states
            </summary>
            <param name="body">Implementation of the call that needs protected</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> containing result of protected call</returns>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.CallFails">
            <summary>
            Invoked when call fails
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.CallSucceeds">
            <summary>
            Invoked when call succeeds
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.EnterInternal">
            <summary>
            Invoked on the transitioned-to state during transition. Notifies listeners after invoking subclass template method _enter
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.AtomicState.Enter">
            <summary>
            Enter the state. NotifyTransitionListeners is not awaited -- its "fire and forget". 
            It is up to the user to handle any errors that occur in this state.
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.IAtomicState">
            <summary>
            This interface represents the parts of the internal circuit breaker state; the behavior stack, watched by, watching and termination queue
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicState.AddListener(System.Action)">
            <summary>
            TBD
            </summary>
            <param name="listener">TBD</param>
        </member>
        <member name="P:Akka.Util.Internal.IAtomicState.HasListeners">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicState.Invoke``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="body">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicState.Enter">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.Collections.EnumeratorExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.Collections.EnumeratorExtensions.Iterator``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="enumerable">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Internal.Collections.IBinaryTreeNode`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TValue">TBD</typeparam>
        </member>
        <member name="P:Akka.Util.Internal.Collections.IBinaryTreeNode`2.Left">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Internal.Collections.IBinaryTreeNode`2.Right">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.Collections.IKeyValuePair`2">
            <summary>
            TBD
            </summary>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TValue">TBD</typeparam>
        </member>
        <member name="P:Akka.Util.Internal.Collections.IKeyValuePair`2.Key">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Internal.Collections.IKeyValuePair`2.Value">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.Collections.Iterator`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Util.Internal.Collections.Iterator`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            TBD
            </summary>
            <param name="enumerator">TBD</param>
        </member>
        <member name="M:Akka.Util.Internal.Collections.Iterator`1.Next">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.Collections.Iterator`1.IsEmpty">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.Collections.Iterator`1.ToVector">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Internal.DictionaryExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.DictionaryExtensions.Put``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            TBD
            </summary>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TVal">TBD</typeparam>
            <param name="dict">TBD</param>
            <param name="key">TBD</param>
            <param name="value">TBD</param>
        </member>
        <member name="M:Akka.Util.Internal.DictionaryExtensions.TryAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            TBD
            </summary>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TVal">TBD</typeparam>
            <param name="dict">TBD</param>
            <param name="key">TBD</param>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Internal.Extensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.AsInstanceOf``1(System.Object)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="self">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.Drop``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Scala alias for Skip
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="self">TBD</param>
            <param name="count">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.Head``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Scala alias for FirstOrDefault
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="self">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.SplitDottedPathHonouringQuotes(System.String)">
            <summary>
            Splits a 'dotted path' in its elements, honouring quotes (not splitting by dots between quotes)
            </summary>
            <param name="path">The input path</param>
            <returns>The path elements</returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.Join(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <param name="separator">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.BetweenDoubleQuotes(System.String)">
            <summary>
            TBD
            </summary>
            <param name="self">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.AddOrSet``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Dictionary helper that allows for idempotent updates. You don't need to care whether or not
            this item is already in the collection in order to update it.
            </summary>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TValue">TBD</typeparam>
            <param name="hash">TBD</param>
            <param name="key">TBD</param>
            <param name="value">TBD</param>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.GetOrElse``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            TBD
            </summary>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TValue">TBD</typeparam>
            <param name="hash">TBD</param>
            <param name="key">TBD</param>
            <param name="elseValue">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.GetOrElse``1(``0,``0)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="obj">TBD</param>
            <param name="elseValue">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.AddAndReturn``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            TBD
            </summary>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TValue">TBD</typeparam>
            <param name="hash">TBD</param>
            <param name="key">TBD</param>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.Max(System.TimeSpan,System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="this">TBD</param>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.Min(System.TimeSpan,System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="this">TBD</param>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.Concat``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="enumerable">TBD</param>
            <param name="item">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Applies a delegate <paramref name="action" /> to all elements of this enumerable.
            </summary>
            <typeparam name="T">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to iterate.</param>
            <param name="action">The function that is applied for its side-effect to every element. The result of function <paramref name="action" /> is discarded.</param>
        </member>
        <member name="M:Akka.Util.Internal.Extensions.TakeRight``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Selects last n elements.
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="self">TBD</param>
            <param name="n">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Internal.IAtomicCounter`1">
            <summary>
            An interface that describes a numeric counter.
            </summary>
            <typeparam name="T">The type of the numeric.</typeparam>
        </member>
        <member name="P:Akka.Util.Internal.IAtomicCounter`1.Current">
            <summary>
            The current value of this counter.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.Next">
            <summary>
            Increments the counter and gets the next value. This is exactly the same as calling <see cref="M:Akka.Util.Internal.IAtomicCounter`1.IncrementAndGet"/>.
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.GetAndIncrement">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The original value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.IncrementAndGet">
            <summary>
            Atomically increments the counter by one.
            </summary>
            <returns>The new value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.GetAndAdd(`0)">
            <summary>
            Returns the current value and adds the specified value to the counter.
            </summary>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The original value before additions.</returns>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.AddAndGet(`0)">
            <summary>
            Adds the specified value to the counter and returns the new value.
            </summary>
            <param name="amount">The amount to add to the counter.</param>
            <returns>The new value after additions.</returns>
        </member>
        <member name="M:Akka.Util.Internal.IAtomicCounter`1.Reset">
            <summary>
            Resets the counter to zero.
            </summary>
        </member>
        <member name="T:Akka.Util.Internal.ImmutabilityUtils">
            <summary>
            Utility class for adding some basic immutable behaviors
            to specific types of collections without having to reference
            the entire BCL.Immutability NuGet package.
            
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.ImmutabilityUtils.CopyAndAdd``1(System.Collections.Generic.HashSet{``0},``0)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="set">TBD</param>
            <param name="item">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if the given <paramref name="set"/> is undefined.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.ImmutabilityUtils.CopyAndRemove``1(System.Collections.Generic.HashSet{``0},``0)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="set">TBD</param>
            <param name="item">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if the given <paramref name="set"/> is undefined.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.ImmutabilityUtils.CopyAndAdd``2(System.Collections.Generic.SortedDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            TBD
            </summary>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TValue">TBD</typeparam>
            <param name="dict">TBD</param>
            <param name="values">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.ImmutabilityUtils.CopyAndRemove``2(System.Collections.Generic.SortedDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            TBD
            </summary>
            <typeparam name="TKey">TBD</typeparam>
            <typeparam name="TValue">TBD</typeparam>
            <param name="dict">TBD</param>
            <param name="values">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Internal.InterlockedSpin">
            <summary>INTERNAL!
            Implements helpers for performing Compare-and-swap operations using <see cref="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)"/>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.InterlockedSpin.Swap``1(``0@,System.Func{``0,``0})">
            <summary>INTERNAL!
            Atomically updates the object <paramref name="reference"/> by calling <paramref name="updater"/> to get the new value.
            Note that <paramref name="updater"/> may be called many times so it should be idempotent.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="reference">TBD</param>
            <param name="updater">TBD</param>
            <returns>The updated value.</returns>
        </member>
        <member name="M:Akka.Util.Internal.InterlockedSpin.ConditionallySwap``2(``0@,System.Func{``0,System.Tuple{System.Boolean,``0,``1}})">
            <summary>INTERNAL!
            Atomically updates the int <paramref name="reference"/> by calling <paramref name="updateIfTrue"/> to get the new value.
            <paramref name="updateIfTrue"/> returns a Tuple&lt;should update, the new int value, the return value&gt;
            If the first item in the tuple is true, the value is updated, and the third value of the tuple is returned.
            Note that <paramref name="updateIfTrue"/> may be called many times so it should be idempotent.
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="TReturn">TBD</typeparam>
            <param name="reference">TBD</param>
            <param name="updateIfTrue">TBD</param>
            <returns>The third value from the tuple return by <paramref name="updateIfTrue"/>.</returns>
        </member>
        <member name="T:Akka.Util.Internal.StringBuilderExtensions">
            <summary>
            <remarks>Note! Part of internal API. Breaking changes may occur without notice. Use at own risk.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.StringBuilderExtensions.AppendJoin``1(System.Text.StringBuilder,System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="sb">TBD</param>
            <param name="separator">TBD</param>
            <param name="values">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.StringBuilderExtensions.AppendJoin``1(System.Text.StringBuilder,System.String,System.Collections.Generic.IEnumerable{``0},System.Action{System.Text.StringBuilder,``0,System.Int32})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="sb">TBD</param>
            <param name="separator">TBD</param>
            <param name="values">TBD</param>
            <param name="valueAppender">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Internal.TaskEx">
            <summary>
            INTERNAL API.
            
            Renamed from <see cref="T:Akka.Util.Internal.TaskExtensions"/> so it doesn't colide
            with a helper class in the same namespace defined in System.Threadin.Tasks.
            </summary>
        </member>
        <member name="F:Akka.Util.Internal.TaskEx.Completed">
            <summary>
            A completed task
            </summary>
        </member>
        <member name="M:Akka.Util.Internal.TaskEx.FromException(System.Exception)">
            <summary>
            Creates a failed <see cref="T:System.Threading.Tasks.Task"/>
            </summary>
            <param name="ex">The exception to use to fail the task.</param>
            <returns>A failed task.</returns>
        </member>
        <member name="M:Akka.Util.Internal.TaskEx.FromException``1(System.Exception)">
            <summary>
            Creates a failed <see cref="T:System.Threading.Tasks.Task"/>
            </summary>
            <param name="ex">The exception to use to fail the task.</param>
            <returns>A failed task.</returns>
            <typeparam name="T">The type of <see cref="T:System.Threading.Tasks.Task`1"/></typeparam>
        </member>
        <member name="T:Akka.Util.Internal.TaskExtensions">
             <summary>
             INTERNAL API
            
             Extensions for working with <see cref="T:System.Threading.Tasks.Task"/> types
             </summary>
        </member>
        <member name="M:Akka.Util.Internal.TaskExtensions.CastTask``2(System.Threading.Tasks.Task{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="TTask">TBD</typeparam>
            <typeparam name="TResult">TBD</typeparam>
            <param name="task">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Internal.TaskExtensions.WithCancellation(System.Threading.Tasks.Task,System.Threading.CancellationToken)">
            <summary>
            Returns the task which completes with result of original task if cancellation token not canceled it before completion.
            </summary>
            <param name="task">The original task.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The task which completes with result of original task or with cancelled state.</returns>
        </member>
        <member name="T:Akka.Util.ISurrogate">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.ISurrogate.FromSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.ISurrogated">
            <summary>
            Used for surrogate serialization.
            </summary>
        </member>
        <member name="M:Akka.Util.ISurrogated.ToSurrogate(Akka.Actor.ActorSystem)">
            <summary>
            TBD
            </summary>
            <param name="system">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.ListPriorityQueue">
            <summary>
            Priority queue implemented using a simple list with binary search for inserts.
            This specific implementation is cheap in terms of memory but weak in terms of performance.
            See http://visualstudiomagazine.com/articles/2012/11/01/priority-queues-with-c.aspx for original implementation
            This specific version is adapted for Envelopes only and calculates a priority of envelope.Message
            </summary>
        </member>
        <member name="F:Akka.Util.ListPriorityQueue.DefaultPriorityCalculator">
            <summary>
            The default priority generator.
            </summary>
        </member>
        <member name="M:Akka.Util.ListPriorityQueue.#ctor(System.Int32)">
            <summary>
            DEPRECATED. Should always specify priority calculator instead.
            </summary>
            <param name="initialCapacity">The current capacity of the priority queue.</param>
        </member>
        <member name="M:Akka.Util.ListPriorityQueue.#ctor(System.Int32,System.Func{System.Object,System.Int32})">
            <summary>
            Creates a new priority queue.
            </summary>
            <param name="initialCapacity">The initial capacity of the queue.</param>
            <param name="priorityCalculator">The calculator function for assigning message priorities.</param>
        </member>
        <member name="M:Akka.Util.ListPriorityQueue.SetPriorityCalculator(System.Func{System.Object,System.Int32})">
            <summary>
            DEPRECATED. Sets a new priority calculator.
            </summary>
            <param name="priorityCalculator">The calculator function for assigning message priorities.</param>
            <remarks>
            WARNING: SHOULD NOT BE USED. Use the constructor to set priority instead.
            </remarks>
        </member>
        <member name="M:Akka.Util.ListPriorityQueue.Enqueue(Akka.Actor.Envelope)">
            <summary>
            Enqueues a message into the priority queue.
            </summary>
            <param name="item">The item to enqueue.</param>
        </member>
        <member name="M:Akka.Util.ListPriorityQueue.Dequeue">
            <summary>
            Dequeues the highest priority message at the front of the priority queue.
            </summary>
            <returns>The highest priority message <see cref="T:Akka.Actor.Envelope"/>.</returns>
        </member>
        <member name="M:Akka.Util.ListPriorityQueue.Peek">
            <summary>
            Peek at the message at the front of the priority queue.
            </summary>
            <returns>The highest priority message <see cref="T:Akka.Actor.Envelope"/>.</returns>
        </member>
        <member name="M:Akka.Util.ListPriorityQueue.Count">
            <summary>
            Counts the number of items in the priority queue.
            </summary>
            <returns>The total number of items in the queue.</returns>
        </member>
        <member name="M:Akka.Util.ListPriorityQueue.ToString">
            <summary>
            Converts the queue to a string representation.
            </summary>
            <returns>A string representation of the queue.</returns>
        </member>
        <member name="M:Akka.Util.ListPriorityQueue.IsConsistent">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.MonotonicClock">
            <summary>
            INTERNAL API
            
            A Monotonic clock implementation based on total uptime.
            Used for keeping accurate time internally.
            </summary>
        </member>
        <member name="P:Akka.Util.MonotonicClock.Elapsed">
            <summary>
            Time as measured by the current system up-time.
            </summary>
        </member>
        <member name="P:Akka.Util.MonotonicClock.ElapsedHighRes">
            <summary>
            High resolution elapsed time as determined by a <see cref="F:Akka.Util.MonotonicClock.Stopwatch"/>
            running continuously in the background.
            </summary>
        </member>
        <member name="M:Akka.Util.MonotonicClock.GetMilliseconds">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.MonotonicClock.GetNanos">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.MonotonicClock.GetTicks">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.MonotonicClock.ToNanos(System.Int64)">
            <summary>
            Ticks represent 100 nanos. https://msdn.microsoft.com/en-us/library/system.datetime.ticks(v=vs.110).aspx
            
            This extension method converts a Ticks value to nano seconds.
            </summary>
            <param name="ticks">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.MonotonicClock.ToTicks(System.Int64)">
            <summary>
            Ticks represent 100 nanos. https://msdn.microsoft.com/en-us/library/system.datetime.ticks(v=vs.110).aspx
            
            This extension method converts a nano seconds value to Ticks.
            </summary>
            <param name="nanos">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.MurmurHash">
            <summary>
            Murmur3 Hash implementation
            </summary>
        </member>
        <member name="F:Akka.Util.MurmurHash.StoredMagicA">
            The first 23 magic integers from the first stream are stored here 
        </member>
        <member name="F:Akka.Util.MurmurHash.StoredMagicB">
            The first 23 magic integers from the second stream are stored here 
        </member>
        <member name="F:Akka.Util.MurmurHash.StartMagicA">
            <summary>
            The initial magic integer in the first stream.
            </summary>
        </member>
        <member name="F:Akka.Util.MurmurHash.StartMagicB">
            <summary>
            The initial magic integer in the second stream.
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.#cctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.MurmurHash.StartHash(System.UInt32)">
            <summary>
            Begin a new hash with a seed value.
            </summary>
            <param name="seed">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.NextMagicA(System.UInt32)">
            <summary>
            Given a magic integer from the first stream, compute the next
            </summary>
            <param name="magicA">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.NextMagicB(System.UInt32)">
            <summary>
            Given a magic integer from the second stream, compute the next
            </summary>
            <param name="magicB">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.ExtendHash(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Incorporates a new value into an existing hash
            </summary>
            <param name="hash">The prior hash value</param>
            <param name="value">The new value to incorporate</param>
            <param name="magicA">A magic integer from the left of the stream</param>
            <param name="magicB">A magic integer from a different stream</param>
            <returns>The updated hash value</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.FinalizeHash(System.UInt32)">
            <summary>
            Once all hashes have been incorporated, this performs a final mixing.
            </summary>
            <param name="hash">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.RotateLeft32(System.UInt32,System.Int32)">
            <summary>
            Rotate a 32-bit unsigned integer to the left by <paramref name="shift"/> bits
            </summary>
            <param name="original">Original value</param>
            <param name="shift">The shift value</param>
            <returns>The rotated 32-bit integer</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.RotateLeft64(System.UInt64,System.Int32)">
            <summary>
            Rotate a 64-bit unsigned integer to the left by <paramref name="shift"/> bits
            </summary>
            <param name="original">Original value</param>
            <param name="shift">The shift value</param>
            <returns>The rotated 64-bit integer</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.ByteHash(System.Byte[])">
            <summary>
            Compute a high-quality hash of a byte array
            </summary>
            <param name="b">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.ArrayHash``1(``0[])">
            <summary>
            Compute a high-quality hash of an array
            </summary>
            <param name="a">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.StringHash(System.String)">
            <summary>
            Compute high-quality hash of a string
            </summary>
            <param name="s">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.MurmurHash.SymmetricHash``1(System.Collections.Generic.IEnumerable{``0},System.UInt32)">
            <summary>
            Compute a hash that is symmetric in its arguments--that is,
            where the order of appearance of elements does not matter.
            This is useful for hashing sets, for example.
            </summary>
            <param name="xs">TBD</param>
            <param name="seed">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.BitArrayHelpers">
            <summary>
            Extension method class to make it easier to work with <see cref="T:System.Collections.BitArray"/> instances
            </summary>
        </member>
        <member name="M:Akka.Util.BitArrayHelpers.ToBytes(System.Collections.BitArray)">
            <summary>
            Converts a <see cref="T:System.Collections.BitArray"/> into an array of <see cref="T:System.Byte"/>
            </summary>
            <param name="arr">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if there aren't enough bits in the given <paramref name="arr"/> to make a byte.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Reflection.ExpressionExtensions">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Reflection.ExpressionExtensions.GetArguments(System.Linq.Expressions.NewExpression)">
            <summary>
            TBD
            </summary>
            <param name="newExpression">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Reflection.TypeCache">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Reflection.TypeCache.GetType(System.String)">
            <summary>
            Gets the <see cref="T:System.Type"/> with the specified name, performing a case-sensitive search and throw an exception if the type is not found.
            </summary>
            
            <returns>
            The type with the specified name. If the type is not found, an exception is thrown.
            </returns>
            <param name="typeName">
            The assembly-qualified name of the type to get. See <see cref="P:System.Type.AssemblyQualifiedName"/>.
            If the type is in Akka.dll or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.
            </param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.IResolver">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.IResolver.Resolve``1(System.Object[])">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="args">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Resolve">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Resolve.Produce">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Util.Resolve.ActorType">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Resolve.Resolver">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Resolve.SetResolver(Akka.Util.IResolver)">
            <summary>
            TBD
            </summary>
            <param name="resolver">TBD</param>
        </member>
        <member name="M:Akka.Util.Resolve.Release(Akka.Actor.ActorBase)">
            <summary>
            TBD
            </summary>
            <param name="actor">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Resolve`1">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Resolve`1.#ctor(System.Object[])">
            <summary>
            TBD
            </summary>
            <param name="args">TBD</param>
        </member>
        <member name="M:Akka.Util.Resolve`1.Produce">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.InvalidOperationException">
            This exception is thrown if the current <see cref="P:Akka.Util.Resolve.Resolver"/> is undefined.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Util.Resolve`1.ActorType">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.Resolve`1.Arguments">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Util.Result`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Util.Result`1.IsSuccess">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Util.Result`1.Value">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Util.Result`1.Exception">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Result`1.#ctor(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
        </member>
        <member name="M:Akka.Util.Result`1.#ctor(System.Exception)">
            <summary>
            TBD
            </summary>
            <param name="exception">TBD</param>
        </member>
        <member name="M:Akka.Util.Result`1.Equals(Akka.Util.Result{`0})">
            <summary>
            Determines whether the specified <see cref="T:Akka.Util.Result`1" />, is equal to this instance.
            </summary>
            <param name="other">The <see cref="T:Akka.Util.Result`1" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:Akka.Util.Result`1" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Util.Result`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Akka.Util.Result`1.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Akka.Util.Result`1.op_Equality(Akka.Util.Result{`0},Akka.Util.Result{`0})">
            <summary>
            Compares two specified <see cref="T:Akka.Util.Result`1"/> for equality.
            </summary>
            <param name="left">The first <see cref="T:Akka.Util.Result`1"/> used for comparison</param>
            <param name="right">The second <see cref="T:Akka.Util.Result`1"/> used for comparison</param>
            <returns><c>true</c> if both <see cref="T:Akka.Util.Result`1"/> are equal; otherwise <c>false</c></returns>
        </member>
        <member name="M:Akka.Util.Result`1.op_Inequality(Akka.Util.Result{`0},Akka.Util.Result{`0})">
            <summary>
            Compares two specified <see cref="T:Akka.Util.Result`1"/> for inequality.
            </summary>
            <param name="left">The first <see cref="T:Akka.Util.Result`1"/> used for comparison</param>
            <param name="right">The second <see cref="T:Akka.Util.Result`1"/> used for comparison</param>
            <returns><c>true</c> if both <see cref="T:Akka.Util.Result`1"/> are not equal; otherwise <c>false</c></returns>
        </member>
        <member name="T:Akka.Util.Result">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Result.Success``1(``0)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Result.Failure``1(System.Exception)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="exception">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Result.FromTask``1(System.Threading.Tasks.Task{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="task">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Result.From``1(System.Func{``0})">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="func">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.RuntimeDetector">
            <summary>
            Used to detect specific .NET runtimes, to make it easier to adjust for platform specific
            differences.
            </summary>
            <remarks>
            Mostly used for detecting Mono right now because certain features, i.e. IPV6 support, aren't
            fully supported on it. Can also be used for picking platform-specific implementations of things
            such as Akka.Cluster.Metrics implementations.
            </remarks>
        </member>
        <member name="F:Akka.Util.RuntimeDetector.IsMono">
            <summary>
            Is <c>true</c> if we're running on a Mono VM. <c>false</c> otherwise.
            </summary>
        </member>
        <member name="T:Akka.Util.StandardOutWriter">
            <summary>
            This class contains methods for thread safe writing to the standard output stream.
             </summary>
        </member>
        <member name="M:Akka.Util.StandardOutWriter.Write(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Writes the specified <see cref="T:System.String"/> value to the standard output stream. Optionally 
            you may specify which colors should be used.
            </summary>
            <param name="message">The <see cref="T:System.String"/> value to write</param>
            <param name="foregroundColor">Optional: The foreground color</param>
            <param name="backgroundColor">Optional: The background color</param>
        </member>
        <member name="M:Akka.Util.StandardOutWriter.WriteLine(System.String,System.Nullable{System.ConsoleColor},System.Nullable{System.ConsoleColor})">
            <summary>
            Writes the specified <see cref="T:System.String"/> value, followed by the current line terminator,
            to the standard output stream. Optionally you may specify which colors should be used.
            </summary>
            <param name="message">The <see cref="T:System.String"/> value to write</param>
            <param name="foregroundColor">Optional: The foreground color</param>
            <param name="backgroundColor">Optional: The background color</param>
        </member>
        <member name="T:Akka.Util.StringFormat">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.StringFormat.SafeJoin(System.String,System.Object[])">
            <summary>
            Concatenates the values, using the specified separator between the elements.
            This method is similar to <see cref="M:System.String.Join(System.String,System.Object[])"/> except it
            formats null values as &lt;null&gt;
            </summary>
            <param name="separator">The separator.</param>
            <param name="args">The arguments.</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.WildcardMatch">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.WildcardMatch.Like(System.String,System.String,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="text">TBD</param>
            <param name="pattern">TBD</param>
            <param name="caseSensitive">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.Switch">
            <summary>
            An atomic switch that can be either on or off
            </summary>
        </member>
        <member name="M:Akka.Util.Switch.#ctor(System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="startAsOn">TBD</param>
        </member>
        <member name="M:Akka.Util.Switch.TranscendFrom(System.Boolean,System.Action)">
            <summary>
            TBD
            </summary>
            <param name="from">TBD</param>
            <param name="action">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Switch.SwitchOff(System.Action)">
            <summary>
            Executes the provided action if the lock is on. This is done under a lock so be _very_ careful with longrunning/blocking operations in it.
            Only executes the action if the switch is on, and switches it off immediately after obtaining the lock.
            Will switch it back on if the provided action throws an exception.
            </summary>
            <param name="action">TBD</param>
            <returns>Returns <c>true</c> if the switch was switched off</returns>
        </member>
        <member name="M:Akka.Util.Switch.SwitchOn(System.Action)">
            <summary>
            Executes the provided action if the lock is off. This is done under a lock so be _very_ careful with longrunning/blocking operations in it.
            Only executes the action if the switch is off, and switches it on immediately after obtaining the lock.
            Will switch it back off if the provided action throws an exception.
            </summary>
            <param name="action">TBD</param>
            <returns>Returns <c>true</c> if the switch was switched on</returns>
        </member>
        <member name="M:Akka.Util.Switch.SwitchOff">
            <summary>
            Switches the switch off (if on). Uses locking.
            </summary>
            <returns>Returns <c>true</c> if the switch was switched off</returns>
        </member>
        <member name="M:Akka.Util.Switch.SwitchOn">
            <summary>
            Switches the switch on (if off). Uses locking.
            </summary>
            <returns>Returns <c>true</c> if the switch was switched on</returns>
        </member>
        <member name="M:Akka.Util.Switch.IfOn(System.Action)">
            <summary>
            Executes the provided action and returns if the action was executed or not, if the switch is IMMEDIATELY on (i.e. no lock involved)
            </summary>
            <param name="action">The action.</param>
            <returns>Return <c>true</c> if the switch was on</returns>
        </member>
        <member name="M:Akka.Util.Switch.IfOff(System.Action)">
            <summary>
            Executes the provided action and returns if the action was executed or not, if the switch is IMMEDIATELY off (i.e. no lock involved)
            </summary>
            <param name="action">The action.</param>
            <returns>Return <c>true</c> if the switch was off</returns>
        </member>
        <member name="M:Akka.Util.Switch.WhileOn(System.Action)">
            <summary>
            Executes the provided action and returns if the action was executed or not, if the switch is on, waiting for any pending changes to happen before (locking)
            Be careful of longrunning or blocking within the provided action as it can lead to deadlocks or bad performance
            </summary>
            <param name="action">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.Switch.WhileOff(System.Action)">
            <summary>
            Executes the provided action and returns if the action was executed or not, if the switch is off, waiting for any pending changes to happen before (locking)
            Be careful of longrunning or blocking within the provided action as it can lead to deadlocks or bad performance
            </summary>
            <param name="action">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Util.Switch.IsOn">
            <summary>
            Gets a value indicating whether this switch is on. No locking.
            </summary>
            <value>
              <c>true</c> if this instance is on; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Akka.Util.Switch.IsOff">
            <summary>
            Gets a value indicating whether this switch is off. No locking.
            </summary>
            <value>
              <c>true</c> if this instance is off; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:Akka.Util.Switch.Locked(System.Action)">
            <summary>
            TBD
            </summary>
            <param name="action">TBD</param>
        </member>
        <member name="T:Akka.Util.ThreadLocalRandom">
            <summary>
            Create random numbers with Thread-specific seeds.
            
            Borrowed form Jon Skeet's brilliant C# in Depth: http://csharpindepth.com/Articles/Chapter12/Random.aspx
            </summary>
        </member>
        <member name="P:Akka.Util.ThreadLocalRandom.Current">
            <summary>
            The current random number seed available to this thread
            </summary>
        </member>
        <member name="T:Akka.Util.TokenBucket">
            <summary>
            INTERNAL API
            </summary>
        </member>
        <member name="M:Akka.Util.TokenBucket.#ctor(System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Util.TokenBucket"/> class.
            </summary>
            <param name="capacity">TBD</param>
            <param name="ticksBetweenTokens">TBD</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown when either the specified <paramref name="capacity"/> is less than zero
            or the specified <paramref name="ticksBetweenTokens"/> is less than or equal to zero.
            </exception>
        </member>
        <member name="M:Akka.Util.TokenBucket.Init">
            <summary>
            This method must be called before the token bucket can be used.
            </summary>
        </member>
        <member name="P:Akka.Util.TokenBucket.CurrentTime">
            <summary>
            The current time in ticks. The returned value is monotonic, might wrap over and has no relationship with wall-clock. 
            </summary>
            <returns>The current time in ticks as Long</returns>
        </member>
        <member name="M:Akka.Util.TokenBucket.Offer(System.Int64)">
             <summary>
             Call this (side-effecting) method whenever an element should be passed through the token-bucket. This method
             will return the number of nanoseconds the element needs to be delayed to conform with the token bucket parameters.
             Returns zero if the element can be emitted immediately. The method does not handle overflow, if an element is to
             be delayed longer in nanoseconds than what can be represented as a positive Long then an undefined value is returned.
            
             If a non-zero value is returned, it is the responsibility of the caller to not call this method before the
             returned delay has been elapsed (but can be called later). This class does not check or protect against early
             calls. 
             </summary>
             <param name="cost">How many tokens the element costs. Can be larger than the capacity of the bucket.</param>
             <exception cref="T:System.ArgumentException">
             This exception is thrown when the specified <paramref name="cost"/> is less than zero.
             </exception>
             <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.TickTimeTokenBucket">
            <summary>
            Default implementation of <see cref="T:Akka.Util.TokenBucket"/> that uses <see cref="P:System.DateTime.Ticks"/> as the time source.
            </summary>
        </member>
        <member name="M:Akka.Util.TickTimeTokenBucket.#ctor(System.Int64,System.Int64)">
            <summary>
            TBD
            </summary>
            <param name="capacity">TBD</param>
            <param name="period">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Util.TickTimeTokenBucket.CurrentTime">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Util.TypeExtensions">
            <summary>
            Class TypeExtensions.
            </summary>
        </member>
        <member name="M:Akka.Util.TypeExtensions.Implements``1(System.Type)">
            <summary>
            Returns true if <paramref name="type" /> implements/inherits <typeparamref name="T" />.
            <example><para>typeof(object[]).Implements&lt;IEnumerable&gt;() --&gt; true</para></example>
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="type">The type.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Util.TypeExtensions.Implements(System.Type,System.Type)">
            <summary>
            Returns true if <paramref name="type" /> implements/inherits <paramref name="moreGeneralType" />.
            <example><para>typeof(object[]).Implements(typeof(IEnumerable)) --&gt; true</para></example>
            </summary>
            <param name="type">The type.</param>
            <param name="moreGeneralType">Type of the more general.</param>
            <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Akka.Util.TypeExtensions.TypeQualifiedName(System.Type)">
            <summary>
            Utility to be used by implementors to create a manifest from the type.
            The manifest is used to look up the type on deserialization.
            </summary>
            <param name="type">TBD</param>
            <returns>Returns the type qualified name including namespace and assembly, but not assembly version.</returns>
        </member>
        <member name="T:Akka.Util.Vector">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.Vector.Fill``1(System.Int32)">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <param name="number">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Util.WildcardTree`1">
            <summary>
            A searchable nested dictionary, represents a searchable tree structure underneath
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Util.WildcardTree`1.#ctor">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.WildcardTree`1.#ctor(`0,System.Collections.Generic.IDictionary{System.String,Akka.Util.WildcardTree{`0}})">
            <summary>
            TBD
            </summary>
            <param name="data">TBD</param>
            <param name="children">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Util.WildcardTree`1.Data">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Util.WildcardTree`1.Children">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Util.WildcardTree`1.Insert(System.Collections.Generic.IEnumerator{System.String},`0)">
            <summary>
            TBD
            </summary>
            <param name="elements">TBD</param>
            <param name="data">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.WildcardTree`1.Find(System.Collections.Generic.IEnumerator{System.String})">
            <summary>
            TBD
            </summary>
            <param name="elements">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.WildcardTree`1.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Util.WildcardTree`1.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="F:Akka.Util.WildcardTree`1.Empty">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Tools.MatchHandler.Argument">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.Argument.#ctor(Akka.Tools.MatchHandler.PredicateAndHandler,System.Object,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="predicateAndHandler">TBD</param>
            <param name="value">TBD</param>
            <param name="valueIsActionOrFunc">TBD</param>
        </member>
        <member name="P:Akka.Tools.MatchHandler.Argument.PredicateAndHandler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Tools.MatchHandler.Argument.Value">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Tools.MatchHandler.Argument.ValueIsActionOrFunc">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Tools.MatchHandler.CachedMatchCompiler`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="F:Akka.Tools.MatchHandler.CachedMatchCompiler`1.Instance">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.CachedMatchCompiler`1.#ctor(Akka.Tools.MatchHandler.IMatchExpressionBuilder,Akka.Tools.MatchHandler.IPartialActionBuilder,Akka.Tools.MatchHandler.ILambdaExpressionCompiler)">
            <summary>
            TBD
            </summary>
            <param name="expressionBuilder">TBD</param>
            <param name="actionBuilder">TBD</param>
            <param name="expressionCompiler">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.CachedMatchCompiler`1.Compile(System.Collections.Generic.IReadOnlyList{Akka.Tools.MatchHandler.TypeHandler},System.Collections.Generic.IReadOnlyList{Akka.Tools.MatchHandler.Argument},Akka.Tools.MatchHandler.MatchBuilderSignature)">
            <summary>
            TBD
            </summary>
            <param name="handlers">TBD</param>
            <param name="capturedArguments">TBD</param>
            <param name="signature">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Tools.MatchHandler.CachedMatchCompiler`1.CompileToMethod(System.Collections.Generic.IReadOnlyList{Akka.Tools.MatchHandler.TypeHandler},System.Collections.Generic.IReadOnlyList{Akka.Tools.MatchHandler.Argument},Akka.Tools.MatchHandler.MatchBuilderSignature,System.Reflection.Emit.TypeBuilder,System.String,System.Reflection.MethodAttributes)">
            <summary>
            TBD
            </summary>
            <param name="handlers">TBD</param>
            <param name="capturedArguments">TBD</param>
            <param name="signature">TBD</param>
            <param name="typeBuilder">TBD</param>
            <param name="methodName">TBD</param>
            <param name="methodAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.CompiledMatchHandlerWithArguments">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.CompiledMatchHandlerWithArguments.#ctor(System.Delegate,System.Object[])">
            <summary>
            TBD
            </summary>
            <param name="compiledDelegate">TBD</param>
            <param name="delegateArguments">TBD</param>
        </member>
        <member name="P:Akka.Tools.MatchHandler.CompiledMatchHandlerWithArguments.CompiledDelegate">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Tools.MatchHandler.CompiledMatchHandlerWithArguments.DelegateArguments">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Tools.MatchHandler.HandlerKind">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Tools.MatchHandler.HandlerKind.Action">
            <summary>The handler is a Action&lt;T&gt;</summary>
        </member>
        <member name="F:Akka.Tools.MatchHandler.HandlerKind.ActionWithPredicate">
            <summary>The handler is a Action&lt;T&gt; and a Predicate&lt;T&gt; is specified</summary>
        </member>
        <member name="F:Akka.Tools.MatchHandler.HandlerKind.Func">
            <summary>The handler is a Func&lt;T, bool&gt;</summary>
        </member>
        <member name="T:Akka.Tools.MatchHandler.ILambdaExpressionCompiler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.ILambdaExpressionCompiler.Compile(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Produces a delegate that represents the lambda expression.
            </summary>
            <param name="expression">The expression to compile</param>
            <returns>A delegate containing the compiled version of the lambda.</returns>
        </member>
        <member name="M:Akka.Tools.MatchHandler.ILambdaExpressionCompiler.CompileToMethod(System.Linq.Expressions.LambdaExpression,System.Reflection.Emit.MethodBuilder)">
            <summary>
            Compiles the lambda into a method definition.
            </summary>
            <param name="expression">The expression to compile</param>
            <param name="method">A <see cref="T:System.Reflection.Emit.MethodBuilder"/> which will be used to hold the lambda's IL.</param>
        </member>
        <member name="T:Akka.Tools.MatchHandler.IMatchCompiler`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.IMatchCompiler`1.Compile(System.Collections.Generic.IReadOnlyList{Akka.Tools.MatchHandler.TypeHandler},System.Collections.Generic.IReadOnlyList{Akka.Tools.MatchHandler.Argument},Akka.Tools.MatchHandler.MatchBuilderSignature)">
            <summary>
            TBD
            </summary>
            <param name="handlers">TBD</param>
            <param name="capturedArguments">TBD</param>
            <param name="signature">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Tools.MatchHandler.IMatchCompiler`1.CompileToMethod(System.Collections.Generic.IReadOnlyList{Akka.Tools.MatchHandler.TypeHandler},System.Collections.Generic.IReadOnlyList{Akka.Tools.MatchHandler.Argument},Akka.Tools.MatchHandler.MatchBuilderSignature,System.Reflection.Emit.TypeBuilder,System.String,System.Reflection.MethodAttributes)">
            <summary>
            TBD
            </summary>
            <param name="handlers">TBD</param>
            <param name="capturedArguments">TBD</param>
            <param name="signature">TBD</param>
            <param name="typeBuilder">TBD</param>
            <param name="methodName">TBD</param>
            <param name="methodAttributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.IMatchExpressionBuilder">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.IMatchExpressionBuilder.BuildLambdaExpression(System.Collections.Generic.IReadOnlyList{Akka.Tools.MatchHandler.TypeHandler})">
            <summary>
            TBD
            </summary>
            <param name="typeHandlers">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Tools.MatchHandler.IMatchExpressionBuilder.CreateArgumentValuesArray(System.Collections.Generic.IReadOnlyList{Akka.Tools.MatchHandler.Argument})">
            <summary>
            TBD
            </summary>
            <param name="arguments">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.IPartialActionBuilder">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.IPartialActionBuilder.Build``1(Akka.Tools.MatchHandler.CompiledMatchHandlerWithArguments)">
            <summary>
            Builds the specified delegate and arguments to a <see cref="T:Akka.Tools.MatchHandler.PartialAction`1"/>
            <para>If the number of arguments are 0, the delegate should be a <see cref="T:System.Func`1">Func&lt;<typeparamref name="T"/>,bool&gt;</see></para>
            <para>If the number of arguments are 1, the delegate should be a <see cref="T:System.Func`2">Func&lt;<typeparamref name="T"/>,T1,bool&gt;</see></para>
            <para>...</para>
            <para>If the number of arguments are n, the delegate should be a Func&lt;<typeparamref name="T"/>,T1,...,Tn,bool&gt;</para>
            <para>The maximum number of arguments i.e. n in the above example is therefore <see cref="F:Akka.Tools.MatchHandler.PartialActionBuilder.MaxNumberOfArguments"/>=14</para>
            <para>Given a delegate deleg of type Func&lt;<typeparamref name="T"/>,T1,...,Tn,bool&gt; and args [a_1,...a_n] then 
            the delegate corresponding to this code is returned:
            <example>(value) => deleg(value,a_1, ..., a_n)</example>
            </para>
            </summary>
            <typeparam name="T">The type of the value parameter in to the returned <see cref="T:Akka.Tools.MatchHandler.PartialAction`1"/></typeparam>
            <param name="handlerAndArgs">The handler, i.e. a Func&lt;<typeparamref name="T"/>,T1,...,Tn,bool&gt; and arguments [a_1,...a_n].</param>
            <returns>Returns a <see cref="T:Akka.Tools.MatchHandler.PartialAction`1"/> that calls the delegate with the arguments.</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.LambdaExpressionCompiler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.LambdaExpressionCompiler.Compile(System.Linq.Expressions.LambdaExpression)">
            <summary>
            TBD
            </summary>
            <param name="expression">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Tools.MatchHandler.LambdaExpressionCompiler.CompileToMethod(System.Linq.Expressions.LambdaExpression,System.Reflection.Emit.MethodBuilder)">
            <summary>
            TBD
            </summary>
            <param name="expression">TBD</param>
            <param name="method"></param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.MatchBuilder`1">
            <summary>
            TBD
            </summary>
            <typeparam name="TItem">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.#ctor(Akka.Tools.MatchHandler.IMatchCompiler{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Tools.MatchHandler.MatchBuilder`1"/> class.
            </summary>
            <param name="compiler">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if the given <paramref name="compiler"/> is undefined.
            </exception>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Match``1(System.Action{``0},System.Predicate{``0})">
            <summary>
            Adds a handler that is called if the item being matched is of type <typeparamref name="T"/>
            and <paramref name="shouldHandle"/>, if it has been specified, returns <c>true</c>.
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type that it must match in order for <paramref name="handler"/> to be called.</typeparam>
            <param name="handler">The handler that is invoked when everything matches.</param>
            <param name="shouldHandle">An optional predicate to test if the item matches. If it returns <c>true</c> the <paramref name="handler"/> is invoked.</param>
            <exception cref="T:System.InvalidOperationException">
            This exception is thrown if a handler that catches all messages has been added or a partial action has already been built. 
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            This exception is thrown if the current state is unknown.
            </exception>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Match(System.Type,System.Action{`0},System.Predicate{`0})">
            <summary>
            Adds a handler that is called if the item being matched is of type <paramref name="handlesType"/>
            and <paramref name="shouldHandle"/>, if it has been specified, returns <c>true</c>.
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
            <param name="handlesType">The type that it must match in order for <paramref name="handler"/> to be called.</param>
            <param name="handler">The handler that is invoked when everything matches.</param>
            <param name="shouldHandle">An optional predicate to test if the item matches. If it returns <c>true</c> the <paramref name="handler"/> is invoked.</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the given <paramref name="handler"/> cannot handle the given <paramref name="handlesType"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            This exception is thrown if the current state is unknown.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            This exception is thrown if a handler that catches all messages has been added or a partial action has already been built. 
            </exception>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Match``1(System.Func{``0,System.Boolean})">
            <summary>
            Adds a handler that is called if the item being matched is of type <typeparamref name="T"/>.
            The handler should return <c>true</c> if the item sent in matched and was handled.
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
            <typeparam name="T">The type that it must match in order for <paramref name="handler"/> to be called.</typeparam>
            <param name="handler">The handler that is invoked. It should return <c>true</c> if the item sent in matched and was handled.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            This exception is thrown if the current state is unknown.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            This exception is thrown if a handler that catches all messages has been added or a partial action has already been built. 
            </exception>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Match(System.Type,System.Func{`0,System.Boolean})">
            <summary>
            Adds a handler that is called if the item being matched is of type <paramref name="handlesType"/>.
            The handler should return <c>true</c> if the item sent in matched and was handled.
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
            <param name="handlesType">The type that it must match in order for <paramref name="handler"/> to be called.</param>
            <param name="handler">The handler that is invoked. It should return <c>true</c> if the item sent in matched and was handled.</param>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the given <paramref name="handler"/> cannot handle the given <paramref name="handlesType"/>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            This exception is thrown if the current state is unknown.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            This exception is thrown if a handler that catches all messages has been added or a partial action has already been built. 
            </exception>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.MatchAny(System.Action{`0})">
            <summary>
            Adds a handler that is invoked no matter the type the item being matched is.
            <remarks>Note that since this matches all items, no more handlers may be added after this one.</remarks>
            <remarks>Note that if a previous added handler handled the item, this <paramref name="handler"/> will not be invoked.</remarks>
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.Build">
            <summary>
            Builds all added handlers and returns a <see cref="T:Akka.Tools.MatchHandler.PartialAction`1"/>.
            </summary>
            <returns>Returns a <see cref="T:Akka.Tools.MatchHandler.PartialAction`1"/></returns>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder`1.BuildToMethod(System.Reflection.Emit.TypeBuilder,System.String,System.Reflection.MethodAttributes)">
            <summary>
            TBD
            </summary>
            <param name="typeBuilder">TBD</param>
            <param name="methodName">TBD</param>
            <param name="attributes">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.MatchBuilder">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilder.#ctor(Akka.Tools.MatchHandler.IMatchCompiler{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="compiler">TBD</param>
        </member>
        <member name="T:Akka.Tools.MatchHandler.MatchBuilderSignature">
            <summary>
            This class contains the handled <see cref="T:System.Type">Types</see> and <see cref="T:Akka.Tools.MatchHandler.HandlerKind">HandlerKinds</see> 
            that has been added to a <see cref="T:Akka.Tools.MatchHandler.MatchBuilder"/>.
            Two signatures are equal if they contain the same <see cref="T:System.Type">Types</see> and <see cref="T:Akka.Tools.MatchHandler.HandlerKind">HandlerKinds</see>
            in the same order.
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilderSignature.#ctor(System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="signature">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilderSignature.Equals(Akka.Tools.MatchHandler.MatchBuilderSignature)">
            <summary>
            TBD
            </summary>
            <param name="other">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilderSignature.Equals(System.Object)">
            <summary>
            TBD
            </summary>
            <param name="obj">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilderSignature.GetHashCode">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchBuilderSignature.ToString">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.MatchExpressionBuilder`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchExpressionBuilder`1.BuildLambdaExpression(System.Collections.Generic.IReadOnlyList{Akka.Tools.MatchHandler.TypeHandler})">
            <summary>
            TBD
            </summary>
            <param name="typeHandlers">TBD</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            This exception is thrown if the an unknown <see cref="P:Akka.Tools.MatchHandler.PredicateAndHandler.HandlerKind"/> is contained
            in a <see cref="P:Akka.Tools.MatchHandler.TypeHandler.Handlers"/> in the given <paramref name="typeHandlers"/>.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchExpressionBuilder`1.CreateArgumentValuesArray(System.Collections.Generic.IReadOnlyList{Akka.Tools.MatchHandler.Argument})">
            <summary>
            TBD
            </summary>
            <param name="arguments">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.MatchExpressionBuilderResult">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.MatchExpressionBuilderResult.#ctor(System.Linq.Expressions.LambdaExpression,System.Object[])">
            <summary>
            TBD
            </summary>
            <param name="lambdaExpression">TBD</param>
            <param name="arguments">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Akka.Tools.MatchHandler.MatchExpressionBuilderResult.LambdaExpression">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Tools.MatchHandler.MatchExpressionBuilderResult.Arguments">
            <summary>
            TBD
            </summary>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialAction`1">
            <summary>
            An action that returns <c>true</c> if the <paramref name="item"/> was handled.
            </summary>
            <typeparam name="T">The type of the argument</typeparam>
            <param name="item">The argument.</param>
            <returns>Returns <c>true</c> if the <paramref name="item"/> was handled</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialActionBuilder">
            <summary>
            TBD
            </summary>
        </member>
        <member name="F:Akka.Tools.MatchHandler.PartialActionBuilder.MaxNumberOfArguments">
            <summary>
            The maximum number of arguments=15 not including the obligatory first value argument in a partial action. 
            16 is the maximum number of args in a Func, see <see cref="T:System.Func`17"/>
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialActionBuilder.Build``1(Akka.Tools.MatchHandler.CompiledMatchHandlerWithArguments)">
            <summary>
            Builds the specified delegate and arguments to a <see cref="T:Akka.Tools.MatchHandler.PartialAction`1" /><para>If the number of arguments are 0, the delegate should be a <see cref="T:System.Func`1">Func&lt;<typeparamref name="T" />,bool&gt;</see></para><para>If the number of arguments are 1, the delegate should be a <see cref="T:System.Func`2">Func&lt;<typeparamref name="T" />,T1,bool&gt;</see></para><para>...</para><para>If the number of arguments are n, the delegate should be a Func&lt;<typeparamref name="T" />,T1,...,Tn,bool&gt;</para><para>The maximum number of arguments i.e. n in the above example is therefore <see cref="F:Akka.Tools.MatchHandler.PartialActionBuilder.MaxNumberOfArguments" />=14</para><para>Given a delegate deleg of type Func&lt;<typeparamref name="T" />,T1,...,Tn,bool&gt; and args [a_1,...a_n] then
            the delegate corresponding to this code is returned:
            <example>(value) =&gt; deleg(value,a_1, ..., a_n)</example></para>
            </summary>
            <typeparam name="T">The type of the value parameter in to the returned <see cref="T:Akka.Tools.MatchHandler.PartialAction`1" /></typeparam>
            <param name="handlerAndArgs">The handler, i.e. a Func&lt;<typeparamref name="T" />,T1,...,Tn,bool&gt; and arguments [a_1,...a_n].</param>
            <returns>
            Returns a <see cref="T:Akka.Tools.MatchHandler.PartialAction`1" /> that calls the delegate with the arguments.
            </returns>
            <exception cref="T:System.ArgumentException">
            This exception is thrown if the number of arguments in the given <paramref name="handlerAndArgs"/> exceeds the configured <see cref="F:Akka.Tools.MatchHandler.PartialActionBuilder.MaxNumberOfArguments"/>.
            </exception>
        </member>
        <member name="T:Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture`1.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Tools.MatchHandler.IPartialHandlerArgumentsCapture`1.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="message">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`1">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`1.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`1.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`2">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`2.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`2.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`3">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`3.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`3.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`4">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`4.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`4.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`5">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`5.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`5.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`6">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`6.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`6.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`7">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`7.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`7.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`8">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
            <typeparam name="T7">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`8.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`8.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`9">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
            <typeparam name="T7">TBD</typeparam>
            <typeparam name="T8">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`9.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`9.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`10">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
            <typeparam name="T7">TBD</typeparam>
            <typeparam name="T8">TBD</typeparam>
            <typeparam name="T9">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`10.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`10.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`11">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
            <typeparam name="T7">TBD</typeparam>
            <typeparam name="T8">TBD</typeparam>
            <typeparam name="T9">TBD</typeparam>
            <typeparam name="T10">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`11.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`11.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`12">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
            <typeparam name="T7">TBD</typeparam>
            <typeparam name="T8">TBD</typeparam>
            <typeparam name="T9">TBD</typeparam>
            <typeparam name="T10">TBD</typeparam>
            <typeparam name="T11">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`12.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`12.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`13">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
            <typeparam name="T7">TBD</typeparam>
            <typeparam name="T8">TBD</typeparam>
            <typeparam name="T9">TBD</typeparam>
            <typeparam name="T10">TBD</typeparam>
            <typeparam name="T11">TBD</typeparam>
            <typeparam name="T12">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`13.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`13.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`14">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
            <typeparam name="T7">TBD</typeparam>
            <typeparam name="T8">TBD</typeparam>
            <typeparam name="T9">TBD</typeparam>
            <typeparam name="T10">TBD</typeparam>
            <typeparam name="T11">TBD</typeparam>
            <typeparam name="T12">TBD</typeparam>
            <typeparam name="T13">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`14.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`14.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`15">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
            <typeparam name="T7">TBD</typeparam>
            <typeparam name="T8">TBD</typeparam>
            <typeparam name="T9">TBD</typeparam>
            <typeparam name="T10">TBD</typeparam>
            <typeparam name="T11">TBD</typeparam>
            <typeparam name="T12">TBD</typeparam>
            <typeparam name="T13">TBD</typeparam>
            <typeparam name="T14">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`15.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`15.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`16">
            <summary>
            TBD
            </summary>
            <typeparam name="T">TBD</typeparam>
            <typeparam name="T1">TBD</typeparam>
            <typeparam name="T2">TBD</typeparam>
            <typeparam name="T3">TBD</typeparam>
            <typeparam name="T4">TBD</typeparam>
            <typeparam name="T5">TBD</typeparam>
            <typeparam name="T6">TBD</typeparam>
            <typeparam name="T7">TBD</typeparam>
            <typeparam name="T8">TBD</typeparam>
            <typeparam name="T9">TBD</typeparam>
            <typeparam name="T10">TBD</typeparam>
            <typeparam name="T11">TBD</typeparam>
            <typeparam name="T12">TBD</typeparam>
            <typeparam name="T13">TBD</typeparam>
            <typeparam name="T14">TBD</typeparam>
            <typeparam name="T15">TBD</typeparam>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`16.Initialize(System.Delegate,System.Collections.Generic.IReadOnlyList{System.Object})">
            <summary>
            TBD
            </summary>
            <param name="handler">TBD</param>
            <param name="arguments">TBD</param>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PartialHandlerArgumentsCapture`16.Handle(`0)">
            <summary>
            TBD
            </summary>
            <param name="value">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.PredicateAndHandler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Tools.MatchHandler.PredicateAndHandler.HandlerKind">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Tools.MatchHandler.PredicateAndHandler.Arguments">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Tools.MatchHandler.PredicateAndHandler.HandlerFirstArgumentShouldBeBaseType">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Tools.MatchHandler.PredicateAndHandler.ActionOrFuncExpression">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Tools.MatchHandler.PredicateAndHandler.PredicateExpression">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PredicateAndHandler.CreateAction(System.Object,System.Object,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="action">TBD</param>
            <param name="predicate">TBD</param>
            <param name="handlerFirstArgumentShouldBeBaseType">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="M:Akka.Tools.MatchHandler.PredicateAndHandler.CreateFunc(System.Object,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="func">TBD</param>
            <param name="handlerFirstArgumentShouldBeBaseType">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="T:Akka.Tools.MatchHandler.TypeHandler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.TypeHandler.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Akka.Tools.MatchHandler.TypeHandler"/> class.
            </summary>
            <param name="handlesType">TBD</param>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if the given <paramref name="handlesType"/> is undefined.
            </exception>
        </member>
        <member name="P:Akka.Tools.MatchHandler.TypeHandler.HandlesType">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Akka.Tools.MatchHandler.TypeHandler.Handlers">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Akka.Tools.MatchHandler.TypeHandler.GetArguments">
            <summary>
            TBD
            </summary>
            <returns>TBD</returns>
        </member>
        <member name="T:Helios.Concurrency.ThreadType">
            <summary>
            The type of threads to use - either foreground or background threads.
            </summary>
        </member>
        <member name="T:Helios.Concurrency.DedicatedThreadPoolSettings">
            <summary>
            Provides settings for a dedicated thread pool
            </summary>
        </member>
        <member name="F:Helios.Concurrency.DedicatedThreadPoolSettings.DefaultThreadType">
            <summary>
            Background threads are the default thread type
            </summary>
        </member>
        <member name="M:Helios.Concurrency.DedicatedThreadPoolSettings.#ctor(System.Int32,System.String,System.Nullable{System.TimeSpan},System.Threading.ApartmentState,System.Action{System.Exception},System.Int32)">
            <summary>
            TBD
            </summary>
            <param name="numThreads">TBD</param>
            <param name="name">TBD</param>
            <param name="deadlockTimeout">TBD</param>
            <param name="apartmentState">TBD</param>
            <param name="exceptionHandler">TBD</param>
            <param name="threadMaxStackSize">TBD</param>
        </member>
        <member name="M:Helios.Concurrency.DedicatedThreadPoolSettings.#ctor(System.Int32,Helios.Concurrency.ThreadType,System.String,System.Nullable{System.TimeSpan},System.Threading.ApartmentState,System.Action{System.Exception},System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Helios.Concurrency.DedicatedThreadPoolSettings"/> class.
            </summary>
            <param name="numThreads">TBD</param>
            <param name="threadType">TBD</param>
            <param name="name">TBD</param>
            <param name="deadlockTimeout">TBD</param>
            <param name="apartmentState">TBD</param>
            <param name="exceptionHandler">TBD</param>
            <param name="threadMaxStackSize">TBD</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            This exception is thrown if the given <paramref name="deadlockTimeout"/> is set to less than 1ms.
            It can also be thrown if the given <paramref name="numThreads"/> is set to less than one.
            </exception>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.NumThreads">
            <summary>
            The total number of threads to run in this thread pool.
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.ThreadType">
            <summary>
            The type of threads to run in this thread pool.
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.ApartmentState">
            <summary>
            Apartment state for threads to run in this thread pool
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.DeadlockTimeout">
            <summary>
            Interval to check for thread deadlocks.
            
            If a thread takes longer than <see cref="P:Helios.Concurrency.DedicatedThreadPoolSettings.DeadlockTimeout"/> it will be aborted
            and replaced.
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.Name">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.ExceptionHandler">
            <summary>
            TBD
            </summary>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolSettings.ThreadMaxStackSize">
            <summary>
            Gets the thread stack size, 0 represents the default stack size.
            </summary>
        </member>
        <member name="T:Helios.Concurrency.DedicatedThreadPoolTaskScheduler">
            <summary>
            TaskScheduler for working with a <see cref="T:Helios.Concurrency.DedicatedThreadPool"/> instance
            </summary>
        </member>
        <member name="F:Helios.Concurrency.DedicatedThreadPoolTaskScheduler._parallelWorkers">
            <summary>
            Number of tasks currently running
            </summary>
        </member>
        <member name="M:Helios.Concurrency.DedicatedThreadPoolTaskScheduler.#ctor(Helios.Concurrency.DedicatedThreadPool)">
            <summary>
            TBD
            </summary>
            <param name="pool">TBD</param>
        </member>
        <member name="M:Helios.Concurrency.DedicatedThreadPoolTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>
            TBD
            </summary>
            <param name="task">TBD</param>
        </member>
        <member name="M:Helios.Concurrency.DedicatedThreadPoolTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="task">TBD</param>
            <param name="taskWasPreviouslyQueued">TBD</param>
        </member>
        <member name="M:Helios.Concurrency.DedicatedThreadPoolTaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
            <summary>
            TBD
            </summary>
            <param name="task">TBD</param>
            <returns>TBD</returns>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPoolTaskScheduler.MaximumConcurrencyLevel">
            <summary>
            Level of concurrency is directly equal to the number of threads
            in the <see cref="T:Helios.Concurrency.DedicatedThreadPool"/>.
            </summary>
        </member>
        <member name="M:Helios.Concurrency.DedicatedThreadPoolTaskScheduler.GetScheduledTasks">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.NotSupportedException">
            This exception is thrown if can't ensure a thread-safe return of the list of tasks.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="T:Helios.Concurrency.DedicatedThreadPool">
            <summary>
            An instanced, dedicated thread pool.
            </summary>
        </member>
        <member name="M:Helios.Concurrency.DedicatedThreadPool.#ctor(Helios.Concurrency.DedicatedThreadPoolSettings)">
            <summary>
            TBD
            </summary>
            <param name="settings">TBD</param>
        </member>
        <member name="P:Helios.Concurrency.DedicatedThreadPool.Settings">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Helios.Concurrency.DedicatedThreadPool.QueueUserWorkItem(System.Action)">
            <summary>
            TBD
            </summary>
            <exception cref="T:System.ArgumentNullException">
            This exception is thrown if the given <paramref name="work"/> item is undefined.
            </exception>
            <returns>TBD</returns>
        </member>
        <member name="M:Helios.Concurrency.DedicatedThreadPool.Dispose">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Helios.Concurrency.DedicatedThreadPool.WaitForThreadsExit">
            <summary>
            TBD
            </summary>
        </member>
        <member name="M:Helios.Concurrency.DedicatedThreadPool.WaitForThreadsExit(System.TimeSpan)">
            <summary>
            TBD
            </summary>
            <param name="timeout">TBD</param>
        </member>
    </members>
</doc>
